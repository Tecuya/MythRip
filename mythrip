#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Fri May 22 10:25:23 2009

# mythrip: GUI tool to export MythTV recordings to various portable media files, and manage recordings in general

import os
import shutil
import sys
import wx
import mythtv
import threading
import subprocess
import socket
import re
import time   # for debugging only so far
import signal
import stat

# begin wxGlade: extracode
# end wxGlade




class threadDetailFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: threadDetailFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.threadDetailLabel = wx.StaticText(self, -1, "Details for thread:")
        self.threadDetailInformation = wx.StaticText(self, -1, "")
        self.static_line_1 = wx.StaticLine(self, -1)
        self.threadMencoderPass1Label = wx.StaticText(self, -1, "mencoder Pass 1 Command:")
        self.threadMencoderPass1Cmd = wx.StaticText(self, -1, "[ Waiting.. ]")
        self.static_line_2 = wx.StaticLine(self, -1)
        self.threadMencoderPass2Label = wx.StaticText(self, -1, "mencoder Pass 2 Command:")
        self.threadMencoderPass2Cmd = wx.StaticText(self, -1, "[ Waiting.. ]")
        self.static_line_3 = wx.StaticLine(self, -1)
        self.closeButton = wx.Button(self, -1, "Close")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.closeButton)
        # end wxGlade
        
        self.Bind(wx.EVT_SIZE, self.onResize, self)
        
    def __set_properties(self):
        # begin wxGlade: threadDetailFrame.__set_properties
        self.SetTitle("Thread Details")
        self.SetSize((578, 335))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: threadDetailFrame.__do_layout
        threadDetailSizer = wx.BoxSizer(wx.VERTICAL)
        threadDetailInfoSizer = wx.BoxSizer(wx.HORIZONTAL)
        threadDetailInfoSizer.Add(self.threadDetailLabel, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        threadDetailInfoSizer.Add(self.threadDetailInformation, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        threadDetailSizer.Add(threadDetailInfoSizer, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.static_line_1, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMencoderPass1Label, 0, 0, 0)
        threadDetailSizer.Add(self.threadMencoderPass1Cmd, 0, 0, 0)
        threadDetailSizer.Add(self.static_line_2, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMencoderPass2Label, 0, 0, 0)
        threadDetailSizer.Add(self.threadMencoderPass2Cmd, 0, 0, 0)
        threadDetailSizer.Add(self.static_line_3, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.closeButton, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 0)
        self.SetSizer(threadDetailSizer)
        self.Layout()
        # end wxGlade

    def setThreadID(self, threadID):        
        self.encoderThread = self.GetParent().threads[ threadID ] 
        self.refreshThreadInfo()
        
    def refreshThreadInfo(self):
        if self.encoderThread.mencoderCmd.has_key(1):
            self.threadMencoderPass1Cmd.SetLabel( " ".join(self.encoderThread.mencoderCmd[1]) )

        if self.encoderThread.mencoderCmd.has_key(2):
            self.threadMencoderPass2Cmd.SetLabel( " ".join(self.encoderThread.mencoderCmd[2]) )
        

    def refreshLayout(self):
        self.refreshThreadInfo() # when i dont call this bad things happen - wrap() calls seem like they can only make text wrap thinner, not wider.. 
        width = self.GetSizeTuple()[0]
        self.threadMencoderPass1Cmd.Wrap( width )
        self.threadMencoderPass2Cmd.Wrap( width )
        self.Layout()

    def onCloseButton(self, event): # wxGlade: threadDetailFrame.<event_handler>
        self.Destroy()
        event.Skip()

    def onRefreshButton(self, event): # wxGlade: threadDetailFrame.<event_handler>
        self.refreshThreadInfo()
        event.Skip()

    def onResize(self, event):
        self.refreshLayout()
        event.Skip()

# end of class threadDetailFrame


class MyFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # content of this block not found: did you rename this class?
        pass

    def __set_properties(self):
        # content of this block not found: did you rename this class?
        pass

    def __do_layout(self):
        # content of this block not found: did you rename this class?
        pass

# end of class MyFrame


class mainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        
        toolbarEncode = wx.NewId()
        toolbarView = wx.NewId()
        toolbarDelete = wx.NewId()
        toolbarPrefs = wx.NewId()
        toolbarReload = wx.NewId()
        toolbarQuit = wx.NewId()

        # begin wxGlade: mainFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.mainFrameMenubar = wx.MenuBar()
        self.fileMenuItem = wx.Menu()
        self.deleteMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Delete", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.deleteMenuItem)
        self.fileMenuItem.AppendSeparator()
        self.quitMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Quit", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.quitMenuItem)
        self.mainFrameMenubar.Append(self.fileMenuItem, "&File")
        self.editMenuItem = wx.Menu()
        self.prefsMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Preferences", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.prefsMenuItem)
        self.mainFrameMenubar.Append(self.editMenuItem, "&Edit")
        self.viewMenuItem = wx.Menu()
        self.queMenuItem = wx.MenuItem(self.viewMenuItem, wx.NewId(), "&Queue", "", wx.ITEM_NORMAL)
        self.viewMenuItem.AppendItem(self.queMenuItem)
        self.mainFrameMenubar.Append(self.viewMenuItem, "&View")
        self.helpMenuItem = wx.Menu()
        self.aboutMenuItem = wx.MenuItem(self.helpMenuItem, wx.NewId(), "&About", "", wx.ITEM_NORMAL)
        self.helpMenuItem.AppendItem(self.aboutMenuItem)
        self.mainFrameMenubar.Append(self.helpMenuItem, "&Help")
        self.SetMenuBar(self.mainFrameMenubar)
        # Menu Bar end
        self.mainFrameStatusbar = self.CreateStatusBar(1, 0)
        
        # Tool Bar
        self.mainFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.mainFrameToolbar)
        self.mainFrameToolbar.AddLabelTool(toolbarReload, "Reload", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/reload.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Reload MythTV Recording List", "")
        self.mainFrameToolbar.AddSeparator()
        self.mainFrameToolbar.AddLabelTool(toolbarView, "View", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-media-play-ltr.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "View selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarEncode, "Encode", wx.Bitmap("/usr/share/icons/gnome/32x32/categories/applications-system.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Encode selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarDelete, "Delete", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/stock_delete.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Delete selected recordings(s)", "")
        self.mainFrameToolbar.AddSeparator()
        self.mainFrameToolbar.AddLabelTool(toolbarPrefs, "Preferences", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Open Preferences Dialog", "")
        self.mainFrameToolbar.AddLabelTool(toolbarQuit, "Quit", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/application-exit.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Quit", "")
        # Tool Bar end
        self.mainFrameListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.LC_EDIT_LABELS|wx.LC_SORT_ASCENDING|wx.SUNKEN_BORDER)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.onMenuDelete, self.deleteMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuQuit, self.quitMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuPrefs, self.prefsMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuQueue, self.queMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuAbout, self.aboutMenuItem)
        self.Bind(wx.EVT_TOOL, self.onToolbarReload, id=toolbarReload)
        self.Bind(wx.EVT_TOOL, self.onToolbarEncode, id=toolbarEncode)
        self.Bind(wx.EVT_TOOL, self.onToolbarDelete, id=toolbarDelete)
        self.Bind(wx.EVT_TOOL, self.onToolbarPrefs, id=toolbarPrefs)
        self.Bind(wx.EVT_TOOL, self.onToolbarQuit, id=toolbarQuit)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.onColClick, self.mainFrameListCtrl)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.onItemRightClick, self.mainFrameListCtrl)
        # end wxGlade

        ################################################################################
        # Various non-wxglade GUI setup

        # set up our child frames
        self.encoderQueueFrame = encoderQueueFrame(parent=self)
        self.preferencesFrame = preferencesFrame(parent=self)

        # bind "OK" button presses in preferences frame to our own event handler
        self.Bind(wx.EVT_BUTTON, self.onPrefsOK, self.preferencesFrame.preferencesOKButton)

        # set up the ListCtrl columns
        self.mainFrameListCtrl.InsertColumn(0, "Show")
        self.mainFrameListCtrl.InsertColumn(1, "Episode")
        self.mainFrameListCtrl.InsertColumn(2, "Air Time")
        self.mainFrameListCtrl.InsertColumn(3, "Flags")

        ###################################################################################
        # preference handling

        # map of options support by the config file and internal prefs

        self.optionMap = ( { 'short': '-P', 'long': '--mysqlport', 'action': 'store', 'dest': 'mysqlPort', 'default': 3306, 'help': 'MythTV MySQL Port', 'autoDiscover': True },
                           { 'short': '-H', 'long': '--mysqlhost', 'action': 'store', 'dest': 'mysqlHost', 'default': 'localhost', 'help': 'MythTV MySQL Host', 'autoDiscover': True},
                           { 'short': '-u', 'long': '--mysqluser', 'action': 'store', 'dest': 'mysqlUser', 'default': 'localhost', 'help': 'MythTV MySQL User', 'autoDiscover': True},
                           { 'short': '-p', 'long': '--mysqlpass', 'action': 'store', 'dest': 'mysqlPassword', 'default': 'localhost', 'help': 'MythTV MySQL Password', 'autoDiscover': True},
                           { 'short': '-d', 'long': '--mysqldb', 'action': 'store', 'dest': 'mysqlDB', 'default': 'localhost', 'help': 'MythTV MySQL Database Name', 'autoDiscover': True},
                           { 'short': '-C', 'long': '--mythcutlist', 'action': 'store', 'dest': 'useMythCutlist', 'default': '0', 'help': 'Use MythTV Cutlist'},
                           { 'short': '-c', 'long': '--container', 'action': 'store', 'dest': 'containerFormat', 'default': '0', 'help' : 'Container format' },
                           { 'short': '-v', 'long': '--videocodec', 'action': 'store', 'dest': 'videoCodec', 'default': '0', 'help' : 'Video Codec Choice Index' },
                           { 'short': '-1', 'long': '--videocodecopts', 'action': 'store', 'dest': 'videoFirstPassOpts', 'default': '', 'help' : 'Video Codec Option String - Pass 1' },
                           { 'short': '-2', 'long': '--videocodecoptspass2', 'action': 'store', 'dest': 'videoSecondPassOpts', 'default': '', 'help' : 'Video Codec Option String - Pass 2' },
                           { 'short': '-f', 'long': '--videofilter', 'action': 'store', 'dest': 'videoFilter', 'default': 'pp=fd', 'help': 'Video Filter String' },
                           { 'short': '-T', 'long': '--twopass', 'action': 'store', 'dest': 'twoPassVideo', 'default': '0', 'help' : 'Two Pass Video Choice Index' },
                           { 'short': '-a', 'long': '--audiocodec', 'action': 'store', 'dest': 'audioCodec', 'default': '0', 'help' : 'Audio Codec Choice Index' },
                           { 'short': '-A', 'long': '--audiocodecopts', 'action': 'store', 'dest': 'audioCodecOptions', 'default': '', 'help' : 'Audio Codec Option String' },
                           { 'short': '-F', 'long': '--audiofilter', 'action': 'store', 'dest': 'audioFilter', 'default': '', 'help' : 'Audio Filter String' },
                           { 'short': '-t', 'long': '--threadcount', 'action': 'store', 'dest': 'threadCount', 'default': '2', 'help' : 'Max Simultaneous Encoding Jobs' },
                           { 'short': '-r', 'long': '--removecompleted', 'action': 'store', 'dest': 'removeCompleted', 'default': '0', 'help' : 'Remove Completed Job Choice Index' },                       
                           { 'short': '-s', 'long': '--savepath', 'action': 'store', 'dest': 'savePath', 'default': os.path.expanduser('~/Desktop'), 'help' : 'Save Encodings to Path' }, 
                           { 'short': '-x', 'long': '--filetemplate', 'action': 'store', 'dest': 'fileTemplate', 'default': '%s - %t.%x', 'help' : 'Output File Naming Template' }
                           )
        # load preferences from disk
        self.loadPrefsFromDisk()
        
        # load preferences from CLI ; these override disk preferences
        self.loadPrefsFromCli()

        # push the prefs we've gathered in to the preferences frame
        self.populatePrefsToChildren()

        ###############################################################################
        # make mythtv connection and load data from it
        
        # a variable to stuff the program list in to
        self.programList = []

        # connect to mythtv
        if self.connectToMyth():

            # load recordings from myth
            self.loadRecordingsFromMyth()

        # prepare the right-click context menu entry definitions
        self.contextMenuEntriesById = {}
        for item in [ "Preview", "Delete", "Encode" ]:
            self.contextMenuEntriesById[ wx.NewId() ] = item

    def __set_properties(self):
        # begin wxGlade: mainFrame.__set_properties
        self.SetTitle("MythRip - Main")
        self.SetSize((720, 430))
        self.mainFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        mainFrameStatusbar_fields = ["mainFrame_statusbar"]
        for i in range(len(mainFrameStatusbar_fields)):
            self.mainFrameStatusbar.SetStatusText(mainFrameStatusbar_fields[i], i)
        self.mainFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: mainFrame.__do_layout
        mainFrameSizer = wx.BoxSizer(wx.HORIZONTAL)
        mainFrameSizer.Add(self.mainFrameListCtrl, 1, wx.EXPAND, 0)
        self.SetSizer(mainFrameSizer)
        self.Layout()
        # end wxGlade

    def connectToMyth(self):        
        # establish our MythTV connection using the mythtv python bindings, push our preferences in to it
        try: 
            self.mythTV = mythtv.MythTV(force_db_opts=self.prefs)
            return True
        except Exception, e:
            self.showErrorDialog("Error connecting to MythTV", "Error connecting to MythTV:\n%s\nPlease alter your MythTV settings in the Preferences Dialog"%str(e))
            # it failed?  send the user to the preferences dialog
            self.preferencesFrame.Show()
            self.mythTV = False
            return False

        
    def loadRecordingsFromMyth(self):

        # delete any listctrl items currently present
        for i in range(len(self.programList)):
            self.mainFrameListCtrl.DeleteItem( self.mainFrameListCtrl.FindItemData(0, i) )

        # reset the programList
        self.programList = []

        # query recordings from the backend
        rawRecordings = self.mythTV.backendCommand('QUERY_RECORDINGS Play').split(mythtv.BACKEND_SEP)            

        if len(rawRecordings):
            # determine the record length and number of recordings present in the response
            numberRecordings = int(rawRecordings[0])        
            recordingLength = (len(rawRecordings) - 1) / numberRecordings

            # parse the output, stuff the results in to a list of Program objects

            for recording in range(numberRecordings):            
                idxStart = ( recording * recordingLength ) + 1    # plus one - offset for the beginning's "record count" record
                idxStop = ( recording + 1 ) * recordingLength     # stop at the next recording beginning

                recordingData = rawRecordings[idxStart:idxStop]

                # print "RECORDING: ",recordingData,"------------------------------------------------------\n\n\n"

                self.programList.append( mythtv.Program( recordingData ) )
            
        # add recording count to the status bar
        self.mainFrameStatusbar.PushStatusText('Loaded %d recordings' % len(self.programList))
        
        
        # push in the ListCtrl data
        for i in range(len(self.programList)):
            program = self.programList[i]
            self.mainFrameListCtrl.InsertStringItem(i, program.title)
            self.mainFrameListCtrl.SetStringItem(i, 1, program.subtitle)
            self.mainFrameListCtrl.SetStringItem(i, 2, str(program.starttime))
            
            # unpack program flags to english strings
            flags = []
            for k,v in mythtv.PROGRAM_FLAGS.iteritems():
                if int(program.programflags) & v:
                    flags.append(k)

            self.mainFrameListCtrl.SetStringItem(i, 3, ', '.join(flags) )
            self.mainFrameListCtrl.SetItemData(i, i)  # set item datas to be the same as indexes initially
            
        # make nice column sizes
        self.mainFrameListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)
        
        # these variables are for preserving the listctrl sorting state
        self.lastColClick = 0
        self.sortToggler = 1

        # run an initial sort
        self.mainFrameListCtrl.SortItems( self.sortList ) 
        

    # this is the callback to sort the mainFrameListCtrl used by mainFrameListCtrl.SortItems
    def sortList(self, item1, item2):
        
        progLeft = self.programList[ item1 ]
        progRight = self.programList[ item2 ]
        
        if self.lastColClick == 0:
            if progLeft.title < progRight.title:
                return -1 * self.sortToggler
            elif progLeft.title == progRight.title:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 1:
            if progLeft.subtitle < progRight.subtitle:
                return -1 * self.sortToggler
            elif progLeft.subtitle == progRight.subtitle:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 2:
            if progLeft.starttime < progRight.starttime:
                return -1 * self.sortToggler
            elif progLeft.starttime == progRight.starttime:
                return 0
            else:
                return 1 * self.sortToggler

        return 0
    
    
    # this function returns a list of the mythtv Program objects that have been selected
    def getSelectedPrograms(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.mainFrameListCtrl.GetFirstSelected()
        while item != -1:
            program = self.programList[ self.mainFrameListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.mainFrameListCtrl.GetNextSelected(item)
        
        return returnList
    
    def addRecordingsToQueue(self):
        
        addcount = 0
        for program in self.getSelectedPrograms():
            self.encoderQueueFrame.addProgram(program)
            addcount += 1

        # automatically show encoder queue when we add to it
        if addcount > 0:
            self.encoderQueueFrame.Show()

        self.mainFrameStatusbar.PushStatusText('Added %d recordings to queue.' % addcount)
        

    def readPrefsFromDisk(self):
        prefs = {}
	cfgfile=os.path.expanduser('~')+'/.mythriprc'
	
	if not os.access(cfgfile,os.F_OK):
	    print "mythrip config file not found, generating a default one in %s for you.." % cfgfile
	    self.resetDiskPrefs()

        # read config file	    
	lines = file(cfgfile,'r').readlines()

	# parse config line by line
	for line in lines:
	    if line[0] != '#':
		delimiterAt = line.find(' ')
		if delimiterAt != -1:
		    opt = line[:delimiterAt].strip()
		    value = line[delimiterAt+1:].rstrip("\n")
		    
		    # try to interpret config options
		    if value.lower() == 'true':
			setvalue = True
		    elif value.lower() == 'false':
			setvalue = False
		    elif value.isdigit():
			setvalue = int(value)
		    else:
			setvalue = value
		    
		    prefs[opt] = setvalue

        return prefs

    def resetDiskPrefs(self):
	cfgfile=os.path.expanduser('~')+'/.mythriprc'
        cfg = file(cfgfile,'w+')
        cfg.write("# Automatically generated mythrip config file.\n\n")
        for option in self.optionMap:
            
            # we avoid writing the mysql options because they are automatically discovered by the self.findMythMysqlSettings
            if option.has_key('autoDiscover'):
                optionPrefix = "# "
            else:
                optionPrefix = ""

            cfg.write("# %s\n%s%s %s\n\n" % (option['help'], optionPrefix, option['dest'], option['default']))

        cfg.close()

    # write a dictionary of options to the configuration file
    def writePrefsToDisk(self):
        print "writePrefsToDisk writing prefs"

	cfgFile=os.path.expanduser('~')+'/.mythriprc'
        
        cfg = file(cfgFile,'w+')
        cfg.write("# Automatically generated mythrip config file.\n\n")

        for option in self.optionMap:

            if self.prefs.has_key( option["dest"] ): # if the option appears in our prefs then save it
                cfg.write("## %s\n%s %s\n\n" % (option["help"], option["dest"], self.prefs[ option["dest"] ]))

        cfg.close()

    # read CLI optparse opts into the self.prefs, if they were given
    def loadPrefsFromCli(self):
	import optparse
	usage = "%prog [options]"
	
        cliparser = optparse.OptionParser(usage=usage)
	
	for option in self.optionMap:
            cliparser.add_option(option['short'],option['long'],action=option['action'],dest=option['dest'],help=option['help'])
	
	(options, files) = cliparser.parse_args()
        
	for option in self.optionMap:
            value = getattr(options, option['dest'])
            if value:
                print "pref ",option['dest']," loaded with value",value,"from cli"
                self.prefs[option['dest']] = value
                
    def populatePrefsToChildren(self):
        self.preferencesFrame.setPreferences( self.prefs )
        self.encoderQueueFrame.setPreferences( self.prefs )

        
    def onPrefsOK(self, event):

        # load the preferences from the prefs frame
        self.prefs = self.preferencesFrame.getPreferences()
        
        self.writePrefsToDisk()

        self.populatePrefsToChildren()

        self.mainFrameStatusbar.PushStatusText('Preferences saved.')

        event.Skip()

    def loadPrefsFromDisk(self):
        
        # load the prefs from disk to self.prefs        
        self.prefs = self.readPrefsFromDisk()
        
        # if we did not load mysqlHost from disk, assume we should try and find the myth settings from the myth config files
        if not self.prefs.has_key("mysqlHost"):
            print "mysql host wasnt loaded from disk; searching for mysql settings"

            mythSettings = self.findMythMysqlSettings()
            print "myth settings acquired",mythSettings

            self.prefs.update( mythSettings )
            
        self.mainFrameStatusbar.PushStatusText('Preferences loaded.')
        
        print "loadPrefsFromDisk returning : ",self.prefs

        
    def findMythMysqlSettings(self):
        # Try to read the mysql.txt file used by MythTV.
        # Order taken from libs/libmyth/mythcontext.cpp
        config_files = [
            '/usr/local/share/mythtv/mysql.txt',
            '/usr/share/mythtv/mysql.txt',
            '/usr/local/etc/mythtv/mysql.txt',
            '/etc/mythtv/mysql.txt',
            os.path.expanduser('~/.mythtv/mysql.txt'),
            ]
        
        if 'MYTHCONFDIR' in os.environ:
            config_locations.append('%s/mysql.txt' % os.environ['MYTHCONFDIR'])

        found_config = False
        for config_file in config_files:

            dbconn_host = None
            dbconn_name = None
            dbconn_user = None
            dbconn_pass = None
            dbconn_port = None

            if not os.access(config_file, os.R_OK): 
                continue

            for line in file(config_file):
                
                if line[0] != '#' and '=' in line:
                    equalPos = line.find('=')

                    key = line[0:equalPos]
                    val = line[equalPos+1:].strip()
                    
                    if key == "DBHostName":
                        dbconn_host = val
                    elif key == "DBPort":
                        dbconn_port = val
                    elif key == "DBName":
                        dbconn_name = val
                    elif key == "DBUserName":
                        dbconn_user = val
                    elif key == "DBPassword":
                        dbconn_pass = val

            if dbconn_host != None or dbconn_name != None or dbconn_user != None or dbconn_pass != None:
                print "found config"
                found_config = True
                break
        
        # we didn't find a config file, just bail out
        if not found_config:
            return {}
        
        
        return {"mysqlHost": dbconn_host,
                "mysqlPort": dbconn_port,
                "mysqlDB": dbconn_name,
                "mysqlUser": dbconn_user,
                "mysqlPassword": dbconn_pass}
    

    def showErrorDialog(self,title,message):
        errorDialog = wx.MessageDialog(parent=self, caption=title, message=message)
        errorDialog.ShowModal()

    ###########################################################################
    # event handler land

        
    def onMenuQuit(self, event): # wxGlade: mainFrame.<event_handler>
        sys.exit()


    def onItemRightClick(self, event): # wxGlade: mainFrame.<event_handler>
        
        menu = wx.Menu()

        for (id,title) in self.contextMenuEntriesById.iteritems():
            menu.Append(id, title)
            wx.EVT_MENU( menu, id, self.onContextMenuSelection )
            
        self.PopupMenu( menu )

        event.Skip()

    def onColClick(self, event): # wxGlade: mainFrame.<event_handler>

        clickedCol = event.GetColumn()

        if (clickedCol == self.lastColClick):
            self.sortToggler *= -1
        else:
            self.sortToggler = 1

        self.lastColClick = clickedCol
        
        self.mainFrameListCtrl.SortItems( self.sortList ) 

        event.Skip()


    def onContextMenuSelection(self, event):        
        selectedMenuItem = self.contextMenuEntriesById[ event.GetId() ]
        if selectedMenuItem == "Encode":
            self.addRecordingsToQueue()
        event.Skip()
        
    def onMenuQueue(self, event): # wxGlade: mainFrame.<event_handler>        
        print "showing encoderQueueFrame.."
        self.encoderQueueFrame.Show()
        event.Skip()

    def onToolbarEncode(self, event): # wxGlade: mainFrame.<event_handler>
        self.addRecordingsToQueue()
        event.Skip()

    def onToolbarDelete(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarDelete' not implemented"
        event.Skip()

    def onMenuDelete(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onMenuDelete' not implemented"
        event.Skip()

    def onMenuPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        self.preferencesFrame.Show()
        event.Skip()

    def onToolbarPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        self.preferencesFrame.Show()
        event.Skip()

    def onToolbarQuit(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarQuit' not implemented"
        event.Skip()

    def onToolbarReload(self, event): # wxGlade: mainFrame.<event_handler>
        if not self.mythTV:
            self.connectToMyth()
            
        if self.mythTV:
            self.loadRecordingsFromMyth()
        else:
            self.mainFrameStatusbar.PushStatusText('No recordings loaded.')

        event.Skip()

    def onMenuAbout(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onMenuAbout' not implemented"
        event.Skip()

# end of class mainFrame





class aboutFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: aboutFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.aboutFrameContents = wx.StaticText(self, -1, "About MythRIP", style=wx.ALIGN_CENTRE)
        self.aboutFrameCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: aboutFrame.__set_properties
        self.SetTitle("MythRip - About")
        self.aboutFrameCloseButton.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: aboutFrame.__do_layout
        aboutFrameSizer = wx.BoxSizer(wx.VERTICAL)
        aboutFrameSizer.Add(self.aboutFrameContents, 0, wx.BOTTOM|wx.EXPAND, 0)
        aboutFrameSizer.Add(self.aboutFrameCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(aboutFrameSizer)
        aboutFrameSizer.Fit(self)
        self.Layout()
        # end wxGlade

# end of class aboutFrame


class encoderOptionsFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: encoderOptionsFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.encoderOptionsFrameStatusbar = self.CreateStatusBar(1, 0)

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: encoderOptionsFrame.__set_properties
        self.SetTitle("MythRip - Encoder Options")
        self.SetSize((400, 300))
        self.encoderOptionsFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        encoderOptionsFrameStatusbar_fields = ["encoderOptionsFrame_statusbar"]
        for i in range(len(encoderOptionsFrameStatusbar_fields)):
            self.encoderOptionsFrameStatusbar.SetStatusText(encoderOptionsFrameStatusbar_fields[i], i)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderOptionsFrame.__do_layout
        self.Layout()
        # end wxGlade

# end of class encoderOptionsFrame


class encoderQueueFrame(wx.Frame):
    def __init__(self, *args, **kwds):

        toolbarCleanup = wx.NewId()
        toolbarStop = wx.NewId()
        toolbarUp = wx.NewId()
        toolbarDown = wx.NewId()
        toolbarPrefs = wx.NewId()

        # begin wxGlade: encoderQueueFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Tool Bar
        self.encoderQueueFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.encoderQueueFrameToolbar)
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarStop, "Stop", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-cancel.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Stop Encoder Thread", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarUp, "Up", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-up.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected recording(s) up", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarDown, "Down", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-down.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected recording(s) down", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarCleanup, "Clean Up", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/edit-clear.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Clean Up", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarPrefs, "Preferences", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Queue Preferences", "")
        # Tool Bar end
        self.encoderQueueListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.SUNKEN_BORDER)
        self.encoderQueueCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_TOOL, self.onToolbarStop, id=toolbarStop)
        self.Bind(wx.EVT_TOOL, self.onToolbarUp, id=toolbarUp)
        self.Bind(wx.EVT_TOOL, self.onToolbarDown, id=toolbarDown)
        self.Bind(wx.EVT_TOOL, self.onToolbarCleanup, id=toolbarCleanup)
        self.Bind(wx.EVT_TOOL, self.onToolbarPrefs, id=toolbarPrefs)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.onItemRightClick, self.encoderQueueListCtrl)
        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.encoderQueueCloseButton)
        # end wxGlade
        
        ##########################
        
        # this variable tracks the thread IDs .. 
        # because I use this style of identifying threads eventually the ID would wrap.. so there's the app's max threads limit!
        self.nextThreadID = 0

        # this variable contains a list of encoder jobs, including their thread handles
        self.threads = {}

        # this tracks the order in which the threads appear in the listctrl
        self.threadOrder = []

        # this holds our app preferences
        self.prefs = {}

        # set up the listctrl
        self.encoderQueueListCtrl.InsertColumn(0, "Show")
        self.encoderQueueListCtrl.InsertColumn(1, "Episode")
        self.encoderQueueListCtrl.InsertColumn(2, "Air Time")
        self.encoderQueueListCtrl.InsertColumn(3, "Progress")
        
        # connect up a handler to update the GUI upon events from the encoder threads
        EVT_ENCODER(self, self.onEncoderEvent)    

        # prepare the right-click context menu entry definitions        
        self.contextMenuEntriesById = {}
        for item in [ "Toggle Pause","View Details","Remove" ]:
            self.contextMenuEntriesById[ wx.NewId() ] = item
        
        self.threadDetailFrames = {}
        
        # start the updater timer
        self.encoderQueueUpdateTimer = encoderQueueUpdateTimer()
        self.encoderQueueUpdateTimer.setFrameHandle(self)
        self.encoderQueueUpdateTimer.Start(milliseconds=2000)

    def __set_properties(self):
        # begin wxGlade: encoderQueueFrame.__set_properties
        self.SetTitle("MythRip - Encoding Queue")
        self.SetSize((640, 300))
        self.encoderQueueFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderQueueFrame.__do_layout
        encoderQueueSizer = wx.BoxSizer(wx.VERTICAL)
        encoderQueueSizer.Add(self.encoderQueueListCtrl, 1, wx.EXPAND, 0)
        encoderQueueSizer.Add(self.encoderQueueCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(encoderQueueSizer)
        self.Layout()
        # end wxGlade

    ##########################################################################################
    # meat

    def addProgram(self,program):
        
        # grab the next thread id
        threadID = self.nextThreadID
        
        # prepare the thread id for the thread after this one
        self.nextThreadID += 1
        
        # create the thread.  
        self.threads[threadID] = encoderThread(program, threadID, self)

        self.threadOrder.append(threadID)
        
        # determine the number of items in the control and add in the next available slot
        newListIndex = self.encoderQueueListCtrl.GetItemCount()

        self.onThreadPoolChange()

    def getSelectedEncoders(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:
            thread = self.threads[ self.encoderQueueListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.encoderQueueListCtrl.GetNextSelected(item)
        
        return returnList


    def resizeEncoderQueueListCtrl(self):
        self.encoderQueueListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)

    def setPreferences(self, prefs):
        print "encoder queue frame received new prefs"
        self.prefs = prefs
        
    def reorderThreads(self, direction):

        # make a list of selected threads so we can restore it after we redraw the listctrl
        selThreads = []

        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:

            selThreadID = self.encoderQueueListCtrl.GetItemData(item)

            selThreads.append(selThreadID)
            
            # make a copy of threadOrder for us to mutilate
            newThreadOrder = self.threadOrder

            # loop through threadOrder indexes
            idx=0
            maxIdx = len(self.threadOrder)
            for idx in range(maxIdx):
                                
                if selThreadID == self.threadOrder[idx]:
                    
                    if direction == "up" and idx > 0:
                        # swap entries up
                        tmpThread = newThreadOrder[idx-1] 
                        newThreadOrder[idx-1] = newThreadOrder[idx]
                        newThreadOrder[idx] = tmpThread
                        break

                    elif direction == "down" and idx+1 < maxIdx:
                        # swap entries down
                        tmpThread = newThreadOrder[idx+1]
                        newThreadOrder[idx+1] = newThreadOrder[idx]
                        newThreadOrder[idx] = tmpThread
                        break

                idx += 1

            self.threadOrder = newThreadOrder

            item = self.encoderQueueListCtrl.GetNextSelected(item)

        # now that we are done re-ordering, redraw the threads
        self.onThreadPoolChange(selThreads)

    ##########################################################################################
    # event handlers

    # called by hand any time the threads list is added from, subtracted to, or re-ordered
    def onThreadPoolChange(self,selectedThreads = []):
        
        self.encoderQueueListCtrl.DeleteAllItems()

        for threadID in self.threadOrder:

            # for threadID, encoderThread in self.threads.iteritems():            
            newListIndex = self.encoderQueueListCtrl.GetItemCount()

            program = self.threads[threadID].program

            # insert the new list ctrl item
            self.encoderQueueListCtrl.InsertStringItem(newListIndex, program.title)
            self.encoderQueueListCtrl.SetStringItem(newListIndex, 1, program.subtitle)
            self.encoderQueueListCtrl.SetStringItem(newListIndex, 2, str(program.starttime))
            self.encoderQueueListCtrl.SetStringItem(newListIndex, 3, self.threads[threadID].lastListMessage)
            self.encoderQueueListCtrl.SetItemData(newListIndex, threadID) # store the thread id with each item

            # restore the user's selection
            if threadID in selectedThreads:
                item = self.encoderQueueListCtrl.FindItemData(0, threadID)
                self.encoderQueueListCtrl.SetItemState( item, state=wx.LIST_STATE_SELECTED, stateMask=wx.LIST_STATE_SELECTED)
            
        # keep the table clean with some column resizing
        self.resizeEncoderQueueListCtrl()


    # called from the encoderQueueUpdateTimer
    def onTimerTick(self):

        # this is where the encoder queue determines when it needs to start more encoders

        while True:
        
            pendingThreads = []

            threadCount = len(self.threadOrder)

            runningThreads = 0

            for threadID in self.threadOrder:

                encoderThread = self.threads[threadID]

                # count how many threads are running now
                if encoderThread.state == "running":
                    runningThreads += 1  

                # make a list of threads that are waiting to start
                elif encoderThread.state == "new":
                    pendingThreads.append( encoderThread )

            # if there are less threads running than the threadCount, then start some until thats no longer true    
            if runningThreads < self.prefs['threadCount'] and len(pendingThreads):
                pendingThreads[0].start()
            else:
                # the only way out of the while True is for there to be no more threads that need starting
                break
                    

    # when an encoder event is received this is called
    def onEncoderEvent(self, event):

        print "Thread %d state %s : %s" % (event.threadID, event.threadState, event.listMessage)
        
        # we pretty much need this no matter what
        listCtrlIndex = self.encoderQueueListCtrl.FindItemData(0,event.threadID)
        
        if event.threadState == "terminating":
            # if the thread died, remove it from the thread pool, and remove the item from the listctrl

            print "Thread %d removed from thread pool." % event.threadID
            
            del self.threads[event.threadID]
            
            print "- Thread %d is at position %d in the list ctrl, removing it" % (event.threadID,listCtrlIndex)
            
            self.encoderQueueListCtrl.DeleteItem(listCtrlIndex)
            

        self.encoderQueueListCtrl.SetStringItem(listCtrlIndex, 3, event.listMessage)

        self.resizeEncoderQueueListCtrl()

        # refresh any thread detail frames that are open for this thread
        if self.threadDetailFrames.has_key( event.threadID ):
            try:
                self.threadDetailFrames[ event.threadID ].refreshLayout()
                
            except wx.PyDeadObjectError: # can't do this in C++ heh
                print "deleting thread reference to detail frame"
                del self.threadDetailFrames[ event.threadID ]
            
        event.Skip()

    def onCloseButton(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.Hide()
        event.Skip()

    def onToolbarUp(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.reorderThreads("up")
        event.Skip()

    def onToolbarDown(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.reorderThreads("down")
        event.Skip()

    def onToolbarCleanup(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarCleanup' not implemented"
        event.Skip()

    def onItemRightClick(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        
        menu = wx.Menu()

        for (id,title) in self.contextMenuEntriesById.iteritems():
            menu.Append(id, title)
            wx.EVT_MENU( menu, id, self.onContextMenuSelection )
            
        self.PopupMenu( menu )

        event.Skip()


    def onContextMenuSelection(self, event):        
        selectedMenuItem = self.contextMenuEntriesById[ event.GetId() ]
        
        if selectedMenuItem == "View Details":
            threadID = self.encoderQueueListCtrl.GetItemData( self.encoderQueueListCtrl.GetFirstSelected() )
            self.threadDetailFrames[ threadID ] = threadDetailFrame(parent=self)
            self.threadDetailFrames[ threadID ].setThreadID(threadID)        
            self.threadDetailFrames[ threadID ].Show()

        event.Skip()

    def onToolbarPrefs(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.GetParent().preferencesFrame.Show()
        self.GetParent().preferencesFrame.preferencesNotebook.ChangeSelection(2)
        event.Skip()

    def onToolbarStop(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:
            threadID = self.encoderQueueListCtrl.GetItemData(item)

            # abort if its running (dont set abort flag on waiting threads)
            if self.threads[ threadID ].state == "running":
                self.threads[ threadID ].setCommand("abort")

            item = self.encoderQueueListCtrl.GetNextSelected(item)
        event.Skip()

# end of class encoderQueueFrame

###################################################################
# encoder thread land

# get an ID for an "encoder" event 
EVT_ENCODER_ID = wx.NewId()

# define a macro for connecting event handlers to the encoder events
def EVT_ENCODER(theWin, theFunc):
    theWin.Connect(-1, -1, EVT_ENCODER_ID, theFunc)

# a simple event to throw out of the encoder
class encoderEvent(wx.PyEvent):
    def __init__(self, threadID, threadState, listMessage):
        wx.PyEvent.__init__(self)
        self.SetEventType(EVT_ENCODER_ID)
        self.threadID = threadID
        self.threadState = threadState
        self.listMessage = listMessage

# the encoder thread itself
class encoderThread(threading.Thread):
    
    def __init__(self, program, threadID, notifyWindow):
        
        self.notifyWindow = notifyWindow
        self.program = program
        self.threadID = threadID
        self.doCommand = ""
        
        self.state = "new"
        
        self.lastListMessage = "Waiting"

        self.mythTranscodeProcess = False
        self.mythTranscodeStdout = ""
        self.mythTranscodeFifoDir = ""
        
        # source video/audio properties
        self.vidWidth = ""
        self.vidHeight = ""
        self.vidFramerate = ""
        self.audioRate = ""
        self.audioChannels = ""

        self.currentPass = 0
        self.currentFrame = 0
        self.currentFPS = 0
        self.maxFrame = 0
        
        # make a copy of the preferences at the time the thread was created to avoid them changing mid-stream if the user
        # alters preferences during a thread's execution
        self.prefs = self.notifyWindow.prefs 

        # boolean describing if two-pass is enabled ; 0 is yes
        self.twoPass = (self.prefs["twoPassVideo"] == 0)

        self.mencoderCmd = {}

        # load parent constructor
        threading.Thread.__init__(self)
    
        
    def run(self):

        self.state = "running"

        print "Thread ID %d : %s" % (self.threadID, self.program)
        
        self.startMythtranscode()

        # now we need to examine the mythtranscode output to determine the video and audio parameters .. 
        # we wait up to 10 seconds for them to show up in self.mythTranscodeStdout
        for i in range(10): 
            self.parseSubprocessOutput(mtGathering = True)
            print self.mythTranscodeStdout,"\n-----------------------------------------"
            if re.search(".*Stream.*Audio.*kb/s", self.mythTranscodeStdout):
                print "Found file AV parameters! Beginning extraction from mythtranscode output"
                (self.vidWidth, self.vidHeight, self.vidFramerate) = re.findall('.*Stream #.* ([0-9]+)x([0-9]+).* ([0-9]+\.[0-9]+) tb',self.mythTranscodeStdout)[0]
                (self.audioRate, audioChanMode) = re.findall('.*Stream #.* ([0-9]+) Hz, ([A-Za-z]+)',self.mythTranscodeStdout)[0]
                if audioChanMode == "stereo":
                    self.audioChannels = "2"
                else:
                    # TODO im not sure what other values are produced in this slot
                    self.audioChannels = "1"
                break

            time.sleep(1)

        
        if self.twoPass:
            mencCount = 2
        else:
            mencCount = 1


        # loop as many times as we are supposed to start mencoder
        # - zip through the upcoming passes and generate the mencoderCmds in advance
        for i in range(mencCount):
            self.currentPass = i+1
            self.mencoderCmd[self.currentPass] = self.buildMencoderCmd()

        # loop as many times as we are supposed to start mencoder
        for i in range(mencCount):

            self.currentPass = i+1

            # if we were told to abort, escape the loop
            if self.doCommand == "abort":
                print "aborting pass %d" % self.currentPass
                break


            # if this isnt the first loop, we can't count on mythtranscode being started!  we need to start a new one for subsequent passes
            if self.currentPass != 1:
                self.startMythtranscode()


            self.stdoutSockMenc, stdoutChildSockMenc = socket.socketpair() 
            self.stderrSockMenc, stderrChildSockMenc = socket.socketpair() 
            self.stdoutSockMenc.settimeout(0.1)
            self.stderrSockMenc.settimeout(0.1)

            self.mencoderProcess = subprocess.Popen(self.mencoderCmd[self.currentPass], stdin=None, stdout=stdoutChildSockMenc.fileno(), stderr=stderrChildSockMenc.fileno())

            self.setRunningStatus( "Encoder started." )

            stopRunning = False
            while not stopRunning:

                print "encoder thread heartbeat"

                self.parseSubprocessOutput()
                
                # dead processes
                mythTranscodeRunning = (self.mythTranscodeProcess.poll() == None)
                mencoderRunning = (self.mencoderProcess.poll() == None)

                # end the pass if mythtranscode and mencoder are not both running, or if we've been told to abort
                endPass = (not ( mythTranscodeRunning and mencoderRunning ) ) or self.doCommand == "abort"

                if endPass:

                    self.setRunningStatus( "Waiting for all subprocesses to end" )

                    print "alert - mencoderRunning",mencoderRunning,"mythTranscodeRunning",mythTranscodeRunning
                    
                    # wait 5 seconds for things to normalize
                    for sec in range(15):
                        
                        # read again
                        mythTranscodeRunning = (self.mythTranscodeProcess.poll() == None)
                        mencoderRunning = (self.mencoderProcess.poll() == None)
                        
                        if not mythTranscodeRunning and not mencoderRunning:
                            print "all subprocesses dead"
                            stopRunning = True
                            break

                        if sec > 3:

                            # read again
                            mythTranscodeRunning = (self.mythTranscodeProcess.poll() == None)
                            mencoderRunning = (self.mencoderProcess.poll() == None)

                            self.setRunningStatus( "Actively stopping subprocesses" )
                            print "its been %d seconds now.. going to aggressive mode" % sec

                            if sec > 7:
                                usesig = signal.SIGKILL
                            else:
                                usesig = signal.SIGTERM

                            if mythTranscodeRunning:
                                print "aggr, mencoder died but mythtranscode continues to run.  killing it."
                                os.kill(self.mythTranscodeProcess.pid, usesig)

                            if mencoderRunning:
                                print "aggr, the 5 sec wait, mythTranscode died but mencoder continues to run.  killing it."
                                os.kill(self.mencoderProcess.pid, usesig)


                        # wait a second.. both processes should be disolving more or less simultaneously
                        time.sleep(1);

                    # parse subprocess output one last time
                    self.parseSubprocessOutput()
                
                # wait a second before checking the subprocess again
                time.sleep(0.1)

        if self.doCommand == "abort":
            self.sendEncoderEvent( "stopped", "Aborted" )
            self.state = "aborted"
        else:
            self.sendEncoderEvent( "stopped", "Completed" )
            self.state = "completed"

    def clearFifoDir(self):
        print "clearFifoDir"

        # get directory for our fifos to live in
        self.mythTranscodeFifoDir = '/tmp/mythrip-%d-fifo' % self.threadID

        # we'll try killing that fifo dir 10 times.
        for sec in range(10):
            
            self.setRunningStatus( "Waiting for mythtranscode fifos" )

            if os.path.isdir(self.mythTranscodeFifoDir):
                try:
                    shutil.rmtree(self.mythTranscodeFifoDir)
                except Exception, e:
                    self.endThread("failed","Could not remove stale fifo directory: %s" % e)
            else:
                break

            time.sleep(1)

        try:
            os.mkdir(self.mythTranscodeFifoDir)
        except Exception, e:
            self.endThread("failed","Failed creating fifo directories: %s" % e)


    def parseSubprocessOutput(self,mtGathering = False):
        
        streamDict = {"mt": [self.stdoutSockMT, self.stderrSockMT]}
        
        # if we are in mtGathering mode, we ignore menc
        if not mtGathering:
            streamDict["menc"] = [self.stdoutSockMenc, self.stderrSockMenc]
        
        # read from all processes
        for (name, (stdoutSock,stderrSock)) in streamDict.iteritems():
            newstdout = ""
            newstderr = ""
            
            try:
                newstdout = stdoutSock.recv(1024)
                newstderr = stderrSock.recv(1024)

            except socket.timeout, e:
                pass 

            # print em out if there was anything
            if len(newstdout):
                # if this is mythtranscode, we need to gather up all the output so we may parse out video and audio parameters
                if mtGathering:
                    self.mythTranscodeStdout += newstdout
                    
                # parse mencoder output for the queue listctrl
                if name == "menc":
                    # Pos:   6.1s    192f ( 0%) 35.13fps Trem:   0min   0mb  A-V:0.033 [715:1536]
                    match = re.findall('Pos\: +([0-9\.]+)s +([0-9]+)f \(([0-9 ]+%)\) +([0-9\.]+)fps',newstdout) # pull mencoder output
                    if match:
                        self.currentFrame = int(match[0][1])
                        self.currentFPS = float(match[0][3])

                # because we just receive data periodically we might be getting only pieces of full output lines.. but this is just a progress indicator, its good enough
                if name == "mt":
                    match = re.findall('.*Processed: [0-9]+ of ([0-9]+) frames',newstdout)
                    if match:
                        self.maxFrame = int(match[0])

                
                if self.currentFrame and self.maxFrame:
                    perc = self.currentFrame / float(self.maxFrame) * 100 

                    self.setRunningStatus("%d%% : Frame %d / %d : %0.02f fps" % (int(perc), self.currentFrame, self.maxFrame, self.currentFPS ) )

                elif self.currentFrame:
                    
                    self.setRunningStatus("0%% : Frame %d / ????: %0.02f fps" % (self.currentFrame, self.currentFPS) )

                # print "STDOUT %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstdout)
                    
            if len(newstderr):
                # print "STDERR %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstderr)
                pass


    def buildMencoderCmd(self):
                
        print "loaded prefs",self.prefs

        # now fire up mencoder reading from mythtranscode's fifo
        mencoderCmd = ['/usr/bin/mencoder','-noskip','-idx',
                       os.path.join(self.mythTranscodeFifoDir, 'vidout'),
                       '-audiofile', os.path.join(self.mythTranscodeFifoDir,'audout'),
                       '-demuxer','20','-audio-demuxer','20',
                       '-rawvideo','w=%s:h=%s:fps=%s' % (self.vidWidth, self.vidHeight, self.vidFramerate),
                       '-rawaudio','rate=%s:channels=%s' % (self.audioRate, self.audioChannels),
                       '-demuxer','26']

        ### Audio
        
        # dont process sound on first pass of a two-pass encode
        # if twoPass and passNumber == 1:
        # mencoderCmd.extend( ['-nosound'] )
        # else:
        mencoderCmd.extend( ['-oac','copy'] )

        if len(self.prefs['audioFilter']):
            mencoderCmd.extend( ['-af',self.prefs['audioFilter']] )
            
        ### Video

        # load this pass' options
        if self.twoPass:

            if self.currentPass == 1:
                encOpts = self.prefs['videoFirstPassOpts']+':pass=1'
            else:
                encOpts = self.prefs['videoSecondPassOpts']+':pass=2'

        else:

            if self.currentPass == 1:
                encOpts = self.prefs['videoFirstPassOpts']
            else:
                encOpts = self.prefs['videoSecondPassOpts']

                
        # 0 is xvid
        if self.prefs['videoCodec'] == 0:                 
            mencoderCmd.extend( ['-ovc','xvid','-xvidencopts',encOpts] )
            
        # 1 is x264
        elif self.prefs['videoCodec'] == 1:            
            mencoderCmd.extend( ['-ovc','x264','-x264encopts',encOpts] )  # :pass=1', # 'subq=5:8x8dct:frameref=2:bframes=3:b_pyramid:weight_b',
            
        if len(self.prefs['videoFilter']):            
            mencoderCmd.extend( ['-vf',self.prefs['videoFilter']] )

        # debugging
        mencoderCmd.extend( ['-frames','200'] )


        if self.twoPass:

            if self.currentPass == 1:
                mencoderCmd.extend( ['-o', '/dev/null'] )
            else:
                self.makeOutputFilename()
                mencoderCmd.extend( ['-o', self.outputFile] )

            # in two pass mode, always pass the logfile arg
            mencoderCmd.extend( ['-passlogfile', 'logfile-thread-%d.log' % self.threadID] )
        else:
            outputFile = self.makeOutputFilename()
            mencoderCmd.extend( ['-o', self.outputFile] )
            
        return mencoderCmd
    
    def startMythtranscode(self):
        
        self.clearFifoDir()

        print "Starting mythtranscode!"

        # fire up mythtranscode turbo=1:subq=1:frameref=1
        mythTranscodeCmd = ['/usr/bin/mythtranscode',
                            '--showprogress',
                            '-p','autodetect',
                            '-c',str(self.program.chanid),
                            '-s',self.program.recstartts.strftime('%Y-%m-%dT%H:%M:%S'),
                            '-f',self.mythTranscodeFifoDir,
                            '--verbose','libav' # we pull video parameters out of this verbose output mode
                            ]
        
        if self.prefs["useMythCutlist"] == 0:
            mythTranscodeCmd.append('--honorcutlist')

        print mythTranscodeCmd        
        
        # use sockets for the subprocess file objects so we can read from stdout/stderr in a non-blocking fashion
        self.stdoutSockMT, stdoutChildSockMT = socket.socketpair() 
        self.stderrSockMT, stderrChildSockMT = socket.socketpair() 
        self.stdoutSockMT.settimeout(0.1)
        self.stderrSockMT.settimeout(0.1)
        self.mythTranscodeProcess = subprocess.Popen(mythTranscodeCmd, stdin=None, stdout=stdoutChildSockMT.fileno(), stderr=stderrChildSockMT.fileno())

        # 5 second loop
        for i in range(10):
            print "waiting for fifo dir %d" % i
            if self.isFifo( os.path.join(self.mythTranscodeFifoDir,'vidout') ):
                print "fifo present!"
                break

            time.sleep(1)


    # when called this func spits out the full path & filename for the new file..?
    def makeOutputFilename(self, iteration=0):

        templateMap = { '%s': "title",
                        '%e': "subtitle",
                        '%d': "description",
                        '%c': "category",
                        '%C': "channum",
                        '%T': "starttime",
                        '%E': "endtime",
                        '%i': "seriesid",
                        '%h': "hostname" }
        
        template = self.prefs["fileTemplate"]

        for (code, name) in templateMap.iteritems():

            value = getattr(self.program, name)
            
            template = template.replace(code, str(value))
            
        extension = 'avi'

        if iteration > 0:
            filename = '%s - Copy %d.%s' % (template, iteration, extension)
        else:
            filename = '%s.%s' % (template, extension)
            
        retrFile = os.path.join( self.prefs['savePath'], filename )

        if os.path.isfile(retrFile):
            return self.makeOutputFilename( iteration=(iteration+1) )
        else:
            print "Output filename"
            self.outputFile = retrFile

    # func called to update the encoder queue frame listctrl item
    def setRunningStatus(self,status):

        if self.currentPass > 0 and self.prefs["twoPassVideo"] == 0: # 0 is yes
            sendStat = "Pass %d : %s" % (self.currentPass, status)
        else:
            sendStat = status

        self.sendEncoderEvent( "running", sendStat )
        

    # func called by the main thread in order to issue commands
    def setCommand(self,command):
        self.doCommand = command

    def endThread(self,threadState,listMessage):
        
        # i'm hoping this kills the subprocess... if not i might just use process.pid to kill it
        del self.mythTranscodeProcess

        # the last thing the thread does is tell the main thread its terminating, and thats a rule
        self.sendEncoderEvent( threadState, listMessage )
        
        # die!
        sys.exit()
        
    def sendEncoderEvent(self, threadState, listMessage):
        self.lastListMessage = listMessage
        wx.PostEvent(self.notifyWindow, encoderEvent(self.threadID, threadState, listMessage))
        
    def isFifo(self,fn):
        return os.access(fn,os.R_OK) and stat.S_ISFIFO(os.stat(fn).st_mode)

    
# a very simple timer to call a tick function in the encoder queue fraem
class encoderQueueUpdateTimer(wx.Timer):
    
    def setFrameHandle(self,encoderQueueFrame):
        self.encoderQueueFrame = encoderQueueFrame

    def Notify(self):
        self.encoderQueueFrame.onTimerTick()

###########################################################################
    

class preferencesFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: preferencesFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.preferencesNotebook = wx.Notebook(self, -1, style=0)
        self.preferencesFilesPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesQueuePane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesEncodersPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesMythTVPane = wx.Panel(self.preferencesNotebook, -1)
        self.label_22 = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Settings: ")
        self.mysqlHostLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Hostname: ")
        self.mysqlHostText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlPortLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Port: ")
        self.mysqlPortText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlUserLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL User: ")
        self.mysqlUserText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlPasswordLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Password: ")
        self.mysqlPasswordText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlDBNameLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Database Name: ")
        self.mysqlDBNameText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mythOptionsLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MythTV Options: ")
        self.useMythCutlistLabel = wx.StaticText(self.preferencesMythTVPane, -1, "Use Myth Cutlists: ")
        self.useMythCutlistChoice = wx.Choice(self.preferencesMythTVPane, -1, choices=["Yes", "No"])
        self.FileOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "File Options:")
        self.containerFormatLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Container Format: ")
        self.containerFormatChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["avi", "mkv"])
        self.videoOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Options: ")
        self.videoCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Codec: ")
        self.videoCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["xvid", "x264"])
        self.twoPassVideoLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Two-Pass Video: ")
        self.twoPassVideoChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["Yes", "No"])
        self.videoFirstPassOptsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "First Pass Options (): ")
        self.videoFirstPassOptsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.videoSecondPassOptsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Second Pass Options (): ")
        self.videoSecondPassOptsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.videoFilterStringLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Filter String (-vf): ")
        self.videoFilterStringText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.audioOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Options:")
        self.audioCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec: ")
        self.audioCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["passthrough", "mp3lame", "ogg", "whatever"])
        self.audioCodecOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec Options ():")
        self.audioCodecOptionsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.audioFilterLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Filter String (-af): ")
        self.audioFilterText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.threadCountLabel = wx.StaticText(self.preferencesQueuePane, -1, "Max Simultaneous Jobs: ")
        self.threadCountSpin = wx.SpinCtrl(self.preferencesQueuePane, -1, "", min=0, max=100)
        self.removeCompletedLabel = wx.StaticText(self.preferencesQueuePane, -1, "Remove Completed Jobs: ")
        self.removeCompletedChoice = wx.Choice(self.preferencesQueuePane, -1, choices=["Yes", "No"])
        self.savePathLabel = wx.StaticText(self.preferencesFilesPane, -1, "Save Encoded Videos In: ")
        self.savePathPicker = wx.DirPickerCtrl(self.preferencesFilesPane, -1)
        self.fileTemplateLabel = wx.StaticText(self.preferencesFilesPane, -1, "File Naming Template: ")
        self.fileTemplateText = wx.TextCtrl(self.preferencesFilesPane, -1, "")
        self.preferencesCancelButton = wx.Button(self, wx.ID_CANCEL, "")
        self.preferencesOKButton = wx.Button(self, wx.ID_OK, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCancelButton, self.preferencesCancelButton)
        self.Bind(wx.EVT_BUTTON, self.onOKButton, self.preferencesOKButton)
        # end wxGlade
        
        # a map of which 'prefs' keys map to which controls in the preferences dialog, and the control type
        # we use this for getting/setting values in the preferences dialog

        self.prefMap = {'mysqlHost': ['TextCtrl', self.mysqlHostText],
                        'mysqlPort': ['TextCtrl', self.mysqlPortText],
                        'mysqlUser': ['TextCtrl', self.mysqlUserText],
                        'mysqlPassword': ['TextCtrl', self.mysqlPasswordText],
                        'mysqlDB': ['TextCtrl', self.mysqlDBNameText],
                        'useMythCutlist': ['Choice', self.useMythCutlistChoice],
                        'containerFormat': ['Choice', self.containerFormatChoice],
                        'videoCodec': ['Choice', self.videoCodecChoice],
                        'videoFirstPassOpts': ['TextCtrl', self.videoFirstPassOptsText],
                        'videoSecondPassOpts': ['TextCtrl', self.videoSecondPassOptsText],
                        'videoFilter': ['TextCtrl', self.videoFilterStringText],
                        'twoPassVideo': ['Choice', self.twoPassVideoChoice],
                        'audioCodec': ['Choice', self.audioCodecChoice],
                        'audioCodecOptions': ['TextCtrl', self.audioCodecOptionsText],
                        'audioFilter': ['TextCtrl', self.audioFilterText],
                        'threadCount': ['Spin', self.threadCountSpin],
                        'removeCompleted': ['Choice', self.removeCompletedChoice],
                        'savePath': ['DirPicker', self.savePathPicker],
                        'fileTemplate': ['TextCtrl', self.fileTemplateText]                        
                        }

    def __set_properties(self):
        # begin wxGlade: preferencesFrame.__set_properties
        self.SetTitle("MythRip - Preferences")
        self.useMythCutlistChoice.SetSelection(0)
        self.containerFormatChoice.SetSelection(0)
        self.videoCodecChoice.SetSelection(0)
        self.twoPassVideoChoice.SetSelection(0)
        self.audioCodecChoice.SetSelection(0)
        self.removeCompletedChoice.SetSelection(0)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: preferencesFrame.__do_layout
        preferencesSizer = wx.BoxSizer(wx.VERTICAL)
        preferencesButtonSizer = wx.BoxSizer(wx.HORIZONTAL)
        preferencesFilesSizer = wx.FlexGridSizer(6, 2, 0, 0)
        preferencesQueueSIzer = wx.FlexGridSizer(2, 2, 0, 0)
        preferencesEncodersSizer = wx.FlexGridSizer(7, 2, 0, 0)
        preferencesMythTVSizer = wx.FlexGridSizer(8, 2, 0, 0)
        preferencesMythTVSizer.Add(self.label_22, 0, 0, 0)
        preferencesMythTVSizer.Add((20, 20), 0, 0, 0)
        preferencesMythTVSizer.Add(self.mysqlHostLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlHostText, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPortLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPortText, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlUserLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlUserText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mysqlPasswordLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPasswordText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mysqlDBNameLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlDBNameText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mythOptionsLabel, 0, wx.TOP, 10)
        preferencesMythTVSizer.Add((20, 20), 0, 0, 0)
        preferencesMythTVSizer.Add(self.useMythCutlistLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.useMythCutlistChoice, 0, 0, 0)
        self.preferencesMythTVPane.SetSizer(preferencesMythTVSizer)
        preferencesMythTVSizer.AddGrowableCol(1)
        preferencesEncodersSizer.Add(self.FileOptionsLabel, 0, 0, 0)
        preferencesEncodersSizer.Add((10, 10), 0, 0, 0)
        preferencesEncodersSizer.Add(self.containerFormatLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.containerFormatChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoOptionsLabel, 0, wx.TOP|wx.ALIGN_BOTTOM, 10)
        preferencesEncodersSizer.Add((20, 20), 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.twoPassVideoLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.twoPassVideoChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoFirstPassOptsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoFirstPassOptsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.videoSecondPassOptsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoSecondPassOptsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.videoFilterStringLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoFilterStringText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.audioOptionsLabel, 0, wx.TOP, 10)
        preferencesEncodersSizer.Add((20, 20), 0, 0, 0)
        preferencesEncodersSizer.Add(self.audioCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.audioCodecOptionsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioCodecOptionsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.audioFilterLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioFilterText, 0, wx.EXPAND, 0)
        self.preferencesEncodersPane.SetSizer(preferencesEncodersSizer)
        preferencesEncodersSizer.AddGrowableCol(1)
        preferencesQueueSIzer.Add(self.threadCountLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.threadCountSpin, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.removeCompletedLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.removeCompletedChoice, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        self.preferencesQueuePane.SetSizer(preferencesQueueSIzer)
        preferencesQueueSIzer.AddGrowableCol(1)
        preferencesFilesSizer.Add(self.savePathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.savePathPicker, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.fileTemplateLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.fileTemplateText, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        self.preferencesFilesPane.SetSizer(preferencesFilesSizer)
        preferencesFilesSizer.AddGrowableCol(1)
        self.preferencesNotebook.AddPage(self.preferencesMythTVPane, "MythTV")
        self.preferencesNotebook.AddPage(self.preferencesEncodersPane, "Encoders")
        self.preferencesNotebook.AddPage(self.preferencesQueuePane, "Queue")
        self.preferencesNotebook.AddPage(self.preferencesFilesPane, "Files")
        preferencesSizer.Add(self.preferencesNotebook, 1, wx.EXPAND, 0)
        preferencesButtonSizer.Add(self.preferencesCancelButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesButtonSizer.Add(self.preferencesOKButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesSizer.Add(preferencesButtonSizer, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(preferencesSizer)
        preferencesSizer.Fit(self)
        self.Layout()
        # end wxGlade


    # set the preferences window to the prefs defined in the prefs argument
    def setPreferences(self, prefs):
        print "prefs frame being set with prefs passed from caller",prefs

        self.prefs = prefs
        
        for (prefKey,(controlType,controlVar)) in self.prefMap.iteritems():

            if prefs.has_key( prefKey ):
                
                # set the value according to controlType
                
                if controlType == "TextCtrl": 
                    controlVar.SetValue( str(prefs[ prefKey ]) )
                elif controlType == "Spin":
                    controlVar.SetValue( int(prefs[ prefKey ]) )
                elif controlType == "Choice":
                    controlVar.SetSelection( int(prefs[ prefKey ]) )
                elif controlType == "DirPicker":
                    controlVar.SetPath( str(prefs[ prefKey ]) )
                    

    # load the preferences that are currently set in this frame in to a prefs array and return it
    def getPreferences(self):
        print "prefs frame getting preferences from frame and returning them"
        
        prefs = {}
        
        for (prefKey,(controlType,controlVar)) in self.prefMap.iteritems():

            # retrieve the value according to controlType
            if controlType in ["TextCtrl","Spin"]: # these types all share GetValue()
                value = controlVar.GetValue()
            elif controlType == "Choice":
                value = controlVar.GetCurrentSelection()
            elif controlType == "DirPicker":
                value = controlVar.GetPath()

            # stuff it in to the prefs array
            prefs[ prefKey ] = value

        return prefs


    def onCancelButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        self.Hide()
        event.Skip()

    def onOKButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        # this event is picked up by the mainframe where the actual saving/load of preferences takes place
        self.Hide()
        event.Skip()
        
# end of class preferencesFrame


class mythRipMain(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        self.mainFrameInstance = mainFrame(None, -1, "")
        self.SetTopWindow(self.mainFrameInstance)
        self.mainFrameInstance.Show()
        return 1

# end of class mythRipMain

if __name__ == "__main__":
    mythRip = mythRipMain(0)
    mythRip.MainLoop()

