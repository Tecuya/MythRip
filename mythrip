#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Fri May 22 10:25:23 2009

# mythrip: GUI tool to export MythTV recordings to various portable media files, and manage recordings in general

import os
import shutil
import sys
import wx
import mythtv
import threading
import subprocess
import socket

import time   # for debugging only so far

# begin wxGlade: extracode
# end wxGlade




class mainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        
        toolbarEncode = wx.NewId()
        toolbarView = wx.NewId()
        toolbarDelete = wx.NewId()
        toolbarPrefs = wx.NewId()
        toolbarReload = wx.NewId()
        toolbarQuit = wx.NewId()

        # begin wxGlade: mainFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.mainFrameMenubar = wx.MenuBar()
        self.fileMenuItem = wx.Menu()
        self.deleteMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Delete", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.deleteMenuItem)
        self.fileMenuItem.AppendSeparator()
        self.quitMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Quit", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.quitMenuItem)
        self.mainFrameMenubar.Append(self.fileMenuItem, "&File")
        self.editMenuItem = wx.Menu()
        self.prefsMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Preferences", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.prefsMenuItem)
        self.mainFrameMenubar.Append(self.editMenuItem, "&Edit")
        self.viewMenuItem = wx.Menu()
        self.queMenuItem = wx.MenuItem(self.viewMenuItem, wx.NewId(), "&Queue", "", wx.ITEM_NORMAL)
        self.viewMenuItem.AppendItem(self.queMenuItem)
        self.mainFrameMenubar.Append(self.viewMenuItem, "&View")
        self.helpMenuItem = wx.Menu()
        self.aboutMenuItem = wx.MenuItem(self.helpMenuItem, wx.NewId(), "&About", "", wx.ITEM_NORMAL)
        self.helpMenuItem.AppendItem(self.aboutMenuItem)
        self.mainFrameMenubar.Append(self.helpMenuItem, "&Help")
        self.SetMenuBar(self.mainFrameMenubar)
        # Menu Bar end
        self.mainFrameStatusbar = self.CreateStatusBar(1, 0)
        
        # Tool Bar
        self.mainFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.mainFrameToolbar)
        self.mainFrameToolbar.AddLabelTool(toolbarReload, "Reload", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/reload.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.mainFrameToolbar.AddLabelTool(toolbarEncode, "Encode", wx.Bitmap("/usr/share/icons/gnome/32x32/categories/applications-system.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Encode selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarView, "View", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-media-play-ltr.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "View selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarDelete, "Delete", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/stock_delete.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Delete selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarPrefs, "Preferences", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.mainFrameToolbar.AddLabelTool(toolbarQuit, "Quit", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/application-exit.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        # Tool Bar end
        self.mainFrameListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.LC_EDIT_LABELS|wx.LC_SORT_ASCENDING|wx.SUNKEN_BORDER)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.onMenuDelete, self.deleteMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuQuit, self.quitMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuPrefs, self.prefsMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuQueue, self.queMenuItem)
        self.Bind(wx.EVT_TOOL, self.onToolbarReload, id=toolbarReload)
        self.Bind(wx.EVT_TOOL, self.onToolbarEncode, id=toolbarEncode)
        self.Bind(wx.EVT_TOOL, self.onToolbarDelete, id=toolbarDelete)
        self.Bind(wx.EVT_TOOL, self.onToolbarPrefs, id=toolbarPrefs)
        self.Bind(wx.EVT_TOOL, self.onToolbarQuit, id=toolbarQuit)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.onColClick, self.mainFrameListCtrl)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.onItemRightClick, self.mainFrameListCtrl)
        # end wxGlade

        ################################################################################
        # Various non-wxglade GUI setup

        # set up our child frames
        self.encoderQueueFrame = encoderQueueFrame(parent=self)
        self.preferencesFrame = preferencesFrame(parent=self)

        # bind "OK" button presses in preferences frame to our own event handler
        self.Bind(wx.EVT_BUTTON, self.onPrefsOK, self.preferencesFrame.preferencesOKButton)

        # set up the ListCtrl columns
        self.mainFrameListCtrl.InsertColumn(0, "Show")
        self.mainFrameListCtrl.InsertColumn(1, "Episode")
        self.mainFrameListCtrl.InsertColumn(2, "Air Time")
        self.mainFrameListCtrl.InsertColumn(3, "Flags")

        ###################################################################################
        # preference handling

        # map of options support by the config file and internal prefs
	self.optionmap = ( { 'short': '-P', 'long': '--mysqlport', 'action': 'store', 'dest': 'mysqlPort', 'default': 3306, 'help': 'MythTV MySQL Port' },
                           { 'short': '-H', 'long': '--mysqlhost', 'action': 'store', 'dest': 'mysqlHost', 'default': 'localhost', 'help': 'MythTV MySQL Host'},
                           { 'short': '-u', 'long': '--mysqluser', 'action': 'store', 'dest': 'mysqlUser', 'default': 'localhost', 'help': 'MythTV MySQL User'},
                           { 'short': '-p', 'long': '--mysqlpass', 'action': 'store', 'dest': 'mysqlPassword', 'default': 'localhost', 'help': 'MythTV MySQL Password'},
                           { 'short': '-d', 'long': '--mysqldb', 'action': 'store', 'dest': 'mysqlDB', 'default': 'localhost', 'help': 'MythTV MySQL Database Name'} 
                           
                           )

        # load preferences from disk
        self.loadPrefsFromDisk()
        
        # load preferences from CLI ; these override disk preferences
        self.loadPrefsFromCli()

        # push the prefs we've gathered in to the preferences frame
        self.preferencesFrame.setPreferences( self.prefs )
        
        ###############################################################################
        # make mythtv connection and load data from it
        
        # a variable to stuff the program list in to
        self.programList = []

        # load recordings from myth
        self.loadRecordingsFromMyth()

        # prepare the right-click context menu entry definitions
        self.contextMenuEntriesById = {}
        for item in [ "Preview", "Delete", "Encode" ]:
            self.contextMenuEntriesById[ wx.NewId() ] = item

    def __set_properties(self):
        # begin wxGlade: mainFrame.__set_properties
        self.SetTitle("MythRip - Main")
        self.SetSize((720, 430))
        self.mainFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        mainFrameStatusbar_fields = ["mainFrame_statusbar"]
        for i in range(len(mainFrameStatusbar_fields)):
            self.mainFrameStatusbar.SetStatusText(mainFrameStatusbar_fields[i], i)
        self.mainFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: mainFrame.__do_layout
        mainFrameSizer = wx.BoxSizer(wx.HORIZONTAL)
        mainFrameSizer.Add(self.mainFrameListCtrl, 1, wx.EXPAND, 0)
        self.SetSizer(mainFrameSizer)
        self.Layout()
        # end wxGlade

    def loadRecordingsFromMyth(self):

        # delete any listctrl items currently present
        for i in range(len(self.programList)):
            self.mainFrameListCtrl.DeleteItem( self.mainFrameListCtrl.FindItemData(0, i) )

        # reset the programList
        self.programList = []

        # establish our MythTV connection using the mythtv python bindings, push our preferences in to it
        try: 
            self.mythTV = mythtv.MythTV(force_db_opts=self.prefs)

            # query recordings from the backend
            rawRecordings = self.mythTV.backendCommand('QUERY_RECORDINGS Play').split(mythtv.BACKEND_SEP)

        except Exception, e:
            
            # it failed?  send the user to the preferences dialog
            errorDialog = wx.MessageDialog(parent=self, caption="Error connecting to MythTV", message="Error connecting to MythTV:\n%s\nPlease alter your MythTV settings in the Preferences Dialog"%str(e))
            errorDialog.ShowModal()
            self.preferencesFrame.Show()

            rawRecordings = []
            

        if len(rawRecordings):
            # determine the record length and number of recordings present in the response
            numberRecordings = int(rawRecordings[0])        
            recordingLength = (len(rawRecordings) - 1) / numberRecordings

            # parse the output, stuff the results in to a list of Program objects

            for recording in range(numberRecordings):            
                idxStart = ( recording * recordingLength ) + 1    # plus one - offset for the beginning's "record count" record
                idxStop = ( recording + 1 ) * recordingLength     # stop at the next recording beginning

                recordingData = rawRecordings[idxStart:idxStop]

                # print "RECORDING: ",recordingData,"------------------------------------------------------\n\n\n"

                self.programList.append( mythtv.Program( recordingData ) )

        # add recording count to the status bar
        self.mainFrameStatusbar.PushStatusText('Loaded %d recordings' % len(self.programList))
        
        
        # push in the ListCtrl data
        for i in range(len(self.programList)):
            program = self.programList[i]
            self.mainFrameListCtrl.InsertStringItem(i, program.title)
            self.mainFrameListCtrl.SetStringItem(i, 1, program.subtitle)
            self.mainFrameListCtrl.SetStringItem(i, 2, str(program.starttime))
            
            # unpack program flags to english strings
            flags = []
            for k,v in mythtv.PROGRAM_FLAGS.iteritems():
                if int(program.programflags) & v:
                    flags.append(k)

            self.mainFrameListCtrl.SetStringItem(i, 3, ', '.join(flags) )
            self.mainFrameListCtrl.SetItemData(i, i)  # set item datas to be the same as indexes initially
            
        # make nice column sizes
        self.mainFrameListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)
        
        # these variables are for preserving the listctrl sorting state
        self.lastColClick = 0
        self.sortToggler = 1

        # run an initial sort
        self.mainFrameListCtrl.SortItems( self.sortList ) 
        

    # this is the callback to sort the mainFrameListCtrl used by mainFrameListCtrl.SortItems
    def sortList(self, item1, item2):
                        
        progLeft = self.programList[ item1 ]
        progRight = self.programList[ item2 ]
        
        if self.lastColClick == 0:
            if progLeft.title < progRight.title:
                return -1 * self.sortToggler
            elif progLeft.title == progRight.title:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 1:
            if progLeft.subtitle < progRight.subtitle:
                return -1 * self.sortToggler
            elif progLeft.subtitle == progRight.subtitle:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 2:
            if progLeft.starttime < progRight.starttime:
                return -1 * self.sortToggler
            elif progLeft.starttime == progRight.starttime:
                return 0
            else:
                return 1 * self.sortToggler

        return 0
    
    
    # this function returns a list of the mythtv Program objects that have been selected
    def getSelectedPrograms(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.mainFrameListCtrl.GetFirstSelected()
        while item != -1:
            program = self.programList[ self.mainFrameListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.mainFrameListCtrl.GetNextSelected(item)
        
        return returnList
        
    def addRecordingsToQueue(self):
        
        addcount = 0
        for program in self.getSelectedPrograms():
            self.encoderQueueFrame.addProgram(program)
            addcount += 1

        self.mainFrameStatusbar.PushStatusText('Added %d recordings to queue.' % addcount)
            

    def readPrefsFromDisk(self):
        prefs = {}
	cfgfile=os.path.expanduser('~')+'/.mythriprc'
	
	if not os.access(cfgfile,os.F_OK):
	    print "mythrip config file not found, generating a default one in ~/.mythriprc for you.."
	    cfg = file(cfgfile,'w+')
	    cfg.write("# Automatically generated mythrip config file.\n\n")
	    for option in self.optionmap:
		cfg.write('# '+option['help']+"\n"+option['dest']+':'+str(option['default'])+"\n\n")
	    cfg.seek(0)
	    cfg.close()
	    
	# read config file
	cfg = file(cfgfile,'r')
	    
	lines = cfg.readlines()

	# parse config line by line
	for line in lines:
	    if line[0] != '#':
		delimiterAt = line.find(' ')
		if delimiterAt != -1:
		    opt = line[:delimiterAt].strip()
		    value = line[delimiterAt+1:].rstrip("\n")
		    
		    # try to interpret config options
		    if value.lower() == 'true':
			setvalue = True
		    elif value.lower() == 'false':
			setvalue = False
		    elif value.isdigit():
			setvalue = int(value)
		    else:
			setvalue = value
		    
		    prefs[opt] = setvalue

        return prefs

    # write a dictionary of options to the configuration file
    def writePrefsToDisk(self):
        print "writePrefsToDisk"

	cfgFile=os.path.expanduser('~')+'/.mythriprc'
        
        cfg = file(cfgFile,'w+')
        cfg.write("# Automatically generated mythrip config file.\n\n")

        for option in self.optionmap:
            if self.prefs.has_key( option["dest"] ): # if the option appears in our prefs then save it
                cfg.write("## %s\n%s %s\n\n" % (option["help"], option["dest"], self.prefs[ option["dest"] ]))

        cfg.close()

    # read CLI optparse opts into the self.prefs, if they were given
    def loadPrefsFromCli(self):
	import optparse
	usage = "%prog [options]"
	
        cliparser = optparse.OptionParser(usage=usage)
	
	for option in self.optionmap:
            cliparser.add_option(option['short'],option['long'],action=option['action'],dest=option['dest'],help=option['help'])
	
	(options, files) = cliparser.parse_args()
		
	for option in self.optionmap:
            value = getattr(options, option['dest'])
            if value:
                print "pref ",option['dest']," loaded with value",value,"from cli"
                self.prefs[option['dest']] = value
                
                
        
    def onPrefsOK(self, event):

        # load the preferences from the prefs frame
        self.prefs = self.preferencesFrame.getPreferences()
        
        self.writePrefsToDisk()

        self.mainFrameStatusbar.PushStatusText('Preferences saved.')

        event.Skip()

    def loadPrefsFromDisk(self):
        
        # load the prefs from disk to self.prefs        
        self.prefs = self.readPrefsFromDisk()
                
        # if we did not load mysqlHost from disk, assume we should try and find the myth settings from the myth config files
        if not self.prefs.has_key("mysqlHost"):
            print "mysql host wasnt loaded from disk; searching for mysql settings"
            self.prefs.update( self.findMythMysqlSettings() )
            
        self.mainFrameStatusbar.PushStatusText('Preferences loaded.')
        
        print "loadPrefsFromDisk returning : ",self.prefs

            
    def findMythMysqlSettings(self):
        # Try to read the mysql.txt file used by MythTV.
        # Order taken from libs/libmyth/mythcontext.cpp
        config_files = [
            '/usr/local/share/mythtv/mysql.txt',
            '/usr/share/mythtv/mysql.txt',
            '/usr/local/etc/mythtv/mysql.txt',
            '/etc/mythtv/mysql.txt',
            os.path.expanduser('~/.mythtv/mysql.txt'),
            ]
        
        if 'MYTHCONFDIR' in os.environ:
            config_locations.append('%s/mysql.txt' % os.environ['MYTHCONFDIR'])

        found_config = False
        for config_file in config_files:

                dbconn_host = None
                dbconn_name = None
                dbconn_user = None
                dbconn_pass = None
                dbconn_port = None

                if not os.access(config_file, os.R_OK): 
                        continue

                for line in file(config_file):
                    
                    if line[0] != '#' and '=' in line:
                        equalPos = line.find('=')

                        key = line[0:equalPos]
                        val = line[equalPos+1:].strip()
                        
                        if key == "DBHostName":
                            dbconn_host = val
                        elif key == "DBPort":
                            dbconn_port = val
                        elif key == "DBName":
                            dbconn_name = val
                        elif key == "DBUserName":
                            dbconn_user = val
                        elif key == "DBPassword":
                            dbconn_pass = val

                if dbconn_host != None or dbconn_name != None or dbconn_user != None or dbconn_pass != None:
                    found_config = True
                    break
        
        # we didn't find a config file, just bail out
        if not found_config:
            return {}

        return {"mysqlHost": dbconn_host,
                "mysqlPort": dbconn_port,
                "mysqlDB": dbconn_name,
                "mysqlUser": dbconn_user,
                "mysqlPassword": dbconn_pass}
        

    ###########################################################################
    # event handler land

        
    def onMenuQuit(self, event): # wxGlade: mainFrame.<event_handler>
        sys.exit()


    def onItemRightClick(self, event): # wxGlade: mainFrame.<event_handler>
        
        menu = wx.Menu()

        for (id,title) in self.contextMenuEntriesById.iteritems():
            menu.Append(id, title)
            wx.EVT_MENU( menu, id, self.onContextMenuSelection )
            
        self.PopupMenu( menu )

        event.Skip()

    def onColClick(self, event): # wxGlade: mainFrame.<event_handler>

        clickedCol = event.GetColumn()

        if (clickedCol == self.lastColClick):
            self.sortToggler *= -1
        else:
            self.sortToggler = 1

        self.lastColClick = clickedCol
        
        self.mainFrameListCtrl.SortItems( self.sortList ) 

        event.Skip()


    def onContextMenuSelection(self, event):        
        selectedMenuItem = self.contextMenuEntriesById[ event.GetId() ]
        if selectedMenuItem == "Encode":
            self.addRecordingsToQueue()
        event.Skip()
        
    def onMenuQueue(self, event): # wxGlade: mainFrame.<event_handler>        
        print "showing encoderQueueFrame.."
        self.encoderQueueFrame.Show()
        event.Skip()

    def onToolbarEncode(self, event): # wxGlade: mainFrame.<event_handler>
        self.addRecordingsToQueue()
        event.Skip()

    def onToolbarDelete(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarDelete' not implemented"
        event.Skip()

    def onMenuDelete(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onMenuDelete' not implemented"
        event.Skip()

    def onMenuPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        self.preferencesFrame.Show()
        event.Skip()

    def onToolbarPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarPrefs' not implemented"
        event.Skip()

    def onToolbarQuit(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarQuit' not implemented"
        event.Skip()

    def onToolbarReload(self, event): # wxGlade: mainFrame.<event_handler>
        self.loadRecordingsFromMyth()
        event.Skip()

# end of class mainFrame





class aboutFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: aboutFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.aboutFrameContents = wx.StaticText(self, -1, "About MythRIP", style=wx.ALIGN_CENTRE)
        self.aboutFrameCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: aboutFrame.__set_properties
        self.SetTitle("MythRip - About")
        self.aboutFrameCloseButton.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: aboutFrame.__do_layout
        aboutFrameSizer = wx.BoxSizer(wx.VERTICAL)
        aboutFrameSizer.Add(self.aboutFrameContents, 0, wx.BOTTOM|wx.EXPAND, 0)
        aboutFrameSizer.Add(self.aboutFrameCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(aboutFrameSizer)
        aboutFrameSizer.Fit(self)
        self.Layout()
        # end wxGlade

# end of class aboutFrame


class encoderOptionsFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: encoderOptionsFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.encoderOptionsFrameStatusbar = self.CreateStatusBar(1, 0)

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: encoderOptionsFrame.__set_properties
        self.SetTitle("MythRip - Encoder Options")
        self.SetSize((400, 300))
        self.encoderOptionsFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        encoderOptionsFrameStatusbar_fields = ["encoderOptionsFrame_statusbar"]
        for i in range(len(encoderOptionsFrameStatusbar_fields)):
            self.encoderOptionsFrameStatusbar.SetStatusText(encoderOptionsFrameStatusbar_fields[i], i)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderOptionsFrame.__do_layout
        self.Layout()
        # end wxGlade

# end of class encoderOptionsFrame


class encoderQueueFrame(wx.Frame):
    def __init__(self, *args, **kwds):


        toolbarPause = wx.NewId()
        toolbarRemove = wx.NewId()
        toolbarUp = wx.NewId()
        toolbarDown = wx.NewId()
        toolbarOptions = wx.NewId()

        # begin wxGlade: encoderQueueFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Tool Bar
        self.encoderQueueFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.encoderQueueFrameToolbar)
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarPause, "Pause", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-media-pause.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Pause selected job(s)", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarRemove, "Remove", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-cancel.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Remove from queue", "Remove an item from the encoding queue")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarUp, "Up", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-up.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected recording(s) up", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarDown, "Down", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-down.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected recording(s) down", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarOptions, "Options", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Open the queue options dialog", "")
        # Tool Bar end
        self.encoderQueueListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.SUNKEN_BORDER)
        self.encoderQueueCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_TOOL, self.onToolbarPause, id=toolbarPause)
        self.Bind(wx.EVT_TOOL, self.onToolbarRemove, id=toolbarRemove)
        self.Bind(wx.EVT_TOOL, self.onToolbarUp, id=toolbarUp)
        self.Bind(wx.EVT_TOOL, self.onToolbarDown, id=toolbarDown)
        self.Bind(wx.EVT_TOOL, self.onToolbarOptions, id=toolbarOptions)
        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.encoderQueueCloseButton)
        # end wxGlade
        
        ##########################
        
        # this variable tracks the thread IDs .. 
        # because I use this style of identifying threads eventually the ID would wrap.. so there's the app's max threads limit!
        self.nextThreadID = 0

        # this variable contains a list of encoder jobs, including their thread handles
        self.threads = {}

        # set up the listctrl
        self.encoderQueueListCtrl.InsertColumn(0, "Show")
        self.encoderQueueListCtrl.InsertColumn(1, "Episode")
        self.encoderQueueListCtrl.InsertColumn(2, "Air Time")
        self.encoderQueueListCtrl.InsertColumn(3, "Progress")
        
        # connect up a handler to update the GUI upon events from the encoder threads
        EVT_ENCODER(self, self.onEncoderEvent)    
        

    def __set_properties(self):
        # begin wxGlade: encoderQueueFrame.__set_properties
        self.SetTitle("MythRip - Encoding Queue")
        self.SetSize((640, 300))
        self.encoderQueueFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderQueueFrame.__do_layout
        encoderQueueSizer = wx.BoxSizer(wx.VERTICAL)
        encoderQueueSizer.Add(self.encoderQueueListCtrl, 1, wx.EXPAND, 0)
        encoderQueueSizer.Add(self.encoderQueueCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(encoderQueueSizer)
        self.Layout()
        # end wxGlade

    ##########################################################################################
    # meat

    def addProgram(self,program):
        
        # grab the next thread id
        threadID = self.nextThreadID
        
        # prepare the thread id for the thread after this one
        self.nextThreadID += 1
        
        # create the thread.  
        self.threads[threadID] = encoderThread(program, threadID, self)
        self.threads[threadID].start()
                
        # determine the number of items in the control and add in the next available slot
        newListIndex = self.encoderQueueListCtrl.GetItemCount()

        # insert the new list ctrl item
        self.encoderQueueListCtrl.InsertStringItem(newListIndex, program.title)
        self.encoderQueueListCtrl.SetStringItem(newListIndex, 1, program.subtitle)
        self.encoderQueueListCtrl.SetStringItem(newListIndex, 2, str(program.starttime))
        self.encoderQueueListCtrl.SetStringItem(newListIndex, 3, 'Initializing...')
        self.encoderQueueListCtrl.SetItemData(newListIndex, threadID) # store the thread id with each item

        # keep the table clean with some column resizing
        self.resizeEncoderQueueListCtrl()
                
    def getSelectedEncoders(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:
            thread = self.threads[ self.encoderQueueListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.encoderQueueListCtrl.GetNextSelected(item)
        
        return returnList


    def resizeEncoderQueueListCtrl(self):
        self.encoderQueueListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)
    
    ##########################################################################################
    # event handlers


    # when an encoder event is received this is called
    def onEncoderEvent(self, event):

        print "Thread %d state %s : %s" % (event.threadID, event.threadState, event.listMessage)
        
        # we pretty much need this no matter what
        listCtrlIndex = self.encoderQueueListCtrl.FindItemData(0,event.threadID)
        
        if event.threadState == "terminating":
            # if the thread died, remove it from the thread pool, and remove the item from the listctrl

            print "Thread %d removed from thread pool." % event.threadID
            
            del self.threads[event.threadID]
            
            print "- Thread %d is at position %d in the list ctrl, removing it" % (event.threadID,listCtrlIndex)
            
            self.encoderQueueListCtrl.DeleteItem(listCtrlIndex)
            

        self.encoderQueueListCtrl.SetStringItem(listCtrlIndex, 3, event.listMessage)
        
        event.Skip()

    def onCloseButton(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.Hide()
        event.Skip()

    def onToolbarPause(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        
        print "Event handler `onToolbarPause' not implemented"
        event.Skip()

    def onToolbarRemove(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarRemove' not implemented"
        event.Skip()

    def onToolbarUp(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarUp' not implemented"
        event.Skip()

    def onToolbarDown(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarDown' not implemented"
        event.Skip()

    def onToolbarOptions(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarOptions' not implemented"
        event.Skip()

# end of class encoderQueueFrame

###################################################################
# encoder thread land

# get an ID for an "encoder" event 
EVT_ENCODER_ID = wx.NewId()

# define a macro for connecting event handlers to the encoder events
def EVT_ENCODER(theWin, theFunc):
   theWin.Connect(-1, -1, EVT_ENCODER_ID, theFunc)

# a simple event to throw out of the encoder
class encoderEvent(wx.PyEvent):
   def __init__(self, threadID, threadState, listMessage):
       wx.PyEvent.__init__(self)
       self.SetEventType(EVT_ENCODER_ID)
       self.threadID = threadID
       self.threadState = threadState
       self.listMessage = listMessage

# the encoder thread itself
class encoderThread(threading.Thread):
    
    def __init__(self, program, threadID, notifyWindow):
        
        self.notifyWindow = notifyWindow
        self.program = program
        self.threadID = threadID
        self.doCommand = ""
        self.mythTranscodeProcess = False

        # load parent constructor
        threading.Thread.__init__(self)
    
    def run(self):
                
        print "Thread ID %d : %s" % (self.threadID, self.program)
        
        # get directory for our fifos to live in
        fifoDir = '/tmp/mythrip-%d-fifo' % self.threadID

        if os.path.isdir(fifoDir):
            try:
                shutil.rmtree(fifoDir)
            except Exception, e:
                self.endThread("failed","Could not remove stale fifo directory: %s" % e)

        try:
            os.mkdir(fifoDir)
        except Exception, e:
            self.endThread("failed","Failed creating fifo directories: %s" % e)

        # fire up mythtranscode 
        mythTranscodeCmd = ['/usr/bin/mythtranscode',
               '--showprogress',
               '-p','autodetect',
               '-c',str(self.program.chanid),
               '-s',self.program.recstartts.strftime('%Y-%m-%dT%H:%M:%S'),
               '-f',fifoDir,
               '--honorcutlist']
        
        
        # use sockets for the subprocess file objects so we can read from stdout/stderr in a non-blocking fashion
        self.stdoutSockMT, stdoutChildSockMT = socket.socketpair() 
        self.stderrSockMT, stderrChildSockMT = socket.socketpair() 
        self.stdoutSockMT.settimeout(0.1)
        self.stderrSockMT.settimeout(0.1)

        self.mythTranscodeProcess = subprocess.Popen(mythTranscodeCmd, stdin=None, stdout=stdoutChildSockMT.fileno(), stderr=stderrChildSockMT.fileno())

        # replace me with a thing that waits to verify the fifo is up and ready
        time.sleep(1)
        
        # now fire up mencoder reading from mythtranscode's fifo
        # mencoder -aspect 1.33333333333333 -noskip -idx /tmp/fifodir_7895/vidout -audiofile /tmp/fifodir_7895/audout -demuxer 20 -audio-demuxer 20 -rawaudio rate=48000:channels=2 -demuxer 26 -rawvideo w=720:h=480:fps=29.970 -ovc xvid -passlogfile /tmp/xvid.7895.log -oac copy -xvidencopts bitrate=684:pass=1:quant_type=mpeg:threads=2:keyframe_boost=10:kfthreshold=1:kfreduction=20 -o /dev/null -vf crop=700:468:10:6,lavcdeint,scale=640:480

        mencoderCmd = ['/usr/bin/mencoder','-noskip','-idx',
                       os.path.join(fifoDir, 'vidout'),
                       '-audiofile', os.path.join(fifoDir,'audout'),
                       '-demuxer','20','-audio-demuxer','20',
                       '-rawvideo','w=720:h=480:fps=29.970',
                       '-rawaudio','rate=48000:channels=2','-demuxer','26',# '-rawvideo',
                       '-oac','copy',
                       
                       # xvid
                       '-ovc','xvid',
                       '-xvidencopts','bitrate=684',

                       # '-passlogfile',os.path.join(fifoDir,'logfile.log'),

                       # x264
                       '-ovc','x264',
                       '-x264encopts','qp=38:bframes=1', # :pass=1', # 'subq=5:8x8dct:frameref=2:bframes=3:b_pyramid:weight_b',

                       '-vf','lavcdeint',
                       '-o', '/home/sean/Desktop/video-thread-%d.avi' % self.threadID]

        self.stdoutSockMenc, stdoutChildSockMenc = socket.socketpair() 
        self.stderrSockMenc, stderrChildSockMenc = socket.socketpair() 
        self.stdoutSockMenc.settimeout(0.1)
        self.stderrSockMenc.settimeout(0.1)
        
        self.mencoderProcess = subprocess.Popen(mencoderCmd, stdin=None, stdout=stdoutChildSockMT.fileno(), stderr=stderrChildSockMT.fileno())
    

        
        self.sendEncoderEvent( "started", "Encoding started." )

        while True:
            
            self.parseSubprocessOutput()
            
            # it seems we are getting a None result before the thread actually dies
            # if self.mythTranscodeProcess.poll() == None:                
            # self.parseSubprocessOutput()
            # self.endThread("done","Encoder poll returned None")                
            # break

            # check for the abort command and if its there then bail!
            if self.doCommand == "abort":
                self.endThread("abort","Thread aborted.")
                break

            # wait a second before checking the subprocess again
            time.sleep(1)

        
    def parseSubprocessOutput(self):
        
        # read from all processes
        for (name,(stdoutSock,stderrSock)) in {"mt": [self.stdoutSockMT, self.stderrSockMT], 
                                               "menc": [self.stdoutSockMenc, self.stderrSockMenc] }.iteritems():
            newstdout = ""
            newstderr = ""

            try:
                newstdout = stdoutSock.recv(1024)
                newstderr = stderrSock.recv(1024)

            except socket.timeout, e:
                pass 

            # print em out if there was anything
            if len(newstdout):
                print "STDOUT %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstdout)
            if len(newstderr):
                print "STDERR %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstderr)



    # func called by the main thread in order to issue commands
    def setCommand(self,command):
        self.doCommand = setCommand

    def endThread(self,threadState,listMessage):

        # i'm hoping this kills the subprocess... if not i might just use process.pid to kill it
        del self.mythTranscodeProcess

        # the last thing the thread does is tell the main thread its terminating, and thats a rule
        self.sendEncoderEvent( threadState, listMessage )

        sys.exit()
       
    def sendEncoderEvent(self, threadState, listMessage):
        wx.PostEvent(self.notifyWindow, encoderEvent(self.threadID, threadState, listMessage))

###########################################################################
        

class preferencesFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: preferencesFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.preferencesNotebook = wx.Notebook(self, -1, style=0)
        self.preferencesFilesPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesQueuePane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesEncodersPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesMythTVPane = wx.Panel(self.preferencesNotebook, -1)
        self.prefsMysqlHostLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Hostname: ")
        self.prefsMysqlHostText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.prefsMysqlPortLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Port: ")
        self.prefsMysqlPortText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.prefsMysqlUserLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL User: ")
        self.prefsMysqlUserText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.prefsMysqlPasswordLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Password: ")
        self.prefsMysqlPasswordText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.prefsMysqlDBNameLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Database Name: ")
        self.prefsMysqlDBNameText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.prefsContainerFormatLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Container Format: ")
        self.prefsContainerFormatChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["avi", "mkv"])
        self.prefsVideoCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Codec: ")
        self.prefsVideoCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["xvid", "x264"])
        self.prefsVideoCodecOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Codec Options (): ")
        self.prefsVideoCodecOptionsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.prefsTwoPassVideoLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Two-Pass Video: ")
        self.prefsTwoPassVideoChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["Yes", "No"])
        self.prefsAudioCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec: ")
        self.prefsAudioCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["passthrough", "mp3lame", "ogg", "whatever"])
        self.prefsAudioCodecOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec Options ():")
        self.prefsAudioCodecOptionsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.prefsAudioFilterLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Filter String (-af): ")
        self.prefsAudioFilterText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.label_1 = wx.StaticText(self.preferencesQueuePane, -1, "Thread count: ")
        self.spin_ctrl_1 = wx.SpinCtrl(self.preferencesQueuePane, -1, "", min=0, max=100)
        self.label_2 = wx.StaticText(self.preferencesQueuePane, -1, "Remove Completed Items: ")
        self.choice_6 = wx.Choice(self.preferencesQueuePane, -1, choices=["Yes", "No"])
        self.label_8 = wx.StaticText(self.preferencesFilesPane, -1, "Save Encoded Videos In: ")
        self.window_1 = wx.DirPickerCtrl(self.preferencesFilesPane, -1)
        self.label_9 = wx.StaticText(self.preferencesFilesPane, -1, "File Naming Template: ")
        self.text_ctrl_1 = wx.TextCtrl(self.preferencesFilesPane, -1, "")
        self.preferencesCancelButton = wx.Button(self, wx.ID_CANCEL, "")
        self.preferencesOKButton = wx.Button(self, wx.ID_OK, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCancelButton, self.preferencesCancelButton)
        self.Bind(wx.EVT_BUTTON, self.onOKButton, self.preferencesOKButton)
        # end wxGlade

        # preferences frame variable to prefs value array - straight assignments
        self.prefMap = {"mysqlHost": self.prefsMysqlHostText,
                        "mysqlPort": self.prefsMysqlPortText,
                        "mysqlUser": self.prefsMysqlUserText,
                        "mysqlPassword": self.prefsMysqlPasswordText,
                        "mysqlDB": self.prefsMysqlDBNameText}

    def __set_properties(self):
        # begin wxGlade: preferencesFrame.__set_properties
        self.SetTitle("MythRip - Preferences")
        self.prefsContainerFormatChoice.SetSelection(0)
        self.prefsVideoCodecChoice.SetSelection(0)
        self.prefsTwoPassVideoChoice.SetSelection(0)
        self.prefsAudioCodecChoice.SetSelection(0)
        self.choice_6.SetSelection(0)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: preferencesFrame.__do_layout
        preferencesSizer = wx.BoxSizer(wx.VERTICAL)
        preferencesButtonSizer = wx.BoxSizer(wx.HORIZONTAL)
        preferencesFilesSizer = wx.GridSizer(2, 2, 0, 0)
        preferencesQueueSIzer = wx.GridSizer(2, 2, 0, 0)
        preferencesEncodersSizer = wx.GridSizer(7, 2, 0, 0)
        preferencesMythTVSizer = wx.GridSizer(7, 2, 0, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlHostLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlHostText, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlPortLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlPortText, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlUserLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlUserText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlPasswordLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlPasswordText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlDBNameLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.prefsMysqlDBNameText, 0, wx.EXPAND, 0)
        self.preferencesMythTVPane.SetSizer(preferencesMythTVSizer)
        preferencesEncodersSizer.Add(self.prefsContainerFormatLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.prefsContainerFormatChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.prefsVideoCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.prefsVideoCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.prefsVideoCodecOptionsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.prefsVideoCodecOptionsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.prefsTwoPassVideoLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.prefsTwoPassVideoChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.prefsAudioCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.prefsAudioCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.prefsAudioCodecOptionsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.prefsAudioCodecOptionsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.prefsAudioFilterLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.prefsAudioFilterText, 0, wx.EXPAND, 0)
        self.preferencesEncodersPane.SetSizer(preferencesEncodersSizer)
        preferencesQueueSIzer.Add(self.label_1, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.spin_ctrl_1, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.label_2, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.choice_6, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        self.preferencesQueuePane.SetSizer(preferencesQueueSIzer)
        preferencesFilesSizer.Add(self.label_8, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.window_1, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.label_9, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.text_ctrl_1, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        self.preferencesFilesPane.SetSizer(preferencesFilesSizer)
        self.preferencesNotebook.AddPage(self.preferencesMythTVPane, "MythTV")
        self.preferencesNotebook.AddPage(self.preferencesEncodersPane, "Encoders")
        self.preferencesNotebook.AddPage(self.preferencesQueuePane, "Queue")
        self.preferencesNotebook.AddPage(self.preferencesFilesPane, "Files")
        preferencesSizer.Add(self.preferencesNotebook, 1, wx.EXPAND, 0)
        preferencesButtonSizer.Add(self.preferencesCancelButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesButtonSizer.Add(self.preferencesOKButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesSizer.Add(preferencesButtonSizer, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(preferencesSizer)
        preferencesSizer.Fit(self)
        self.Layout()
        # end wxGlade


    # set the preferences window to the prefs defined in the prefs argument
    def setPreferences(self, prefs):
        print "prefs frame being set with prefs passed from caller",prefs

        self.prefs = prefs
        
        for (prefKey,controlVar) in self.prefMap.iteritems():
            if prefs.has_key( prefKey ):
                controlVar.SetValue( str(prefs[ prefKey ]) )
                    

    # load the preferences that are currently set in this frame in to a prefs array and return it
    def getPreferences(self):
        print "prefs frame getting preferences from frame and returning them"
        
        prefs = {}
        
        for (prefKey,controlVar) in self.prefMap.iteritems():
            prefs[ prefKey ] = controlVar.GetValue()

        return prefs

    def onCancelButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        self.Hide()
        event.Skip()

    def onOKButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        # this event is picked up by the mainframe where the actual saving/load of preferences takes place
        self.Hide()
        event.Skip()
        
# end of class preferencesFrame


class mythRipMain(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        self.mainFrameInstance = mainFrame(None, -1, "")
        self.SetTopWindow(self.mainFrameInstance)
        self.mainFrameInstance.Show()
        return 1

# end of class mythRipMain

if __name__ == "__main__":
    mythRip = mythRipMain(0)
    mythRip.MainLoop()

