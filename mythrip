#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Fri May 22 10:25:23 2009

# mythrip: GUI tool to export MythTV recordings to various portable media files, and manage recordings in general

# standard python stuff
import os, shutil, sys, threading, subprocess, socket, re, time, signal, stat, cPickle, base64, StringIO, traceback

# add to the sys.path if this prog is being run from a known path
dir = os.path.split(__file__)[0]

pathMap = {"/usr/bin" : "/usr/share/mythrip",
           "/usr/local/bin" : "/usr/local/share/mythrip"}

if pathMap.has_key(dir):    
    addPath = pathMap[dir]
    sys.path.append( addPath )
    
# we should hopefully have this somewhere in sys.path at this point
try:
    import mythtv
except Exception, e:
    print "Failed to find mythtv module: %s" % e
    sys.exit()

# wxpython
import wx


# begin wxGlade: extracode
# end wxGlade

###############################################################################################################
## Global App Stuff

# for now i just snag the logger from the mythtv bindings.. maybe it'd be better to use my own.. i dunno
log = mythtv.log
DEBUG = mythtv.DEBUG
INFO = mythtv.INFO
WARNING = mythtv.WARNING
ERROR = mythtv.ERROR
FATAL = mythtv.FATAL
CRITICAL = mythtv.CRITICAL

# string defining the default log level, used by optparse 
defaultLogLevel = 'WARNING'

# our version
mythripVersionString = "MythRip v0.1"

# default config file
mythripRc = os.path.expanduser('~')+'/.mythriprc'


################################################################################################################

# value from prefs: ["oac name", (bool) supports option string, "optionstringname"]
audioCodecDict = {0: ['copy',False],
                  1: ['pcm',False],
                  2: ['mp3lame',True,'-lameopts','preset=medium'],
                  3: ['lavc',True,'-lavcopts','acodec=flac'] }
            
# value from prefs: ["ovc name", (bool) supports option string, "optionstringname", "default option string first pass", "default option string second pass"]
videoCodecDict = {0: ['copy',False],
                  1: ['xvid',True,'-xvidencopts','fixed_quant=6','fixed_quant=6'],
                  2: ['x264',True,'-x264encopts','subq=1:frameref=1:bitrate=600','subq=6:frameref=15:partitions=all:me=umh:bitrate=600',''],
                  3: ['lavc',True,'-lavcopts','vcodec=mpeg4:mdb=1:vbitrate=600','vcodec=mpeg4:mdb=1:vbitrate=600']}

###############################################################################################################

class threadDetailFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: threadDetailFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.threadDetailLabel = wx.StaticText(self, -1, "Details for thread:")
        self.threadDetailInformation = wx.StaticText(self, -1, "")
        self.static_line_1 = wx.StaticLine(self, -1)
        self.threadMencoderPass1Label = wx.StaticText(self, -1, "mencoder Pass 1 Command:")
        self.threadMencoderPass1Cmd = wx.StaticText(self, -1, "[ Waiting.. ]")
        self.static_line_2 = wx.StaticLine(self, -1)
        self.threadMencoderPass2Label = wx.StaticText(self, -1, "mencoder Pass 2 Command:")
        self.threadMencoderPass2Cmd = wx.StaticText(self, -1, "[ Waiting.. ]")
        self.static_line_6 = wx.StaticLine(self, -1)
        self.threadMythtranscodeLabel = wx.StaticText(self, -1, "mythtranscode Command:")
        self.threadMythtranscodeCmd = wx.StaticText(self, -1, "[ Waiting.. ]")
        self.static_line_5 = wx.StaticLine(self, -1)
        self.threadMessagesLabel = wx.StaticText(self, -1, "Errors: ")
        self.threadMessagesText = wx.StaticText(self, -1, "[ None ]")
        self.static_line_7 = wx.StaticLine(self, -1)
        self.closeButton = wx.Button(self, -1, "Close")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.closeButton)
        # end wxGlade
        
        self.Bind(wx.EVT_SIZE, self.onResize, self)
        
        self.threadID = 0

        # start the updater timer
        self.genericTickingTimer = genericTickingTimer()
        self.genericTickingTimer.setFrameHandle(self)
        self.genericTickingTimer.Start(milliseconds=1000)
        
    def __set_properties(self):
        # begin wxGlade: threadDetailFrame.__set_properties
        self.SetTitle("Thread Details")
        self.SetSize((798, 621))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: threadDetailFrame.__do_layout
        threadDetailSizer = wx.BoxSizer(wx.VERTICAL)
        threadDetailInfoSizer = wx.BoxSizer(wx.HORIZONTAL)
        threadDetailInfoSizer.Add(self.threadDetailLabel, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        threadDetailInfoSizer.Add(self.threadDetailInformation, 0, wx.LEFT|wx.ALIGN_CENTER_VERTICAL, 5)
        threadDetailSizer.Add(threadDetailInfoSizer, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        threadDetailSizer.Add((20, 20), 0, 0, 0)
        threadDetailSizer.Add(self.static_line_1, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMencoderPass1Label, 0, 0, 0)
        threadDetailSizer.Add(self.threadMencoderPass1Cmd, 0, 0, 0)
        threadDetailSizer.Add((20, 20), 0, 0, 0)
        threadDetailSizer.Add(self.static_line_2, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMencoderPass2Label, 0, 0, 0)
        threadDetailSizer.Add(self.threadMencoderPass2Cmd, 0, 0, 0)
        threadDetailSizer.Add((20, 20), 0, 0, 0)
        threadDetailSizer.Add(self.static_line_6, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMythtranscodeLabel, 0, 0, 0)
        threadDetailSizer.Add(self.threadMythtranscodeCmd, 0, 0, 0)
        threadDetailSizer.Add((20, 20), 1, wx.EXPAND, 0)
        threadDetailSizer.Add(self.static_line_5, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMessagesLabel, 0, 0, 0)
        threadDetailSizer.Add(self.threadMessagesText, 0, 0, 0)
        threadDetailSizer.Add(self.static_line_7, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.closeButton, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 0)
        self.SetSizer(threadDetailSizer)
        self.Layout()
        # end wxGlade

    def setThreadID(self, threadID):        
        self.encoderThread = self.GetParent().threads[ threadID ] 
        self.threadID = threadID
        self.refreshThreadInfo()
        
    def refreshThreadInfo(self):
        if self.encoderThread.mencoderCmd.has_key(1):
            self.threadMencoderPass1Cmd.SetLabel( " ".join(self.encoderThread.mencoderCmd[1]) )

        if self.encoderThread.mencoderCmd.has_key(2):
            self.threadMencoderPass2Cmd.SetLabel( " ".join(self.encoderThread.mencoderCmd[2]) )        
            
        if self.encoderThread.mythtranscodeCmd and len(self.encoderThread.mythtranscodeCmd):
            self.threadMythtranscodeCmd.SetLabel(" ".join(self.encoderThread.mythtranscodeCmd))

        if self.encoderThread.state in ["failed","failedAndAcknowledged"]:
            self.threadMessagesText.SetLabel( self.encoderThread.failedMessage )

        self.threadDetailInformation.SetLabel( str(self.threadID) )

    def refreshAll(self):
        self.refreshThreadInfo()

        width = self.GetSizeTuple()[0]
        self.threadMencoderPass1Cmd.Wrap( width )
        self.threadMencoderPass2Cmd.Wrap( width )
        self.threadMythtranscodeCmd.Wrap( width )
        self.threadMessagesText.Wrap( width )

        self.Layout()

    def onCloseButton(self, event): # wxGlade: threadDetailFrame.<event_handler>
        self.Destroy()
        event.Skip()

    def onRefreshButton(self, event): # wxGlade: threadDetailFrame.<event_handler>
        self.refreshThreadInfo()
        event.Skip()

    def onResize(self, event):
        self.refreshAll()
        event.Skip()

    def onTimerTick(self):
        self.refreshAll()

# end of class threadDetailFrame



class mainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        
        toolbarEncode = wx.NewId()
        toolbarView = wx.NewId()
        toolbarDelete = wx.NewId()
        toolbarDeleteRerecord = wx.NewId()
        toolbarPrefs = wx.NewId()
        toolbarReload = wx.NewId()
        toolbarQuit = wx.NewId()

        # begin wxGlade: mainFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.mainFrameMenubar = wx.MenuBar()
        self.fileMenuItem = wx.Menu()
        self.reloadMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Reload", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.reloadMenuItem)
        self.encodeMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Encode", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.encodeMenuItem)
        self.viewMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&View", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.viewMenuItem)
        self.fileMenuItem.AppendSeparator()
        self.quitMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Quit", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.quitMenuItem)
        self.mainFrameMenubar.Append(self.fileMenuItem, "&File")
        self.editMenuItem = wx.Menu()
        self.deleteMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Delete", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.deleteMenuItem)
        self.deleteRerecordMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Delete + Re-record", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.deleteRerecordMenuItem)
        self.editMenuItem.AppendSeparator()
        self.prefsMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Preferences", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.prefsMenuItem)
        self.mainFrameMenubar.Append(self.editMenuItem, "&Edit")
        self.viewTopMenuItem = wx.Menu()
        self.queMenuItem = wx.MenuItem(self.viewTopMenuItem, wx.NewId(), "&Queue", "", wx.ITEM_NORMAL)
        self.viewTopMenuItem.AppendItem(self.queMenuItem)
        self.mainFrameMenubar.Append(self.viewTopMenuItem, "&View")
        self.helpMenuItem = wx.Menu()
        self.aboutMenuItem = wx.MenuItem(self.helpMenuItem, wx.NewId(), "&About", "", wx.ITEM_NORMAL)
        self.helpMenuItem.AppendItem(self.aboutMenuItem)
        self.mainFrameMenubar.Append(self.helpMenuItem, "&Help")
        self.SetMenuBar(self.mainFrameMenubar)
        # Menu Bar end
        self.mainFrameStatusbar = self.CreateStatusBar(1, 0)
        
        # Tool Bar
        self.mainFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.mainFrameToolbar)
        self.mainFrameToolbar.AddLabelTool(toolbarReload, "Reload", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/reload.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Reload MythTV recording list", "")
        self.mainFrameToolbar.AddSeparator()
        self.mainFrameToolbar.AddLabelTool(toolbarView, "View", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-media-play-ltr.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "View selected recording", "")
        self.mainFrameToolbar.AddLabelTool(toolbarEncode, "Encode", wx.Bitmap("/usr/share/icons/gnome/32x32/categories/applications-system.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Encode selected recordings(s)", "")
        self.mainFrameToolbar.AddSeparator()
        self.mainFrameToolbar.AddLabelTool(toolbarDelete, "Delete", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/stock_delete.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Delete and do not re-record selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarDeleteRerecord, "DeleteRerecord", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/window-close.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Delete and re-record selected recording(s)", "")
        self.mainFrameToolbar.AddSeparator()
        self.mainFrameToolbar.AddLabelTool(toolbarPrefs, "Preferences", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Open preferences dialog", "")
        self.mainFrameToolbar.AddLabelTool(toolbarQuit, "Quit", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/application-exit.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Quit", "")
        # Tool Bar end
        self.mainFrameListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.LC_EDIT_LABELS|wx.LC_SORT_ASCENDING|wx.SUNKEN_BORDER)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.onReload, self.reloadMenuItem)
        self.Bind(wx.EVT_MENU, self.onEncode, self.encodeMenuItem)
        self.Bind(wx.EVT_MENU, self.onView, self.viewMenuItem)
        self.Bind(wx.EVT_MENU, self.onQuit, self.quitMenuItem)
        self.Bind(wx.EVT_MENU, self.onDelete, self.deleteMenuItem)
        self.Bind(wx.EVT_MENU, self.onDeleteRerecord, self.deleteRerecordMenuItem)
        self.Bind(wx.EVT_MENU, self.onPrefs, self.prefsMenuItem)
        self.Bind(wx.EVT_MENU, self.onQueue, self.queMenuItem)
        self.Bind(wx.EVT_MENU, self.onAbout, self.aboutMenuItem)
        self.Bind(wx.EVT_TOOL, self.onReload, id=toolbarReload)
        self.Bind(wx.EVT_TOOL, self.onView, id=toolbarView)
        self.Bind(wx.EVT_TOOL, self.onEncode, id=toolbarEncode)
        self.Bind(wx.EVT_TOOL, self.onDelete, id=toolbarDelete)
        self.Bind(wx.EVT_TOOL, self.onDeleteRerecord, id=toolbarDeleteRerecord)
        self.Bind(wx.EVT_TOOL, self.onPrefs, id=toolbarPrefs)
        self.Bind(wx.EVT_TOOL, self.onQuit, id=toolbarQuit)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.onColClick, self.mainFrameListCtrl)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.onItemRightClick, self.mainFrameListCtrl)
        # end wxGlade

        ################################################################################
        # Various non-wxglade GUI setup

        # set up our various single-instance child frames
        self.encoderQueueFrame = encoderQueueFrame(parent=self)
        self.preferencesFrame = preferencesFrame(parent=self)
        self.aboutFrame = aboutFrame(parent=self)

        # bind "OK" button presses in preferences frame to our own event handler
        self.Bind(wx.EVT_BUTTON, self.onPrefsOK, self.preferencesFrame.preferencesOKButton)
        self.Bind(wx.EVT_BUTTON, self.onPrefsCancel, self.preferencesFrame.preferencesCancelButton)

        # set up the ListCtrl columns
        self.mainFrameListCtrl.InsertColumn(0, "Show")
        self.mainFrameListCtrl.InsertColumn(1, "Episode")
        self.mainFrameListCtrl.InsertColumn(2, "Air Time")
        self.mainFrameListCtrl.InsertColumn(3, "Flags")

        ###################################################################################
        # preference handling

        # map of options support by the config file and internal prefs

        self.optionMap = ( { 'short': '-P', 'long': '--mysqlport', 'action': 'store', 'dest': 'mysqlPort', 'default': 3306, 'help': 'MythTV MySQL Port', 'autoDiscover': True },
                           { 'short': '-H', 'long': '--mysqlhost', 'action': 'store', 'dest': 'mysqlHost', 'default': 'localhost', 'help': 'MythTV MySQL Host', 'autoDiscover': True},
                           { 'short': '-u', 'long': '--mysqluser', 'action': 'store', 'dest': 'mysqlUser', 'default': 'localhost', 'help': 'MythTV MySQL User', 'autoDiscover': True},
                           { 'short': '-p', 'long': '--mysqlpass', 'action': 'store', 'dest': 'mysqlPassword', 'default': 'localhost', 'help': 'MythTV MySQL Password', 'autoDiscover': True},
                           { 'short': '-D', 'long': '--mysqldb', 'action': 'store', 'dest': 'mysqlDB', 'default': 'localhost', 'help': 'MythTV MySQL Database Name', 'autoDiscover': True},
                           { 'short': '-R', 'long': '--mythrecordingpath', 'action': 'store', 'dest': 'mythtvRecordingPath', 'default': '/mythtv', 'help': 'MythTV Recording Path'},
                           { 'short': '-C', 'long': '--mythcutlist', 'action': 'store', 'dest': 'useMythCutlist', 'default': '0', 'help': 'Use MythTV Cutlist'},
                           { 'short': '-m', 'long': '--mencoderpath', 'action': 'store', 'dest': 'mencoderPath', 'default': '/usr/bin/mencoder', 'help': 'Full path to mencoder'},
                           { 'short': '-M', 'long': '--playerpath', 'action': 'store', 'dest': 'playerPath', 'default': '/usr/bin/mplayer', 'help': 'Full path to player'},
                           { 'short': '-z', 'long': '--mythtranscodepath', 'action': 'store', 'dest': 'mythtranscodePath', 'default': '/usr/bin/mythtranscode', 'help': 'Full path to mythtranscode'},
                           { 'short': '-c', 'long': '--container', 'action': 'store', 'dest': 'containerFormat', 'default': '0', 'help' : 'Container format' },
                           { 'short': '-U', 'long': '--extraflags', 'action': 'store', 'dest': 'extraFlags', 'default': '', 'help' : 'Extra mencoder flags' },
                           { 'short': '-v', 'long': '--videocodec', 'action': 'store', 'dest': 'videoCodec', 'default': '0', 'help' : 'Video Codec Choice Index' },
                           { 'short': '-1', 'long': '--videocodecopts', 'action': 'store', 'dest': 'videoFirstPassOpts', 'default': '', 'help' : 'Video Codec Option String - Pass 1' },
                           { 'short': '-2', 'long': '--videocodecoptspass2', 'action': 'store', 'dest': 'videoSecondPassOpts', 'default': '', 'help' : 'Video Codec Option String - Pass 2' },
                           { 'short': '-f', 'long': '--videofilter', 'action': 'store', 'dest': 'videoFilter', 'default': 'pp=fd', 'help': 'Video Filter String' },
                           { 'short': '-T', 'long': '--twopass', 'action': 'store', 'dest': 'twoPassVideo', 'default': '0', 'help' : 'Two Pass Video Choice Index' },
                           { 'short': '-a', 'long': '--audiocodec', 'action': 'store', 'dest': 'audioCodec', 'default': '0', 'help' : 'Audio Codec Choice Index' },
                           { 'short': '-A', 'long': '--audiocodecopts', 'action': 'store', 'dest': 'audioCodecOptions', 'default': '', 'help' : 'Audio Codec Option String' },
                           { 'short': '-F', 'long': '--audiofilter', 'action': 'store', 'dest': 'audioFilter', 'default': 'volnorm', 'help' : 'Audio Filter String' },
                           { 'short': '-t', 'long': '--threadcount', 'action': 'store', 'dest': 'threadCount', 'default': '2', 'help' : 'Max Simultaneous Encoding Jobs' },
                           { 'short': '-r', 'long': '--removecompleted', 'action': 'store', 'dest': 'removeCompleted', 'default': '1', 'help' : 'Remove Completed Job Choice Index' },                       
                           { 'short': '-s', 'long': '--savepath', 'action': 'store', 'dest': 'savePath', 'default': os.path.expanduser('~/Desktop'), 'help' : 'Save Encodings to Path' }, 
                           { 'short': '-x', 'long': '--filetemplate', 'action': 'store', 'dest': 'fileTemplate', 'default': '%s - %e - %i', 'help' : 'Output File Naming Template' },
                           { 'short': '-d', 'long': '--debuglevel', 'action': 'store', 'dest': 'debugLevel', 'default': defaultLogLevel, 'help': 'Debug Level: CRITICAL, FATAL, ERROR, WARNING, INFO or DEBUG'}
                           )
        # load preferences from disk
        self.loadPrefsFromDisk()
        
        # load preferences from CLI ; these override disk preferences
        self.loadPrefsFromCli()

        # push the prefs we've gathered in to the preferences frame
        self.populatePrefsToChildren()

        ###############################################################################
        # make mythtv connection and load data from it
        
        # a variable to stuff the program list in to
        self.programList = []

        # connect to mythtv
        if self.connectToMyth():

            # load recordings from myth
            self.loadRecordingsFromMyth()

    def __set_properties(self):
        # begin wxGlade: mainFrame.__set_properties
        self.SetTitle("MythRip - Main")
        self.SetSize((720, 430))
        self.mainFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        mainFrameStatusbar_fields = ["mainFrame_statusbar"]
        for i in range(len(mainFrameStatusbar_fields)):
            self.mainFrameStatusbar.SetStatusText(mainFrameStatusbar_fields[i], i)
        self.mainFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: mainFrame.__do_layout
        mainFrameSizer = wx.BoxSizer(wx.HORIZONTAL)
        mainFrameSizer.Add(self.mainFrameListCtrl, 1, wx.EXPAND, 0)
        self.SetSizer(mainFrameSizer)
        self.Layout()
        # end wxGlade

    def connectToMyth(self):        
        # establish our MythTV connection using the mythtv python bindings, push our preferences in to it
        try: 
            self.mythTV = mythtv.MythTV(force_db_opts=self.prefs)
            return True
        except Exception, e:
            # fetch the traceback and push it to logging
            fp = StringIO.StringIO()
            traceback.print_exc(file=fp)
            tracebackString = fp.getvalue()
            log.Msg(CRITICAL, 'Failed connecting to MythTV: %s' % tracebackString)

            # show the user a nice dialog
            self.showErrorDialog("Error connecting to MythTV", "Error connecting to MythTV:\n%s\nPlease alter your MythTV settings in the Preferences Dialog"%str(e))

            # send the user to the preferences dialog
            self.preferencesFrame.Show()
            self.mythTV = False
            return False

        
    def loadRecordingsFromMyth(self):

        # delete any listctrl items currently present
        for i in range(len(self.programList)):
            self.mainFrameListCtrl.DeleteItem( self.mainFrameListCtrl.FindItemData(0, i) )

        # reset the programList
        self.programList = []

        # query recordings from the backend
        rawRecordings = self.mythTV.backendCommand('QUERY_RECORDINGS Play').split(mythtv.BACKEND_SEP)            

        if len(rawRecordings):
            # determine the record length and number of recordings present in the response
            numberRecordings = int(rawRecordings[0])        
            recordingLength = (len(rawRecordings) - 1) / numberRecordings

            # parse the output, stuff the results in to a list of Program objects

            for recording in range(numberRecordings):            
                idxStart = ( recording * recordingLength ) + 1    # plus one - offset for the beginning's "record count" record
                idxStop = ( recording + 1 ) * recordingLength     # stop at the next recording beginning

                recordingData = rawRecordings[idxStart:idxStop]

                log.Msg(DEBUG, "Recording data scrape: %s" % recordingData)

                self.programList.append( mythtv.Program( recordingData ) )
            
        # add recording count to the status bar
        self.mainFrameStatusbar.PushStatusText('Loaded %d recordings' % len(self.programList))
        
        
        # push in the ListCtrl data
        for i in range(len(self.programList)):
            program = self.programList[i]
            self.mainFrameListCtrl.InsertStringItem(i, program.title)
            self.mainFrameListCtrl.SetStringItem(i, 1, program.subtitle)
            self.mainFrameListCtrl.SetStringItem(i, 2, str(program.starttime))
            
            # unpack program flags to english strings
            flags = []
            for k,v in mythtv.PROGRAM_FLAGS.iteritems():
                if int(program.programflags) & v:
                    flags.append(k)

            self.mainFrameListCtrl.SetStringItem(i, 3, ', '.join(flags) )
            self.mainFrameListCtrl.SetItemData(i, i)  # set item datas to be the same as indexes initially
            
        # make nice column sizes
        self.mainFrameListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)
        
        # these variables are for preserving the listctrl sorting state
        self.lastColClick = 0
        self.sortToggler = 1

        # run an initial sort
        self.mainFrameListCtrl.SortItems( self.sortList ) 
        

    # this is the callback to sort the mainFrameListCtrl used by mainFrameListCtrl.SortItems
    def sortList(self, item1, item2):
        
        progLeft = self.programList[ item1 ]
        progRight = self.programList[ item2 ]
        
        if self.lastColClick == 0:
            if progLeft.title < progRight.title:
                return -1 * self.sortToggler
            elif progLeft.title == progRight.title:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 1:
            if progLeft.subtitle < progRight.subtitle:
                return -1 * self.sortToggler
            elif progLeft.subtitle == progRight.subtitle:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 2:
            if progLeft.starttime < progRight.starttime:
                return -1 * self.sortToggler
            elif progLeft.starttime == progRight.starttime:
                return 0
            else:
                return 1 * self.sortToggler

        return 0
    
    
    # this function returns a list of the mythtv Program objects that have been selected
    def getSelectedPrograms(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.mainFrameListCtrl.GetFirstSelected()
        while item != -1:
            program = self.programList[ self.mainFrameListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.mainFrameListCtrl.GetNextSelected(item)
        
        return returnList
    
    def addRecordingsToQueue(self):
        
        addcount = 0
        for program in self.getSelectedPrograms():
            self.encoderQueueFrame.addProgram(program)
            addcount += 1

        # automatically show encoder queue when we add to it
        if addcount > 0:
            self.encoderQueueFrame.Show()

        self.mainFrameStatusbar.PushStatusText('Added %d recordings to queue.' % addcount)
        

    def readPrefsFromDisk(self):
        prefs = {}
	
	if not os.access(mythripRc,os.F_OK):
            log.Msg(WARNING, "%s not found, generating a new one set to application defaults" % mythripRc)
	    self.resetDiskPrefs()

        # read config file	    
	lines = file(mythripRc,'r').readlines()

	# parse config line by line
	for line in lines:
	    if line[0] != '#':
		delimiterAt = line.find(' ')
		if delimiterAt != -1:
		    opt = line[:delimiterAt].strip()

                    # preset options handled a bit differently..
                    if opt[:7] == 'preset-':
                        presetName = base64.b64decode( opt[7:delimiterAt] )
                        value = line[delimiterAt+1:].rstrip("\n")
                        
                        self.preferencesFrame.presetDict[ presetName ] = cPickle.loads( base64.b64decode(value) )

                        self.preferencesFrame.populatePresetCombo()

                    else:
                        value = line[delimiterAt+1:].rstrip("\n")

                        # try to interpret config options
                        if value.lower() == 'true':
                            setvalue = True
                        elif value.lower() == 'false':
                            setvalue = False
                        elif value.isdigit():
                            setvalue = int(value)
                        else:
                            setvalue = value

                        prefs[opt] = setvalue

        return prefs

    def resetDiskPrefs(self):
        cfg = file(mythripRc,'w+')
        cfg.write("# Automatically generated mythrip config file.\n\n")
        for option in self.optionMap:
            
            # we avoid writing the mysql options because they are automatically discovered by the self.findMythMysqlSettings
            if option.has_key('autoDiscover'):
                optionPrefix = "# "
            else:
                optionPrefix = ""

            cfg.write("# %s\n%s%s %s\n\n" % (option['help'], optionPrefix, option['dest'], option['default']))

        cfg.write("# Preset 'x264 - Television'\npreset-eDI2NCAtIFRlbGV2aXNpb24gMg== KGRwMQpTJ2V4dHJhRmxhZ3MnCnAyClYKc1MndmlkZW9Db2RlYycKcDMKSTIKc1MndmlkZW9GaWx0ZXInCnA0ClZwcD1mZApwNQpzUydhdWRpb0ZpbHRlcicKcDYKVnZvbG5vcm0KcDcKc1MndmlkZW9GaXJzdFBhc3NPcHRzJwpwOApWYml0cmF0ZT04MDA6c3VicT0xOmZyYW1lcmVmPTE6cmVmPTM6bWl4ZWQtcmVmczpiZnJhbWVzPTY6d2VpZ2h0YjpkaXJlY3Q9YXV0bzpiLXB5cmFtaWQ6YW5hbHlzZT1hbGw6OHg4ZGN0OnRyZWxsaXM9MTpucj0xNTA6cHN5LXJkPTEsMQpwOQpzUydhdWRpb0NvZGVjT3B0aW9ucycKcDEwClZwcmVzZXQ9bWVkaXVtCnAxMQpzUyd0d29QYXNzVmlkZW8nCnAxMgpJMApzUyd2aWRlb1NlY29uZFBhc3NPcHRzJwpwMTMKVmJpdHJhdGU9ODAwOnN1YnE9NjpmcmFtZXJlZj0xNTpyZWY9MzptaXhlZC1yZWZzOmJmcmFtZXM9Njp3ZWlnaHRiOmRpcmVjdD1hdXRvOmItcHlyYW1pZDptZT11bWg6c3VibWU9OTphbmFseXNlPWFsbDo4eDhkY3Q6dHJlbGxpcz0xOm5yPTE1MDpuby1mYXN0LXBza2lwPTE6cHN5LXJkPTEsMQpwMTQKc1MnYXVkaW9Db2RlYycKcDE1CkkyCnNTJ2NvbnRhaW5lckZvcm1hdCcKcDE2CkkwCnMu\n\n")

        cfg.close()

    # write a dictionary of options to the configuration file
    def writePrefsToDisk(self):

        cfg = file(mythripRc,'w+')
        cfg.write("# Automatically generated mythrip config file.\n# Values in this file are overwritten every time you click 'OK' in the preferences dialog!!\n\n")

        # write standard options 
        for option in self.optionMap:
            if self.prefs.has_key( option["dest"] ): # if the option appears in our prefs then save it
                cfg.write("## %s\n%s %s\n\n" % (option["help"], option["dest"], self.prefs[ option["dest"] ]))

        # now write whatever presets the user defined
        for presetName,presetItem in self.preferencesFrame.presetDict.iteritems():
            cfg.write("## Preset '%s'\npreset-%s %s\n\n" % (presetName, base64.b64encode( presetName ), base64.b64encode( cPickle.dumps( presetItem ))))

        cfg.close()

    # read CLI optparse opts into the self.prefs, if they were given
    def loadPrefsFromCli(self):
	import optparse
	usage = "%prog [options]"
	
        cliparser = optparse.OptionParser(usage=usage)
	
	for option in self.optionMap:
            cliparser.add_option(option['short'],option['long'],action=option['action'],dest=option['dest'],help=option['help'])
	
	(options, files) = cliparser.parse_args()
        
	for option in self.optionMap:
            value = getattr(options, option['dest'])
            if value:
                self.prefs[option['dest']] = value

        # handle the special debuglevel config option

        # map string values to error levels
        levelMap = {"CRITICAL": mythtv.CRITICAL,
                    "FATAL": mythtv.FATAL,
                    "ERROR": mythtv.ERROR,
                    "WARNING": mythtv.WARNING,
                    "INFO": mythtv.INFO,
                    "DEBUG": mythtv.DEBUG}
        
        # if they didnt supply a default log level, then set the default
        if options.debugLevel == None:
            options.debugLevel = defaultLogLevel

        if levelMap.has_key( options.debugLevel ):
            log.setLevel( levelMap[ options.debugLevel ] )
            log.Msg(INFO, "Changed debug level to %s" % options.debugLevel)
        
    def populatePrefsToChildren(self):
        self.preferencesFrame.setPreferences( self.prefs )
        self.encoderQueueFrame.setPreferences( self.prefs )


        
    def loadPrefsFromDisk(self):
        
        log.Msg(INFO, "Loading preferences from disk")

        # load the prefs from disk to self.prefs        
        self.prefs = self.readPrefsFromDisk()
        
        # if we did not load mysqlHost from disk, assume we should try and find the myth settings from the myth config files
        if not self.prefs.has_key("mysqlHost"):
            log.Msg(INFO, "mysqlHost not found in saved preferences; searching for your MythTV MySQL settings file.")

            mythSettings = self.findMythMysqlSettings()

            self.prefs.update( mythSettings )
            
        self.mainFrameStatusbar.PushStatusText('Preferences loaded.')
        
        
    def findMythMysqlSettings(self):
        # Try to read the mysql.txt file used by MythTV.
        # Order taken from libs/libmyth/mythcontext.cpp
        config_files = [
            '/usr/local/share/mythtv/mysql.txt',
            '/usr/share/mythtv/mysql.txt',
            '/usr/local/etc/mythtv/mysql.txt',
            '/etc/mythtv/mysql.txt',
            os.path.expanduser('~/.mythtv/mysql.txt'),
            ]
        
        if 'MYTHCONFDIR' in os.environ:
            config_locations.append('%s/mysql.txt' % os.environ['MYTHCONFDIR'])

        found_config = False
        for config_file in config_files:

            dbconn_host = None
            dbconn_name = None
            dbconn_user = None
            dbconn_pass = None
            dbconn_port = None

            if not os.access(config_file, os.R_OK): 
                continue

            for line in file(config_file):
                
                if line[0] != '#' and '=' in line:
                    equalPos = line.find('=')

                    key = line[0:equalPos]
                    val = line[equalPos+1:].strip()
                    
                    if key == "DBHostName":
                        dbconn_host = val
                    elif key == "DBPort":
                        dbconn_port = val
                    elif key == "DBName":
                        dbconn_name = val
                    elif key == "DBUserName":
                        dbconn_user = val
                    elif key == "DBPassword":
                        dbconn_pass = val

            if dbconn_host != None or dbconn_name != None or dbconn_user != None or dbconn_pass != None:
                log.Msg(INFO, "Using configuration file %s" % config_file)
                found_config = True
                break
        
        # we didn't find a config file, just bail out
        if not found_config:
            return {}
        
        
        return {"mysqlHost": dbconn_host,
                "mysqlPort": dbconn_port,
                "mysqlDB": dbconn_name,
                "mysqlUser": dbconn_user,
                "mysqlPassword": dbconn_pass}
    

    def showErrorDialog(self,title,message):
        errorDialog = wx.MessageDialog(parent=self, caption=title, message=message)
        errorDialog.ShowModal()

    def deleteRecordings(self,forget):
        progList = self.getSelectedPrograms()

        progCount = len(progList)

        if forget:
            actiontitle = "delete and re-record"
        else:
            actiontitle = "delete"

        reloadRecordings = False

        if progCount:

            if progCount == 1:
                message = "Really %s show '%s'?" % (actiontitle, progList[0])
            else:
                message = "Really %s %d shows?" % (actiontitle, progCount)

            wxmessage = wx.MessageDialog(parent=self, message=message, caption="MythRip - Confirm Delete", style=wx.YES_NO|wx.YES_DEFAULT|wx.ICON_QUESTION)
            
            if wxmessage.ShowModal() == wx.ID_YES:
                
                for program in progList:                    
                    self.mythTV.deleteRecording(program, forget)                                        
                
                reloadRecordings = True
                    
        if reloadRecordings:
            # reload the recording list
            self.loadRecordingsFromMyth()
        

    ###########################################################################
    # event handler land

        
    def onPrefsOK(self, event):

        # load the preferences from the prefs frame
        self.prefs = self.preferencesFrame.getPreferences()

        self.writePrefsToDisk()
        self.populatePrefsToChildren()

        self.mainFrameStatusbar.PushStatusText('Preferences saved.')

        event.Skip()


    def onPrefsCancel(self, event):
        
        # restore previous prefs settings if they cancel
        self.preferencesFrame.setPreferences( self.prefs )

        
    def onQuit(self, event): # wxGlade: mainFrame.<event_handler>
        
        runningThreads = []

        for threadID in self.encoderQueueFrame.threadOrder:            
            encoderThread = self.encoderQueueFrame.threads[ threadID ]            
            if encoderThread.state == "running":
                runningThreads.append(threadID)

        if len(runningThreads):            
            message = "%d thread(s) are running now.  Terminate them and quit?" % len(runningThreads)
            wxmessage = wx.MessageDialog(parent=self, message=message, caption="MythRip - Confirm Quit", style=wx.YES_NO|wx.YES_DEFAULT|wx.ICON_QUESTION)
            if wxmessage.ShowModal() == wx.ID_YES:
                self.encoderQueueFrame.abortThreadsAndQuit( runningThreads )

        else:

            sys.exit()


    def onColClick(self, event): # wxGlade: mainFrame.<event_handler>

        clickedCol = event.GetColumn()

        if (clickedCol == self.lastColClick):
            self.sortToggler *= -1
        else:
            self.sortToggler = 1

        self.lastColClick = clickedCol
        
        self.mainFrameListCtrl.SortItems( self.sortList ) 

        event.Skip()


    def onContextMenuSelection(self, event):        
        selectedMenuItem = self.contextMenuEntriesById[ event.GetId() ]
        if selectedMenuItem == "Encode":
            self.addRecordingsToQueue()
        event.Skip()
        
    def onQueue(self, event): # wxGlade: mainFrame.<event_handler>        
        self.encoderQueueFrame.Show()
        event.Skip()

    def onEncode(self, event): # wxGlade: mainFrame.<event_handler>
        self.addRecordingsToQueue()
        event.Skip()

    def onDelete(self, event): # wxGlade: mainFrame.<event_handler>        
        self.deleteRecordings(forget=False)
        event.Skip()

    def onDeleteRerecord(self, event): # wxGlade: mainFrame.<event_handler>
        self.deleteRecordings(forget=True)
        event.Skip()

    def onPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        self.preferencesFrame.Show()
        event.Skip()

    def onReload(self, event): # wxGlade: mainFrame.<event_handler>
        if not self.mythTV:
            self.connectToMyth()
            
        if self.mythTV:
            self.loadRecordingsFromMyth()
        else:
            self.mainFrameStatusbar.PushStatusText('No recordings loaded.')

        event.Skip()

    def onAbout(self, event): # wxGlade: mainFrame.<event_handler>
        self.aboutFrame.Show()
        event.Skip()


    def onView(self, event): # wxGlade: mainFrame.<event_handler>
        
        program = self.getSelectedPrograms()[0]
        
        filename = os.path.join(self.prefs['mythtvRecordingPath'], program.filename.split('/')[3:][0]) 

        failed = False
        
        if os.access(filename, os.R_OK):
            cmd = [ self.prefs['playerPath'], os.path.join(self.prefs['mythtvRecordingPath'], program.filename.split('/')[3:][0]) ]
            try:
                subprocess.call(cmd)
            except OSError, e:
                failed = True
                failMessage = "Failed spawning process:\n\n%s\n\n%s" % (" ".join(cmd), e)
        else:
            failed = True
            failMessage = "Could not access file:\n\n%s\n\nCheck 'MythTV Recording Path' in preferences" % filename

        if failed:
            wxmessage = wx.MessageDialog(parent=self, caption="MythRip - Playback Error", message=failMessage)
            wxmessage.ShowModal()

        event.Skip()

    def onItemRightClick(self, event): # wxGlade: mainFrame.<event_handler>
        # print "Event handler `onItemRightClick' not implemented"
        event.Skip()

# end of class mainFrame





class aboutFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: aboutFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.aboutFrameContents = wx.StaticText(self, -1, "About MythRIP:", style=wx.ALIGN_CENTRE)
        self.versionLabel = wx.StaticText(self, -1, "MythRip v0.0")
        self.static_line_4 = wx.StaticLine(self, -1)
        self.aboutFrameCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.aboutFrameCloseButton)
        # end wxGlade

        self.versionLabel.SetLabel(mythripVersionString)

    def __set_properties(self):
        # begin wxGlade: aboutFrame.__set_properties
        self.SetTitle("MythRip - About")
        self.SetSize((189, 109))
        self.aboutFrameCloseButton.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: aboutFrame.__do_layout
        aboutFrameSizer = wx.BoxSizer(wx.VERTICAL)
        aboutFrameSizer.Add(self.aboutFrameContents, 0, wx.BOTTOM|wx.EXPAND, 0)
        aboutFrameSizer.Add(self.versionLabel, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 11)
        aboutFrameSizer.Add(self.static_line_4, 0, wx.EXPAND, 0)
        aboutFrameSizer.Add(self.aboutFrameCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(aboutFrameSizer)
        self.Layout()
        # end wxGlade

    def onCloseButton(self, event): # wxGlade: aboutFrame.<event_handler>
        self.Hide()
        event.Skip()

# end of class aboutFrame



class encoderQueueFrame(wx.Frame):
    def __init__(self, *args, **kwds):

        toolbarDetails = wx.NewId()
        toolbarCleanup = wx.NewId()
        toolbarStop = wx.NewId()
        toolbarUp = wx.NewId()
        toolbarDown = wx.NewId()
        toolbarPrefs = wx.NewId()

        # begin wxGlade: encoderQueueFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Tool Bar
        self.encoderQueueFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.encoderQueueFrameToolbar)
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarDetails, "Details", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-page-setup.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "View details of selected thread(s)", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarStop, "Stop", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-cancel.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Stop selected thread(s)", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarUp, "Up", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-up.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected thread(s) up", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarDown, "Down", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-down.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected thread(s) down", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarCleanup, "Clean Up", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/edit-clear.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Remove all completed, failed and aborted threads", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarPrefs, "Preferences", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Show queue preferences", "")
        # Tool Bar end
        self.encoderQueueListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.SUNKEN_BORDER)
        self.encoderQueueCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_TOOL, self.onThreadDetail, id=toolbarDetails)
        self.Bind(wx.EVT_TOOL, self.onToolbarStop, id=toolbarStop)
        self.Bind(wx.EVT_TOOL, self.onToolbarUp, id=toolbarUp)
        self.Bind(wx.EVT_TOOL, self.onToolbarDown, id=toolbarDown)
        self.Bind(wx.EVT_TOOL, self.onToolbarCleanup, id=toolbarCleanup)
        self.Bind(wx.EVT_TOOL, self.onToolbarPrefs, id=toolbarPrefs)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.onItemRightClick, self.encoderQueueListCtrl)
        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.encoderQueueCloseButton)
        # end wxGlade
        
        ##########################
        
        # this variable tracks the thread IDs .. 
        # because I use this style of identifying threads eventually the ID would wrap.. so there's the app's max threads limit!
        self.nextThreadID = 0

        # this variable contains a list of encoder jobs, including their thread handles
        self.threads = {}

        # this tracks the order in which the threads appear in the listctrl
        self.threadOrder = []

        # this holds our app preferences
        self.prefs = {}

        # this is set when we are told to abort all jobs & quit.  if tick sees it, it checks that all threads are dead, then quit the app
        self.quitFlag = False

        # set up the listctrl
        self.encoderQueueListCtrl.InsertColumn(0, "Show")
        self.encoderQueueListCtrl.InsertColumn(1, "Episode")
        self.encoderQueueListCtrl.InsertColumn(2, "Air Time")
        self.encoderQueueListCtrl.InsertColumn(3, "Progress")
        
        # connect up a handler to update the GUI upon events from the encoder threads
        EVT_ENCODER(self, self.onEncoderEvent)    
                
        # start the updater timer
        self.genericTickingTimer = genericTickingTimer()
        self.genericTickingTimer.setFrameHandle(self)
        self.genericTickingTimer.Start(milliseconds=1000)

    def __set_properties(self):
        # begin wxGlade: encoderQueueFrame.__set_properties
        self.SetTitle("MythRip - Encoding Queue")
        self.SetSize((640, 300))
        self.encoderQueueFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderQueueFrame.__do_layout
        encoderQueueSizer = wx.BoxSizer(wx.VERTICAL)
        encoderQueueSizer.Add(self.encoderQueueListCtrl, 1, wx.EXPAND, 0)
        encoderQueueSizer.Add(self.encoderQueueCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(encoderQueueSizer)
        self.Layout()
        # end wxGlade

    ##########################################################################################
    # meat

    def addProgram(self,program):
        
        # grab the next thread id
        threadID = self.nextThreadID
        
        # prepare the thread id for the thread after this one
        self.nextThreadID += 1
        
        # create the thread.  
        self.threads[threadID] = encoderThread(program, threadID, self)
        self.threadOrder.append(threadID)
        
        self.onThreadPoolChange()

    def getSelectedThreads(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:
            threadID = self.threads[ self.encoderQueueListCtrl.GetItemData(item) ]                        
            returnList.append(threadID)
            item = self.encoderQueueListCtrl.GetNextSelected(item)
        
        return returnList


    def resizeEncoderQueueListCtrl(self):
        self.encoderQueueListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)

    def setPreferences(self, prefs):
        log.Msg(INFO, "Encoder queue frame received new preferences")
        self.prefs = prefs
        
    def reorderThreads(self, direction):

        # make a list of selected threads so we can restore it after we redraw the listctrl
        selThreads = []

        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:

            selThreadID = self.encoderQueueListCtrl.GetItemData(item)

            selThreads.append(selThreadID)
            
            # make a copy of threadOrder for us to mutilate
            newThreadOrder = self.threadOrder

            # loop through threadOrder indexes
            idx=0
            maxIdx = len(self.threadOrder)
            for idx in range(maxIdx):
                                
                if selThreadID == self.threadOrder[idx]:
                    
                    if direction == "up" and idx > 0:
                        # swap entries up
                        tmpThread = newThreadOrder[idx-1] 
                        newThreadOrder[idx-1] = newThreadOrder[idx]
                        newThreadOrder[idx] = tmpThread
                        break

                    elif direction == "down" and idx+1 < maxIdx:
                        # swap entries down
                        tmpThread = newThreadOrder[idx+1]
                        newThreadOrder[idx+1] = newThreadOrder[idx]
                        newThreadOrder[idx] = tmpThread
                        break

                idx += 1

            self.threadOrder = newThreadOrder

            item = self.encoderQueueListCtrl.GetNextSelected(item)

        # now that we are done re-ordering, redraw the threads
        self.onThreadPoolChange(selThreads)


    def abortThreadsAndQuit(self, abortThreads):
        
        for threadID in abortThreads:
            self.threads[ threadID ].setCommand( "abort" )
            
        self.quitFlag = True

    def removeCompletedItems(self):
        # lists to hold indexes to be deleted from self.threads & self.threadOrder
        nukeThreads = []

        for idx in range(len(self.threadOrder)):
            threadID = self.threadOrder[idx]

            if self.threads[threadID].state in ("aborted","completed","failed","failedAndAcknowledged"):
                
                nukeThreads.append(threadID)
        
        for threadID in nukeThreads:
        
            # we need to discover the idx anew for each thread, since the indexes are liable to change
            for idx in range(len(self.threadOrder)):
                if self.threadOrder[idx] == threadID:
                    del self.threadOrder[idx]
                    break

            # if we havent already nuked it, nuke it from self.threads too
            if self.threads.has_key(threadID):
                del self.threads[ threadID ]

        if len(nukeThreads) > 0:
            self.onThreadPoolChange()


    ##########################################################################################
    # event handlers

    # called by hand any time the threads list is added from, subtracted to, or re-ordered
    def onThreadPoolChange(self,selectedThreads = []):
        
        self.encoderQueueListCtrl.DeleteAllItems()

        for threadID in self.threadOrder:

            # for threadID, encoderThread in self.threads.iteritems():            
            newListIndex = self.encoderQueueListCtrl.GetItemCount()

            if self.threads.has_key(threadID):
                program = self.threads[threadID].program

                # insert the new list ctrl item
                self.encoderQueueListCtrl.InsertStringItem(newListIndex, program.title)
                self.encoderQueueListCtrl.SetStringItem(newListIndex, 1, program.subtitle)
                self.encoderQueueListCtrl.SetStringItem(newListIndex, 2, str(program.starttime))
                self.encoderQueueListCtrl.SetStringItem(newListIndex, 3, self.threads[threadID].lastListMessage)
                self.encoderQueueListCtrl.SetItemData(newListIndex, threadID) # store the thread id with each item

                # restore the user's selection
                if threadID in selectedThreads:
                    item = self.encoderQueueListCtrl.FindItemData(0, threadID)
                    self.encoderQueueListCtrl.SetItemState( item, state=wx.LIST_STATE_SELECTED, stateMask=wx.LIST_STATE_SELECTED)
            
        # keep the table clean with some column resizing
        self.resizeEncoderQueueListCtrl()


    # called from the genericTickingTimer
    def onTimerTick(self):
        
        # 0 is yes
        if self.prefs['removeCompleted'] == 0: 
            self.removeCompletedItems()
        
        # this is where the encoder queue determines when it needs to start more encoders
        while True:
        
            pendingThreads = []

            threadCount = len(self.threadOrder)

            runningThreads = 0

            for threadID in self.threadOrder:

                encoderThread = self.threads[threadID]

                # count how many threads are running now
                if encoderThread.state == "running":
                    runningThreads += 1  

                # make a list of threads that are waiting to start
                elif encoderThread.state == "new":
                    pendingThreads.append( encoderThread )

                elif encoderThread.state == "failed":
                    encoderThread.state = "failedAndAcknowledged"
                    frame = threadDetailFrame(parent=self)
                    frame.setThreadID( threadID )
                    frame.Show()
                    
                
            # if self.quitFlag is set, we are to terminate once no threads are left running
            if runningThreads == 0 and self.quitFlag:
                sys.exit()

            # if there are less threads running than the threadCount, then start some until thats no longer true    
            if runningThreads < self.prefs['threadCount'] and len(pendingThreads):
                pendingThreads[0].start()
                time.sleep(0.1) # sleep long enough for the thread to start and get its 'state' variable set to 'running' so we dont try to run it twice
            else:
                # the only way out of the while True is for there to be no more threads that need starting
                break
                    

    # when an encoder event is received this is called
    def onEncoderEvent(self, event):
        
        # we pretty much need this no matter what
        listCtrlIndex = self.encoderQueueListCtrl.FindItemData(0,event.threadID)        
        self.encoderQueueListCtrl.SetStringItem(listCtrlIndex, 3, event.listMessage)
        self.resizeEncoderQueueListCtrl()
            
        event.Skip()

    def onCloseButton(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.Hide()
        event.Skip()

    def onToolbarUp(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.reorderThreads("up")
        event.Skip()

    def onToolbarDown(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.reorderThreads("down")
        event.Skip()

    def onToolbarCleanup(self, event): # wxGlade: encoderQueueFrame.<event_handler>        
        self.removeCompletedItems()
        event.Skip()

    def onToolbarPrefs(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.GetParent().preferencesFrame.Show()
        self.GetParent().preferencesFrame.preferencesNotebook.ChangeSelection(2)
        event.Skip()

    def onToolbarStop(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        item = self.encoderQueueListCtrl.GetFirstSelected()

        while item != -1:
            threadID = self.encoderQueueListCtrl.GetItemData(item)
            
            # abort it
            self.threads[ threadID ].setCommand("abort")

            # run the thread if it wasn't running .. this way it can receive the abort flag!
            if self.threads[ threadID ].state != "running":
                self.threads[ threadID ].start()

            item = self.encoderQueueListCtrl.GetNextSelected(item)

        event.Skip()




    def onItemRightClick(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onItemRightClick' not implemented"
        event.Skip()

    def onThreadDetail(self, event): # wxGlade: encoderQueueFrame.<event_handler>

        for thread in self.getSelectedThreads():
            frame = threadDetailFrame(parent=self)
            frame.setThreadID( thread.threadID )
            frame.Show()
        
        event.Skip()

# end of class encoderQueueFrame

###################################################################
# encoder thread land

# get an ID for an "encoder" event 
EVT_ENCODER_ID = wx.NewId()

# define a macro for connecting event handlers to the encoder events
def EVT_ENCODER(theWin, theFunc):
    theWin.Connect(-1, -1, EVT_ENCODER_ID, theFunc)

# a simple event to throw out of the encoder
class encoderEvent(wx.PyEvent):
    def __init__(self, threadID, threadState, listMessage):
        wx.PyEvent.__init__(self)
        self.SetEventType(EVT_ENCODER_ID)
        self.threadID = threadID
        self.threadState = threadState
        self.listMessage = listMessage

# the encoder thread itself
class encoderThread(threading.Thread):
    
    def __init__(self, program, threadID, notifyWindow):
        
        self.notifyWindow = notifyWindow
        self.program = program
        self.threadID = threadID
        self.doCommand = "none"
        
        self.maintainState(setState="new")
        
        self.lastListMessage = "Waiting"

        # False indicates the process was never started
        self.mencoderProcess = False
        self.mythtranscodeProcess = False

        # no errors have occurred.. yet..
        self.mencoderProcessError = False
        self.mythtranscodeProcessError = False
        
        # this is for scraping video parameters out of mythtranscode output
        self.mythtranscodeStdout = ""

        self.mythtranscodeFifoDir = ""

        self.lastMythtranscodeStderr = ""
        self.lastMencoderStderr = ""
        
        # source video/audio properties
        self.vidWidth = ""
        self.vidHeight = ""
        self.vidFramerate = ""
        self.audioRate = ""
        self.audioChannels = ""

        self.currentPass = 0
        self.currentFrame = 0
        self.currentFPS = 0
        self.maxFrame = 0
        
        # make a copy of the preferences at the time the thread was created to avoid them changing mid-stream if the user
        # alters preferences during a thread's execution
        self.prefs = self.notifyWindow.prefs 

        # boolean describing if two-pass is enabled ; 0 is yes
        self.twoPass = (self.prefs["twoPassVideo"] == 0)

        self.mencoderCmd = {}

        self.mythtranscodeCmd = False

        # initialize the passlog dir 
        self.clearPasslogDir()

        # load parent constructor
        threading.Thread.__init__(self)
    
        
    def run(self):

        if not self.maintainState("running"):
            return
        
        self.startMythtranscode()

        # now we need to examine the mythtranscode output to determine the video and audio parameters .. 
        # we wait up to 10 seconds for them to show up in self.mythtranscodeStdout
        for i in range(10): 

            # mythtranscode isnt even running.. just bail
            if self.mythtranscodeProcessError == True or self.mythtranscodeProcess.poll() != None:
                log.Msg(WARNING, "Thread %d: mythtranscode launch failure precludes gathering of AV parameters from mythtranscode output; thread will fail" % self.threadID)
                break

            self.parseSubprocessOutput(mtGathering = True)
            # print self.mythtranscodeStdout,"\n-----------------------------------------"
            if re.search(".*Stream.*Audio.*kb/s", self.mythtranscodeStdout):
                log.Msg(INFO, "Thread %d: Found file AV parameters! Beginning extraction from mythtranscode output" % self.threadID)
                (self.vidWidth, self.vidHeight, self.vidFramerate) = re.findall('.*Stream #.* ([0-9]+)x([0-9]+).* ([0-9]+\.[0-9]+) tb',self.mythtranscodeStdout)[0]
                (self.audioRate, audioChanMode) = re.findall('.*Stream #.* ([0-9]+) Hz, ([A-Za-z]+)',self.mythtranscodeStdout)[0]
                if audioChanMode == "stereo":
                    self.audioChannels = "2"
                else:
                    # TODO im not sure what other values are produced in this slot
                    self.audioChannels = "1"
                break

            time.sleep(1)

        
        if self.twoPass:
            mencCount = 2
        else:
            mencCount = 1


        # loop as many times as we are supposed to start mencoder
        # - zip through the upcoming passes and generate the mencoderCmds in advance
        for i in range(mencCount):
            self.currentPass = i+1
            self.mencoderCmd[self.currentPass] = self.buildMencoderCmd()

        # loop as many times as we are supposed to start mencoder
        for i in range(mencCount):

            self.currentPass = i+1

            log.Msg(INFO, "Thread %d: Entering pass %d with doCommand %s, state %s" % ( self.threadID, self.currentPass, self.doCommand, self.state))

            # if maintainstate says we are to die, then we skip
            if not self.maintainState():
                log.Msg(WARNING, "Thread %d: Thread is aborted or failed, pass %d skipped" % (self.threadID, self.currentPass))
                break

            # if this isnt the first loop, we can't count on mythtranscode being started!  we need to start a new one for subsequent passes
            if self.currentPass != 1:
                self.startMythtranscode()

            # if mythtranscode failed outright, just report the error and escape the encoding loop
            if self.mythtranscodeProcessError:
                self.reportSubprocessFailure( self.prefs['mythtranscodePath'], self.lastMythtranscodeStderr )
                log.Msg(WARNING, "Thread %d: Thread failed, pass %d skipped" % (self.threadID, self.currentPass))
                break

            self.stdoutSockMenc, stdoutChildSockMenc = socket.socketpair() 
            self.stderrSockMenc, stderrChildSockMenc = socket.socketpair() 
            self.stdoutSockMenc.settimeout(0.1)
            self.stderrSockMenc.settimeout(0.1)

            self.mencoderProcessError = False
            try:
                self.mencoderProcess = subprocess.Popen(self.mencoderCmd[self.currentPass], stdin=None, stdout=stdoutChildSockMenc.fileno(), stderr=stderrChildSockMenc.fileno())
            except OSError, e:

                # if this fails it will be detected and reported on elsewhere
                self.lastMencoderStderr = "Failed spawning process: %s" % e
                self.mencoderProcessError = True
                pass
                

            self.setRunningStatus( "Encoder started." )
            
            # these need to be initialized for the loop below
            self.mythtranscodeRunning = True
            self.mencoderRunning = True
        
            stopRunning = False
            while not stopRunning:

                self.parseSubprocessOutput()
                
                errorSent = False

                # if a process *was* running, but is not running now, we should decide if its an error and report back to the user
                if self.mythtranscodeRunning:
                    
                    self.updateProcessRunningFlags("mythtranscode")

                    if ( not self.mythtranscodeRunning ) and ( self.mythtranscodeProcessError or self.mythtranscodeProcess.returncode != 0 ):
                        self.reportSubprocessFailure( self.prefs['mythtranscodePath'], self.lastMythtranscodeStderr )
                        errorSent = True
                
                if self.mencoderRunning:

                    self.updateProcessRunningFlags("mencoder")
                    
                    if ( not self.mencoderRunning ) and ( self.mencoderProcessError or self.mencoderProcess.returncode != 0 ):
                        if not errorSent: # dont send another error report about mencoder if mythtranscode already failed
                            self.reportSubprocessFailure( self.prefs['mencoderPath'], self.lastMencoderStderr )
                        
                # end the pass if mythtranscode and mencoder are not both running, or if we've been told to abort
                endPass = (not ( self.mythtranscodeRunning and self.mencoderRunning ) ) or not self.maintainState()

                if endPass:

                    self.setRunningStatus( "Waiting for all subprocesses to end" )
                    
                    # wait 5 seconds for things to normalize
                    for sec in range(15):
                            
                        # if mythtranscodeProcessError is False and poll() returns None, the process is alive
                        self.updateProcessRunningFlags()
                        
                        if not self.mythtranscodeRunning and not self.mencoderRunning:
                            log.Msg(INFO, "Thread %d: All subprocess dead, terminating thread execution" % self.threadID)                            
                            stopRunning = True
                            break

                        if sec > 1:

                            # read again
                            self.updateProcessRunningFlags()

                            self.setRunningStatus( "Actively stopping subprocesses" )
                            
                            log.Msg(INFO, "Thread %d: Aggressive mode running at second %d" % (self.threadID, sec))

                            if sec > 7:
                                usesig = signal.SIGKILL
                                usesigname = "SIGKILL"
                            else:
                                usesig = signal.SIGTERM
                                usesigname = "SIGTERM"

                            if self.mythtranscodeRunning:
                                log.Msg(INFO, "Thread %d: Aggressive mode: mencoder died but mythtranscode continues to run, sending %s to mythtranscode." % (self.threadID, usesigname))
                                os.kill(self.mythtranscodeProcess.pid, usesig)

                            if self.mencoderRunning:
                                log.Msg(INFO, "Thread %d: Aggressive mode: mythtranscode died but mencoder continues to run, sending %s to mencoder." % (self.threadID, usesigname))
                                os.kill(self.mencoderProcess.pid, usesig)


                        # wait a second.. both processes should be disolving more or less simultaneously
                        time.sleep(1);

                    # parse subprocess output one last time
                    self.parseSubprocessOutput()
                
                # wait a second before checking the subprocess again
                time.sleep(0.1)

        # for this final call to maintainstate, we need to determine if we were aborted, and if so tell maintainState so
        if self.state == "aborted":
            self.maintainState("aborted")
        else:
            self.maintainState("completed")

        self.cleanupAndDie()


    # this func maintains the state of the thread.. 
    # it returns a boolean indicating if the thread should continue running
    def maintainState(self,setState = False):

        # allow setting the state
        if setState:
            self.state = setState

        # parse getCommand - always overrides setState
        if self.getCommand() == "abort":
            self.state = "aborted"
            

        # send appropriate encoder events for our state if applicable
        if self.state == "aborted":
            self.sendEncoderEvent( "stopped", "Aborted" )
            return False

        elif self.state in ("failed","failedAndAcknowledged"):
            self.sendEncoderEvent( "stopped", "Failed (see thread detail window)" )        
            return False

        elif self.state == "completed":
            self.sendEncoderEvent( "stopped", "Completed" )
            return False

        else:
            return True

            
    def updateProcessRunningFlags(self,which="both"):
        if which in ("both","mythtranscode"):
            self.mythtranscodeRunning = ( self.mythtranscodeProcessError == False and self.mythtranscodeProcess.poll() == None )

        if which in ("both","mencoder"):
            self.mencoderRunning = ( self.mencoderProcessError == False and self.mencoderProcess.poll() == None )

    def reportSubprocessFailure(self, processName, failureDetails):
        if self.state == "failedAndAcknowledged":
            return

        # set the message first so parent threads dont get a failed state when theres no message set
        self.failedMessage = "%s returned a failure code in pass %d\n\nDetails:\n%s" % (processName, self.currentPass, failureDetails)
        self.state = "failed"

        log.Msg(WARNING, "Thread %d: Subprocess failure: %s" % (self.threadID, self.failedMessage))

    def clearPasslogDir(self, renewMode=True):
        log.Msg(INFO, "Thread %d: Clearing passlog directory" % self.threadID)

        # get directory for our fifos to live in
        self.passlogDir = '/tmp/mythrip-%d-passlog' % self.threadID
        
        if os.path.isdir(self.passlogDir):
            try:
                shutil.rmtree(self.passlogDir)
            except Exception, e:
                msg = "Could not remove stale passlog directory: %s" % e
                
                log.Msg(WARNING, "Thread ID %d: %s" % (self.threadID, msg))

                self.maintainState(setState="failed")

        if renewMode:
            try:
                os.mkdir(self.passlogDir)
            except Exception, e:

                log.Msg(WARNING, "Failed creating passlog directory: %s" % e)

                self.maintainState(setState="failed")

        
    def clearFifoDir(self, renewMode=True):

        log.Msg(INFO, "Thread %d: Clearing FIFO directory" % self.threadID)

        # get directory for our fifos to live in
        self.mythtranscodeFifoDir = '/tmp/mythrip-%d-fifo' % self.threadID

        # we'll try killing that fifo dir 10 times.
        for sec in range(10):
            
            if os.path.isdir(self.mythtranscodeFifoDir):
                try:
                    shutil.rmtree(self.mythtranscodeFifoDir)
                except Exception, e:
                    msg = "Could not remove stale fifo directory: %s" % e

                    log.Msg(WARNING, "Thread ID %d: %s" % (self.threadID, msg))

                    self.maintainState(setState="failed")

            else:
                break

            time.sleep(1)

        if renewMode:
            try:
                os.mkdir(self.mythtranscodeFifoDir)
            except Exception, e:
                log.Msg(WARNING, "Failed creating fifo directories: %s" % e)
                self.maintainState(setState="failed")

    def parseSubprocessOutput(self,mtGathering = False):
        
        streamDict = {"mt": [self.stdoutSockMT, self.stderrSockMT]}
        
        # if we are in mtGathering mode, we ignore menc
        if not mtGathering:
            streamDict["menc"] = [self.stdoutSockMenc, self.stderrSockMenc]
        
        # read from all processes
        for (name, (stdoutSock,stderrSock)) in streamDict.iteritems():
            newstdout = ""
            newstderr = ""
            
            try:
                newstdout = stdoutSock.recv(1024)
                newstderr = stderrSock.recv(1024)

            except socket.timeout, e:
                pass 

            # print em out if there was anything
            if len(newstdout):
                # if this is mythtranscode, we need to gather up all the output so we may parse out video and audio parameters
                if mtGathering:
                    self.mythtranscodeStdout += newstdout
                    
                # parse mencoder output for the queue listctrl
                if name == "menc":
                    # Pos:   6.1s    192f ( 0%) 35.13fps Trem:   0min   0mb  A-V:0.033 [715:1536]
                    match = re.findall('Pos\: +([0-9\.]+)s +([0-9]+)f \(([0-9 ]+%)\) +([0-9\.]+)fps',newstdout) # pull mencoder output
                    if match:
                        self.currentFrame = int(match[0][1])
                        self.currentFPS = float(match[0][3])

                # because we just receive data periodically we might be getting only pieces of full output lines.. but this is just a progress indicator, its good enough
                if name == "mt":
                    match = re.findall('.*Processed: [0-9]+ of ([0-9]+) frames',newstdout)
                    if match:
                        self.maxFrame = int(match[0])

                
                if self.currentFrame and self.maxFrame:
                    perc = self.currentFrame / float(self.maxFrame) * 100 

                    self.setRunningStatus("%d%% : Frame %d / %d : %0.02f fps" % (int(perc), self.currentFrame, self.maxFrame, self.currentFPS ) )

                elif self.currentFrame:
                    
                    self.setRunningStatus("0%% : Frame %d / ????: %0.02f fps" % (self.currentFrame, self.currentFPS) )

                self.lastStdout = newstdout
                                               
                # print "STDOUT %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstdout)
                    
            if len(newstderr):
                
                if name == 'menc':
                    self.lastMencoderStderr = newstderr
                else:
                    self.lastMythtranscodeStderr = newstderr
                    

                # print "STDERR %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstderr)
                pass


    def buildMencoderCmd(self):
                
        # now fire up mencoder reading from mythtranscode's fifo
        mencoderCmd = [self.prefs['mencoderPath'],
                       '-noskip','-idx',
                       os.path.join(self.mythtranscodeFifoDir, 'vidout'),
                       '-audiofile', os.path.join(self.mythtranscodeFifoDir,'audout'),
                       '-demuxer','20','-audio-demuxer','20',
                       '-rawvideo','w=%s:h=%s:fps=%s' % (self.vidWidth, self.vidHeight, self.vidFramerate),
                       '-rawaudio','rate=%s:channels=%s' % (self.audioRate, self.audioChannels),
                       '-demuxer','26']
        
        ### misc
        if len(self.prefs['extraFlags']):
            mencoderCmd.extend(self.prefs['extraFlags'].split(" "))

        
        ### Audio
        
        # dont process sound on first pass of a two-pass encode
        if self.twoPass and self.currentPass == 1:

            mencoderCmd.extend( ['-oac','copy'] )

        else:

            # load the info for the selected codec
            useAudioCodec = audioCodecDict[ int(self.prefs['audioCodec']) ]

            mencoderCmd.extend( ['-oac', useAudioCodec[0]] )

            if useAudioCodec[1] and self.prefs['audioCodecOptions']:
                mencoderCmd.extend( [useAudioCodec[2], self.prefs['audioCodecOptions']] )

            if len(self.prefs['audioFilter']):
                mencoderCmd.extend( ['-af',self.prefs['audioFilter']] )
            
        ### Video

        # load this pass' options
        if self.twoPass:

            if self.currentPass == 1:
                encOpts = self.prefs['videoFirstPassOpts']+':pass=1'
            else:
                encOpts = self.prefs['videoSecondPassOpts']+':pass=2'

        else:

            if self.currentPass == 1:
                encOpts = self.prefs['videoFirstPassOpts']
            else:
                encOpts = self.prefs['videoSecondPassOpts']
                   
        useVideoCodec = videoCodecDict[ self.prefs['videoCodec'] ]

        mencoderCmd.extend( ['-ovc', useVideoCodec[0] ] )
        
        if useVideoCodec[1]:
            mencoderCmd.extend( [useVideoCodec[2], encOpts] )
                
        if len(self.prefs['videoFilter']):            
            mencoderCmd.extend( ['-vf',self.prefs['videoFilter']] )


        if self.twoPass:

            if self.currentPass == 1:
                mencoderCmd.extend( ['-o', '/dev/null'] )
            else:
                self.makeOutputFilename()
                mencoderCmd.extend( ['-o', self.outputFile] )

            # in two pass mode, always pass the logfile arg
            mencoderCmd.extend( ['-passlogfile', os.path.join( self.passlogDir, 'pass.log' ) ] )
        else:
            outputFile = self.makeOutputFilename()
            mencoderCmd.extend( ['-o', self.outputFile] )
            
        return mencoderCmd
    
    def startMythtranscode(self):
        
        # dont even try if we are to terminate
        if not self.maintainState():
            return

        self.setRunningStatus( "Waiting for mythtranscode fifos" )
        self.clearFifoDir()

        # fire up mythtranscode turbo=1:subq=1:frameref=1
        self.mythtranscodeCmd = [self.prefs['mythtranscodePath'],
                            '--showprogress',
                            '-p','autodetect',
                            '-c',str(self.program.chanid),
                            '-s',self.program.recstartts.strftime('%Y-%m-%dT%H:%M:%S'),
                            '-f',self.mythtranscodeFifoDir,
                            '--verbose','libav' # we pull video parameters out of this verbose output mode
                            ]
        
        if self.prefs["useMythCutlist"] == 0:
            self.mythtranscodeCmd.append('--honorcutlist')
        
        # use sockets for the subprocess file objects so we can read from stdout/stderr in a non-blocking fashion
        self.stdoutSockMT, stdoutChildSockMT = socket.socketpair() 
        self.stderrSockMT, stderrChildSockMT = socket.socketpair() 
        self.stdoutSockMT.settimeout(0.1)
        self.stderrSockMT.settimeout(0.1)

        log.Msg(INFO, "Thread %d: Starting mythtranscode" % self.threadID)

        self.mythtranscodeProcessError = False
        try:
            self.mythtranscodeProcess = subprocess.Popen(self.mythtranscodeCmd, stdin=None, stdout=stdoutChildSockMT.fileno(), stderr=stderrChildSockMT.fileno())
        except OSError, e:
            # if this fails it will be detected and reported on elsewhere
            self.lastMythtranscodeStderr = "Failed spawning process: %s" % e
            self.mythtranscodeProcessError = True

            # dont bother with the fifo dir if the command failed
            return

        # 5 second loop
        for i in range(10):

            # mythtranscode isnt even running.. just bail
            if self.mythtranscodeProcess.poll() != None:
                log.Msg(WARNING, "Thread %d: mythtranscode quit running during FIFO directory scan" % self.threadID)
                break

            fifoPresent = self.isFifo( os.path.join(self.mythtranscodeFifoDir,'vidout') )
            if fifoPresent:
                log.Msg(INFO, "Thread %d: FIFO directory has appeared, mythtranscode start-up successful" % self.threadID)
                break

            time.sleep(1)


    # when called this func spits out the full path & filename for the new file..?
    def makeOutputFilename(self, iteration=0):

        templateMap = { '%s': "title",
                        '%e': "subtitle",
                        '%d': "description",
                        '%c': "category",
                        '%C': "channum",
                        '%T': "starttime",
                        '%E': "endtime",
                        '%i': "seriesid",
                        '%h': "hostname" }
        
        template = self.prefs["fileTemplate"]

        for (code, name) in templateMap.iteritems():

            value = getattr(self.program, name)
            
            template = template.replace(code, str(value))
            
        extension = 'avi'

        if iteration > 0:
            filename = '%s - Copy %d.%s' % (template, iteration, extension)
        else:
            filename = '%s.%s' % (template, extension)
            
        retrFile = os.path.join( self.prefs['savePath'], filename )

        if os.path.isfile(retrFile):
            return self.makeOutputFilename( iteration=(iteration+1) )
        else:
            log.Msg(INFO, "Thread %d: Output filename determined to be %s" % (self.threadID, retrFile))
            self.outputFile = retrFile

    # func called to update the encoder queue frame listctrl item
    def setRunningStatus(self,status):

        if self.currentPass > 0 and self.prefs["twoPassVideo"] == 0: # 0 is yes
            sendStat = "Pass %d : %s" % (self.currentPass, status)
        else:
            sendStat = status

        self.sendEncoderEvent( "running", sendStat )
        

    # func called by the main thread in order to issue commands
    def setCommand(self,command):
        self.doCommand = command

    # called by the thread to get commands.  upon getting them, they are reset to none
    def getCommand(self):        
        ret = self.doCommand
        self.doCommand = "none"
        return ret

    def sendEncoderEvent(self, threadState, listMessage):
        self.lastListMessage = listMessage
        wx.PostEvent(self.notifyWindow, encoderEvent(self.threadID, threadState, listMessage))
        
    def isFifo(self,fn):
        return os.access(fn,os.R_OK) and stat.S_ISFIFO(os.stat(fn).st_mode)

    def cleanupAndDie(self):
        self.clearFifoDir(renewMode=False) # clear fifo dir and don't regenerate it!
        self.clearPasslogDir(renewMode=False)
    
# a very simple timer to call a tick function in the encoder queue fraem
class genericTickingTimer(wx.Timer):
    
    def setFrameHandle(self,targetFrame):
        self.targetFrame = targetFrame

    def Notify(self):
        self.targetFrame.onTimerTick()

###########################################################################
    

class preferencesFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: preferencesFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.preferencesNotebook = wx.Notebook(self, -1, style=0)
        self.preferencesExternalProgramsPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesFilesPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesQueuePane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesEncodersPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesMythTVPane = wx.Panel(self.preferencesNotebook, -1)
        self.mysqlSettingsLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Settings: ")
        self.mysqlHostLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Hostname: ")
        self.mysqlHostText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlPortLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Port: ")
        self.mysqlPortText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlUserLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL User: ")
        self.mysqlUserText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlPasswordLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Password: ")
        self.mysqlPasswordText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlDBNameLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Database Name: ")
        self.mysqlDBNameText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mythOptionsLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MythTV Options: ")
        self.useMythCutlistLabel = wx.StaticText(self.preferencesMythTVPane, -1, "Use Myth Cutlists: ")
        self.useMythCutlistChoice = wx.Choice(self.preferencesMythTVPane, -1, choices=["Yes", "No"])
        self.mythtvRecordingPath = wx.StaticText(self.preferencesMythTVPane, -1, "MythTV Recording Path: ")
        self.mythtvRecordingText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mythtvRecordingPathNoteLabel = wx.StaticText(self.preferencesMythTVPane, -1, "(Required for \"View\" function only)")
        self.presetLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Presets:")
        self.loadSavePresetLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Load / Save Preset: ")
        self.presetCombo = wx.ComboBox(self.preferencesEncodersPane, -1, choices=[], style=wx.CB_DROPDOWN|wx.CB_DROPDOWN|wx.CB_SORT)
        self.presetSaveButton = wx.Button(self.preferencesEncodersPane, -1, "Save")
        self.FileOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Global Options:")
        self.containerFormatLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Container Format: ")
        self.containerFormatChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["avi", "mkv"])
        self.extraFlagsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Extra mencoder Flags: ")
        self.extraFlagsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.videoOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Options: ")
        self.videoCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Codec: ")
        self.videoCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["copy", "xvid", "x264", "lavc"])
        self.twoPassVideoLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Two-Pass Video: ")
        self.twoPassVideoChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["Yes", "No"])
        self.videoFirstPassOptsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "First Pass Options: ")
        self.videoFirstPassOptsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.videoSecondPassOptsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Second Pass Options: ")
        self.videoSecondPassOptsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.videoFilterStringLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Filter String (-vf): ")
        self.videoFilterStringText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.audioOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Options:")
        self.audioCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec: ")
        self.audioCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["copy", "pcm", "mp3lame", "lavc"])
        self.audioCodecOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec Options:")
        self.audioCodecOptionsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.audioFilterLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Filter String (-af): ")
        self.audioFilterText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.threadCountLabel = wx.StaticText(self.preferencesQueuePane, -1, "Max Simultaneous Jobs: ")
        self.threadCountSpin = wx.SpinCtrl(self.preferencesQueuePane, -1, "", min=0, max=100)
        self.removeCompletedLabel = wx.StaticText(self.preferencesQueuePane, -1, "Remove Completed Jobs: ")
        self.removeCompletedChoice = wx.Choice(self.preferencesQueuePane, -1, choices=["Yes", "No"])
        self.savePathLabel = wx.StaticText(self.preferencesFilesPane, -1, "Save Encoded Videos In: ")
        self.videoOutputPathText = wx.TextCtrl(self.preferencesFilesPane, -1, "")
        self.videoOutputPathButton = wx.Button(self.preferencesFilesPane, -1, "Browse...")
        self.fileTemplateLabel = wx.StaticText(self.preferencesFilesPane, -1, "File Naming Template: ")
        self.fileTemplateText = wx.TextCtrl(self.preferencesFilesPane, -1, "")
        self.fileTemplateHelpLabel = wx.StaticText(self.preferencesFilesPane, -1, "%s: Title\n%e: Subtitle\n%d: Description\n%c: Category\n%C: Channel number\n%T: Start time\n%E: End time\n%i: Series ID\n%h: Hostname")
        self.mencoderPathLabel = wx.StaticText(self.preferencesExternalProgramsPane, -1, "Path to mencoder: ")
        self.mencoderPathText = wx.TextCtrl(self.preferencesExternalProgramsPane, -1, "")
        self.playerPathLabel = wx.StaticText(self.preferencesExternalProgramsPane, -1, "Path to video player: ")
        self.playerPathText = wx.TextCtrl(self.preferencesExternalProgramsPane, -1, "")
        self.mythtranscodePathLabel = wx.StaticText(self.preferencesExternalProgramsPane, -1, "Path to mythtranscode: ")
        self.mythtranscodePathText = wx.TextCtrl(self.preferencesExternalProgramsPane, -1, "")
        self.preferencesCancelButton = wx.Button(self, wx.ID_CANCEL, "")
        self.preferencesOKButton = wx.Button(self, wx.ID_OK, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_COMBOBOX, self.onLoadPresetComboEvent, self.presetCombo)
        self.Bind(wx.EVT_BUTTON, self.onPresetSave, self.presetSaveButton)
        self.Bind(wx.EVT_CHOICE, self.onVideoCodecChange, self.videoCodecChoice)
        self.Bind(wx.EVT_CHOICE, self.onAudioCodecChange, self.audioCodecChoice)
        self.Bind(wx.EVT_BUTTON, self.onVideoOutputPathButton, self.videoOutputPathButton)
        self.Bind(wx.EVT_BUTTON, self.onCancelButton, self.preferencesCancelButton)
        self.Bind(wx.EVT_BUTTON, self.onOKButton, self.preferencesOKButton)
        # end wxGlade
        
        # a map of which 'prefs' keys map to which controls in the preferences dialog, and the control type
        # we use this for getting/setting values in the preferences dialog

        self.prefMap = {'mysqlHost': ['TextCtrl', self.mysqlHostText],
                        'mysqlPort': ['TextCtrl', self.mysqlPortText],
                        'mysqlUser': ['TextCtrl', self.mysqlUserText],
                        'mysqlPassword': ['TextCtrl', self.mysqlPasswordText],
                        'mysqlDB': ['TextCtrl', self.mysqlDBNameText],
                        'useMythCutlist': ['Choice', self.useMythCutlistChoice],
                        'mythtvRecordingPath': ['TextCtrl', self.mythtvRecordingText],
                        'containerFormat': ['Choice', self.containerFormatChoice],
                        'extraFlags': ['TextCtrl', self.extraFlagsText],
                        'videoCodec': ['Choice', self.videoCodecChoice],
                        'videoFirstPassOpts': ['TextCtrl', self.videoFirstPassOptsText],
                        'videoSecondPassOpts': ['TextCtrl', self.videoSecondPassOptsText],
                        'videoFilter': ['TextCtrl', self.videoFilterStringText],
                        'twoPassVideo': ['Choice', self.twoPassVideoChoice],
                        'audioCodec': ['Choice', self.audioCodecChoice],
                        'audioCodecOptions': ['TextCtrl', self.audioCodecOptionsText],
                        'audioFilter': ['TextCtrl', self.audioFilterText],
                        'threadCount': ['Spin', self.threadCountSpin],
                        'removeCompleted': ['Choice', self.removeCompletedChoice],
                        'savePath': ['TextCtrl', self.videoOutputPathText],
                        'fileTemplate': ['TextCtrl', self.fileTemplateText],
                        'mencoderPath': ['TextCtrl', self.mencoderPathText],
                        'playerPath': ['TextCtrl', self.playerPathText],
                        'mythtranscodePath': ['TextCtrl', self.mythtranscodePathText],

                        }

        self.presetDict = {}
        
        # these are all the prefMap keys we handle in presets
        self.presetItems = ('containerFormat','extraFlags','videoCodec','videoFirstPassOpts','videoSecondPassOpts','videoFilter','twoPassVideo','audioCodec','audioCodecOptions','audioFilter')

        self.populatePresetCombo()

    def __set_properties(self):
        # begin wxGlade: preferencesFrame.__set_properties
        self.SetTitle("MythRip - Preferences")
        self.SetSize((542, 535))
        self.useMythCutlistChoice.SetSelection(0)
        self.mythtvRecordingPathNoteLabel.SetFont(wx.Font(10, wx.DEFAULT, wx.ITALIC, wx.NORMAL, 0, ""))
        self.containerFormatChoice.SetSelection(0)
        self.videoCodecChoice.SetSelection(0)
        self.twoPassVideoChoice.SetSelection(0)
        self.audioCodecChoice.SetSelection(0)
        self.removeCompletedChoice.SetSelection(0)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: preferencesFrame.__do_layout
        preferencesSizer = wx.BoxSizer(wx.VERTICAL)
        preferencesButtonSizer = wx.BoxSizer(wx.HORIZONTAL)
        externalProgramsSizer = wx.FlexGridSizer(4, 2, 0, 0)
        preferencesFilesSizer = wx.FlexGridSizer(4, 2, 0, 0)
        preferencesQueueSIzer = wx.FlexGridSizer(2, 2, 0, 0)
        preferencesEncodersSizer = wx.FlexGridSizer(11, 2, 0, 0)
        presetLoadSaveSizer = wx.BoxSizer(wx.HORIZONTAL)
        preferencesMythTVSizer = wx.FlexGridSizer(10, 2, 0, 0)
        preferencesMythTVSizer.Add(self.mysqlSettingsLabel, 0, 0, 0)
        preferencesMythTVSizer.Add((20, 20), 0, 0, 0)
        preferencesMythTVSizer.Add(self.mysqlHostLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlHostText, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPortLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPortText, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlUserLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlUserText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mysqlPasswordLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPasswordText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mysqlDBNameLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlDBNameText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mythOptionsLabel, 0, wx.TOP, 10)
        preferencesMythTVSizer.Add((20, 20), 0, 0, 0)
        preferencesMythTVSizer.Add(self.useMythCutlistLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.useMythCutlistChoice, 0, 0, 0)
        preferencesMythTVSizer.Add(self.mythtvRecordingPath, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mythtvRecordingText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add((20, 10), 0, 0, 0)
        preferencesMythTVSizer.Add(self.mythtvRecordingPathNoteLabel, 0, 0, 0)
        self.preferencesMythTVPane.SetSizer(preferencesMythTVSizer)
        preferencesMythTVSizer.AddGrowableCol(1)
        preferencesEncodersSizer.Add(self.presetLabel, 0, 0, 0)
        preferencesEncodersSizer.Add((10, 10), 0, 0, 0)
        preferencesEncodersSizer.Add(self.loadSavePresetLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        presetLoadSaveSizer.Add(self.presetCombo, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        presetLoadSaveSizer.Add(self.presetSaveButton, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(presetLoadSaveSizer, 1, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.FileOptionsLabel, 0, wx.ALIGN_BOTTOM, 0)
        preferencesEncodersSizer.Add((10, 20), 0, 0, 0)
        preferencesEncodersSizer.Add(self.containerFormatLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.containerFormatChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.extraFlagsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.extraFlagsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.videoOptionsLabel, 0, wx.TOP|wx.ALIGN_BOTTOM, 10)
        preferencesEncodersSizer.Add((20, 20), 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.twoPassVideoLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.twoPassVideoChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoFirstPassOptsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoFirstPassOptsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.videoSecondPassOptsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoSecondPassOptsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.videoFilterStringLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoFilterStringText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.audioOptionsLabel, 0, wx.TOP, 10)
        preferencesEncodersSizer.Add((20, 20), 0, 0, 0)
        preferencesEncodersSizer.Add(self.audioCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.audioCodecOptionsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioCodecOptionsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.audioFilterLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioFilterText, 0, wx.EXPAND, 0)
        self.preferencesEncodersPane.SetSizer(preferencesEncodersSizer)
        preferencesEncodersSizer.AddGrowableCol(1)
        preferencesQueueSIzer.Add(self.threadCountLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.threadCountSpin, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.removeCompletedLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.removeCompletedChoice, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        self.preferencesQueuePane.SetSizer(preferencesQueueSIzer)
        preferencesQueueSIzer.AddGrowableCol(1)
        preferencesFilesSizer.Add(self.savePathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.videoOutputPathText, 0, wx.EXPAND, 0)
        preferencesFilesSizer.Add((20, 10), 0, 0, 0)
        preferencesFilesSizer.Add(self.videoOutputPathButton, 0, 0, 0)
        preferencesFilesSizer.Add((20, 20), 0, 0, 0)
        preferencesFilesSizer.Add((20, 20), 0, 0, 0)
        preferencesFilesSizer.Add(self.fileTemplateLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.fileTemplateText, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add((20, 20), 0, 0, 0)
        preferencesFilesSizer.Add(self.fileTemplateHelpLabel, 0, 0, 0)
        self.preferencesFilesPane.SetSizer(preferencesFilesSizer)
        preferencesFilesSizer.AddGrowableCol(1)
        externalProgramsSizer.Add(self.mencoderPathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        externalProgramsSizer.Add(self.mencoderPathText, 0, wx.EXPAND, 0)
        externalProgramsSizer.Add(self.playerPathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        externalProgramsSizer.Add(self.playerPathText, 0, wx.EXPAND, 0)
        externalProgramsSizer.Add(self.mythtranscodePathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        externalProgramsSizer.Add(self.mythtranscodePathText, 0, wx.EXPAND, 0)
        self.preferencesExternalProgramsPane.SetSizer(externalProgramsSizer)
        externalProgramsSizer.AddGrowableCol(1)
        self.preferencesNotebook.AddPage(self.preferencesMythTVPane, "MythTV")
        self.preferencesNotebook.AddPage(self.preferencesEncodersPane, "Encoder")
        self.preferencesNotebook.AddPage(self.preferencesQueuePane, "Queue")
        self.preferencesNotebook.AddPage(self.preferencesFilesPane, "Output Files")
        self.preferencesNotebook.AddPage(self.preferencesExternalProgramsPane, "External Programs")
        preferencesSizer.Add(self.preferencesNotebook, 1, wx.EXPAND, 0)
        preferencesButtonSizer.Add(self.preferencesCancelButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesButtonSizer.Add(self.preferencesOKButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesSizer.Add(preferencesButtonSizer, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(preferencesSizer)
        self.Layout()
        # end wxGlade


    # set the preferences window to the prefs defined in the prefs argument
    def setPreferences(self, prefs):
        self.prefs = prefs
        
        for (prefKey,(controlType,controlVar)) in self.prefMap.iteritems():

            if prefs.has_key( prefKey ):
                self.setControlValue( controlType, controlVar, prefs[ prefKey ] )


    def setControlValue( self, controlType, controlVar, value ):
                
        # set the value according to controlType

        if controlType == "TextCtrl":
            controlVar.SetValue( str(value) )
        elif controlType == "Spin":
            controlVar.SetValue( int(value) )
        elif controlType == "Choice":
            controlVar.SetSelection( int(value) )
        elif controlType == "DirPicker":  
            controlVar.SetPath( str(value) )


    # load the preferences that are currently set in this frame in to a prefs array and return it
    def getPreferences(self):        
        prefs = {}
        
        for (prefKey,(controlType,controlVar)) in self.prefMap.iteritems():

            # stuff it in to the prefs array
            prefs[ prefKey ] = self.getControlValue( controlType, controlVar )

        return prefs


    def getControlValue(self, controlType, controlVar):
        # retrieve the value according to controlType
        if controlType in ("TextCtrl","Spin"): # these types all share GetValue()
            value = controlVar.GetValue()
        elif controlType == "Choice":
            value = controlVar.GetCurrentSelection()
        elif controlType == "DirPicker":
            value = controlVar.GetPath()
            
        return value

    def populatePresetCombo(self):        
        self.presetCombo.Clear()
        for presetName,presetItem in self.presetDict.iteritems():            
            self.presetCombo.Append(presetName)


    def onCancelButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        # this event is picked up by the mainframe where the actual saving/load of preferences takes place
        self.Hide()
        event.Skip()

    def onOKButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        # this event is picked up by the mainframe where the actual saving/load of preferences takes place
        self.Hide()
        event.Skip()
        
    def onVideoCodecChange(self, event): # wxGlade: preferencesFrame.<event_handler>

        selection = self.videoCodecChoice.GetCurrentSelection()
        videoCodec = videoCodecDict[ selection ]
        
        if videoCodec[1]:
            showParens = ' (%s)' % videoCodec[2]
        else:
            showParens = ''
            
        self.videoFirstPassOptsLabel.SetLabel('First Pass Options%s:' % showParens)
        self.videoSecondPassOptsLabel.SetLabel('Second Pass Options%s:' % showParens)
        
        self.preferencesEncodersPane.Fit()
        event.Skip()

    def onAudioCodecChange(self, event): # wxGlade: preferencesFrame.<event_handler>

        selection = self.audioCodecChoice.GetCurrentSelection()
        audioCodec = audioCodecDict[ selection ]
        
        if audioCodec[1]:
            showParens = ' (%s)' % audioCodec[2]
        else:
            showParens = ''
            
        self.audioCodecOptionsLabel.SetLabel('Audio Codec Options%s:' % showParens)
        
        if audioCodec[1]:
            self.audioCodecOptionsText.SetValue( audioCodec[3] )
        else:
            self.audioCodecOptionsText.SetValue( '' )

        self.preferencesEncodersPane.Fit()
        event.Skip()

    def onVideoOutputPathButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        wx_dir_chooser = wx.DirDialog(self,
                                      message="Choose the directory where you want encoded videos to be saved.")

        result = wx_dir_chooser.ShowModal()
        dest_path = wx_dir_chooser.GetPath()
        wx_dir_chooser.Destroy()

        if result != wx.ID_OK:
            return

        self.videoOutputPathText.SetValue( dest_path )
        event.Skip()

    def onPresetSave(self, event): # wxGlade: preferencesFrame.<event_handler>

        presetName = self.presetCombo.GetValue()

        presetItemDict = {}

        presetDict = {}
        for item in self.presetItems:
            (controlType, controlVar) = self.prefMap[item]
            presetItemDict[item] = self.getControlValue( controlType, controlVar )
            
        self.presetDict[ presetName ] = presetItemDict

        wxmessage = wx.MessageDialog(parent=self, caption="MythRip - Preset Saved", message="Preset '%s' saved." % presetName, style=wx.OK)
        wxmessage.ShowModal()
                    
        self.populatePresetCombo()

        event.Skip()

    def onLoadPresetComboEvent(self, event): # wxGlade: preferencesFrame.<event_handler>

        presetName = self.presetCombo.GetValue()
        
        if self.presetDict.has_key(presetName):

            presetSetItem = self.presetDict[ presetName ]
        
            for presetFieldName in self.presetItems:

                presetPrefMap = self.prefMap[ presetFieldName ]
                
                self.setControlValue( presetPrefMap[0], presetPrefMap[1], presetSetItem[ presetFieldName ] )

        self.onVideoCodecChange(event)

        event.Skip()

# end of class preferencesFrame


class mythRipMain(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        self.mainFrameInstance = mainFrame(None, -1, "")
        self.SetTopWindow(self.mainFrameInstance)
        self.mainFrameInstance.Show()
        return 1

# end of class mythRipMain

if __name__ == "__main__":
    mythRip = mythRipMain(0)
    mythRip.MainLoop()

