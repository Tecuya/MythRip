#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Fri May 22 10:25:23 2009

# mythrip: GUI tool to export MythTV recordings to various portable media files, and manage recordings in general

import os
import shutil
import sys
import wx
import mythtv
import threading
import subprocess
import socket
import re
import time   # for debugging only so far
import signal
import stat

# begin wxGlade: extracode
# end wxGlade




class mainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        
        toolbarEncode = wx.NewId()
        toolbarView = wx.NewId()
        toolbarDelete = wx.NewId()
        toolbarPrefs = wx.NewId()
        toolbarReload = wx.NewId()
        toolbarQuit = wx.NewId()

        # begin wxGlade: mainFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.mainFrameMenubar = wx.MenuBar()
        self.fileMenuItem = wx.Menu()
        self.deleteMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Delete", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.deleteMenuItem)
        self.fileMenuItem.AppendSeparator()
        self.quitMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Quit", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.quitMenuItem)
        self.mainFrameMenubar.Append(self.fileMenuItem, "&File")
        self.editMenuItem = wx.Menu()
        self.prefsMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Preferences", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.prefsMenuItem)
        self.mainFrameMenubar.Append(self.editMenuItem, "&Edit")
        self.viewMenuItem = wx.Menu()
        self.queMenuItem = wx.MenuItem(self.viewMenuItem, wx.NewId(), "&Queue", "", wx.ITEM_NORMAL)
        self.viewMenuItem.AppendItem(self.queMenuItem)
        self.mainFrameMenubar.Append(self.viewMenuItem, "&View")
        self.helpMenuItem = wx.Menu()
        self.aboutMenuItem = wx.MenuItem(self.helpMenuItem, wx.NewId(), "&About", "", wx.ITEM_NORMAL)
        self.helpMenuItem.AppendItem(self.aboutMenuItem)
        self.mainFrameMenubar.Append(self.helpMenuItem, "&Help")
        self.SetMenuBar(self.mainFrameMenubar)
        # Menu Bar end
        self.mainFrameStatusbar = self.CreateStatusBar(1, 0)
        
        # Tool Bar
        self.mainFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.mainFrameToolbar)
        self.mainFrameToolbar.AddLabelTool(toolbarReload, "Reload", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/reload.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.mainFrameToolbar.AddLabelTool(toolbarEncode, "Encode", wx.Bitmap("/usr/share/icons/gnome/32x32/categories/applications-system.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Encode selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarView, "View", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-media-play-ltr.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "View selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarDelete, "Delete", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/stock_delete.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Delete selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarPrefs, "Preferences", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.mainFrameToolbar.AddLabelTool(toolbarQuit, "Quit", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/application-exit.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        # Tool Bar end
        self.mainFrameListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.LC_EDIT_LABELS|wx.LC_SORT_ASCENDING|wx.SUNKEN_BORDER)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.onMenuDelete, self.deleteMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuQuit, self.quitMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuPrefs, self.prefsMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuQueue, self.queMenuItem)
        self.Bind(wx.EVT_TOOL, self.onToolbarReload, id=toolbarReload)
        self.Bind(wx.EVT_TOOL, self.onToolbarEncode, id=toolbarEncode)
        self.Bind(wx.EVT_TOOL, self.onToolbarDelete, id=toolbarDelete)
        self.Bind(wx.EVT_TOOL, self.onToolbarPrefs, id=toolbarPrefs)
        self.Bind(wx.EVT_TOOL, self.onToolbarQuit, id=toolbarQuit)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.onColClick, self.mainFrameListCtrl)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.onItemRightClick, self.mainFrameListCtrl)
        # end wxGlade

        ################################################################################
        # Various non-wxglade GUI setup

        # set up our child frames
        self.encoderQueueFrame = encoderQueueFrame(parent=self)
        self.preferencesFrame = preferencesFrame(parent=self)

        # bind "OK" button presses in preferences frame to our own event handler
        self.Bind(wx.EVT_BUTTON, self.onPrefsOK, self.preferencesFrame.preferencesOKButton)

        # set up the ListCtrl columns
        self.mainFrameListCtrl.InsertColumn(0, "Show")
        self.mainFrameListCtrl.InsertColumn(1, "Episode")
        self.mainFrameListCtrl.InsertColumn(2, "Air Time")
        self.mainFrameListCtrl.InsertColumn(3, "Flags")

        ###################################################################################
        # preference handling

        # map of options support by the config file and internal prefs
	self.optionMap = ( { 'short': '-P', 'long': '--mysqlport', 'action': 'store', 'dest': 'mysqlPort', 'default': 3306, 'help': 'MythTV MySQL Port', 'autoDiscover': True },
                           { 'short': '-H', 'long': '--mysqlhost', 'action': 'store', 'dest': 'mysqlHost', 'default': 'localhost', 'help': 'MythTV MySQL Host', 'autoDiscover': True},
                           { 'short': '-u', 'long': '--mysqluser', 'action': 'store', 'dest': 'mysqlUser', 'default': 'localhost', 'help': 'MythTV MySQL User', 'autoDiscover': True},
                           { 'short': '-p', 'long': '--mysqlpass', 'action': 'store', 'dest': 'mysqlPassword', 'default': 'localhost', 'help': 'MythTV MySQL Password', 'autoDiscover': True},
                           { 'short': '-d', 'long': '--mysqldb', 'action': 'store', 'dest': 'mysqlDB', 'default': 'localhost', 'help': 'MythTV MySQL Database Name', 'autoDiscover': True},
                           { 'short': '-c', 'long': '--container', 'action': 'store', 'dest': 'containerFormat', 'default': '0', 'help' : 'Container format' },
                           { 'short': '-v', 'long': '--videocodec', 'action': 'store', 'dest': 'videoCodec', 'default': '0', 'help' : 'Video Codec Choice Index' },
                           { 'short': '-1', 'long': '--videocodecopts', 'action': 'store', 'dest': 'videoFirstPassOpts', 'default': '', 'help' : 'Video Codec Option String - Pass 1' },
                           { 'short': '-2', 'long': '--videocodecoptspass2', 'action': 'store', 'dest': 'videoSecondPassOpts', 'default': '', 'help' : 'Video Codec Option String - Pass 2' },
                           { 'short': '-f', 'long': '--videofilter', 'action': 'store', 'dest': 'videoFilter', 'default': 'pp=fd', 'help': 'Video Filter String' },
                           { 'short': '-T', 'long': '--twopass', 'action': 'store', 'dest': 'twoPassVideo', 'default': '0', 'help' : 'Two Pass Video Choice Index' },
                           { 'short': '-a', 'long': '--audiocodec', 'action': 'store', 'dest': 'audioCodec', 'default': '0', 'help' : 'Audio Codec Choice Index' },
                           { 'short': '-A', 'long': '--audiocodecopts', 'action': 'store', 'dest': 'audioCodecOptions', 'default': '', 'help' : 'Audio Codec Option String' },
                           { 'short': '-F', 'long': '--audiofilter', 'action': 'store', 'dest': 'audioFilter', 'default': '', 'help' : 'Audio Filter String' },
                           { 'short': '-t', 'long': '--threadcount', 'action': 'store', 'dest': 'threadCount', 'default': '2', 'help' : 'Max Simultaneous Encoding Jobs' },
                           { 'short': '-r', 'long': '--removecompleted', 'action': 'store', 'dest': 'removeCompleted', 'default': '0', 'help' : 'Remove Completed Job Choice Index' },                       
                           { 'short': '-s', 'long': '--savepath', 'action': 'store', 'dest': 'savePath', 'default': os.path.expanduser('~/Desktop'), 'help' : 'Save Encodings to Path' }, 
                           { 'short': '-x', 'long': '--filetemplate', 'action': 'store', 'dest': 'fileTemplate', 'default': '%s - %t.%x', 'help' : 'Output File Naming Template' }
                           # use this to add new rows easily:
                           # { 'short': '-', 'long': '--', 'action': '', 'dest': '', 'default': '', 'help' : '' }                                                      
                           )

        # load preferences from disk
        self.loadPrefsFromDisk()
        
        # load preferences from CLI ; these override disk preferences
        self.loadPrefsFromCli()

        # push the prefs we've gathered in to the preferences frame
        self.populatePrefsToChildren()

        ###############################################################################
        # make mythtv connection and load data from it
        
        # a variable to stuff the program list in to
        self.programList = []

        # connect to mythtv
        self.connectToMyth()

        # load recordings from myth
        self.loadRecordingsFromMyth()

        # prepare the right-click context menu entry definitions
        self.contextMenuEntriesById = {}
        for item in [ "Preview", "Delete", "Encode" ]:
            self.contextMenuEntriesById[ wx.NewId() ] = item

    def __set_properties(self):
        # begin wxGlade: mainFrame.__set_properties
        self.SetTitle("MythRip - Main")
        self.SetSize((720, 430))
        self.mainFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        mainFrameStatusbar_fields = ["mainFrame_statusbar"]
        for i in range(len(mainFrameStatusbar_fields)):
            self.mainFrameStatusbar.SetStatusText(mainFrameStatusbar_fields[i], i)
        self.mainFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: mainFrame.__do_layout
        mainFrameSizer = wx.BoxSizer(wx.HORIZONTAL)
        mainFrameSizer.Add(self.mainFrameListCtrl, 1, wx.EXPAND, 0)
        self.SetSizer(mainFrameSizer)
        self.Layout()
        # end wxGlade

    def connectToMyth(self):        
        # establish our MythTV connection using the mythtv python bindings, push our preferences in to it
        try: 
            self.mythTV = mythtv.MythTV(force_db_opts=self.prefs)
        except Exception, e:
            self.showErrorDialog("Error connecting to MythTV", "Error connecting to MythTV:\n%s\nPlease alter your MythTV settings in the Preferences Dialog"%str(e))
            # it failed?  send the user to the preferences dialog
            self.preferencesFrame.Show()

        
    def loadRecordingsFromMyth(self):

        # delete any listctrl items currently present
        for i in range(len(self.programList)):
            self.mainFrameListCtrl.DeleteItem( self.mainFrameListCtrl.FindItemData(0, i) )

        # reset the programList
        self.programList = []

        # query recordings from the backend
        rawRecordings = self.mythTV.backendCommand('QUERY_RECORDINGS Play').split(mythtv.BACKEND_SEP)            

        if len(rawRecordings):
            # determine the record length and number of recordings present in the response
            numberRecordings = int(rawRecordings[0])        
            recordingLength = (len(rawRecordings) - 1) / numberRecordings

            # parse the output, stuff the results in to a list of Program objects

            for recording in range(numberRecordings):            
                idxStart = ( recording * recordingLength ) + 1    # plus one - offset for the beginning's "record count" record
                idxStop = ( recording + 1 ) * recordingLength     # stop at the next recording beginning

                recordingData = rawRecordings[idxStart:idxStop]

                print "RECORDING: ",recordingData,"------------------------------------------------------\n\n\n"

                self.programList.append( mythtv.Program( recordingData ) )
            
        # add recording count to the status bar
        self.mainFrameStatusbar.PushStatusText('Loaded %d recordings' % len(self.programList))
        
        
        # push in the ListCtrl data
        for i in range(len(self.programList)):
            program = self.programList[i]
            self.mainFrameListCtrl.InsertStringItem(i, program.title)
            self.mainFrameListCtrl.SetStringItem(i, 1, program.subtitle)
            self.mainFrameListCtrl.SetStringItem(i, 2, str(program.starttime))
            
            # unpack program flags to english strings
            flags = []
            for k,v in mythtv.PROGRAM_FLAGS.iteritems():
                if int(program.programflags) & v:
                    flags.append(k)

            self.mainFrameListCtrl.SetStringItem(i, 3, ', '.join(flags) )
            self.mainFrameListCtrl.SetItemData(i, i)  # set item datas to be the same as indexes initially
            
        # make nice column sizes
        self.mainFrameListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)
        
        # these variables are for preserving the listctrl sorting state
        self.lastColClick = 0
        self.sortToggler = 1

        # run an initial sort
        self.mainFrameListCtrl.SortItems( self.sortList ) 
        

    # this is the callback to sort the mainFrameListCtrl used by mainFrameListCtrl.SortItems
    def sortList(self, item1, item2):
                        
        progLeft = self.programList[ item1 ]
        progRight = self.programList[ item2 ]
        
        if self.lastColClick == 0:
            if progLeft.title < progRight.title:
                return -1 * self.sortToggler
            elif progLeft.title == progRight.title:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 1:
            if progLeft.subtitle < progRight.subtitle:
                return -1 * self.sortToggler
            elif progLeft.subtitle == progRight.subtitle:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 2:
            if progLeft.starttime < progRight.starttime:
                return -1 * self.sortToggler
            elif progLeft.starttime == progRight.starttime:
                return 0
            else:
                return 1 * self.sortToggler

        return 0
    
    
    # this function returns a list of the mythtv Program objects that have been selected
    def getSelectedPrograms(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.mainFrameListCtrl.GetFirstSelected()
        while item != -1:
            program = self.programList[ self.mainFrameListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.mainFrameListCtrl.GetNextSelected(item)
        
        return returnList
        
    def addRecordingsToQueue(self):
        
        addcount = 0
        for program in self.getSelectedPrograms():
            self.encoderQueueFrame.addProgram(program)
            addcount += 1

        self.mainFrameStatusbar.PushStatusText('Added %d recordings to queue.' % addcount)
            

    def readPrefsFromDisk(self):
        prefs = {}
	cfgfile=os.path.expanduser('~')+'/.mythriprc'
	
	if not os.access(cfgfile,os.F_OK):
	    print "mythrip config file not found, generating a default one in %s for you.." % cfgfile
	    cfg = file(cfgfile,'w+')
	    cfg.write("# Automatically generated mythrip config file.\n\n")
	    for option in self.optionMap:

                # we avoid writing the mysql options because they are automatically discovered by the self.findMythMysqlSettings
                if option.has_key('autoDiscover'):
                    optionPrefix = "# "
                else:
                    optionPrefix = ""
                
                cfg.write("# %s\n%s%s %s\n\n" % (option['help'], optionPrefix, option['dest'], option['default']))
	    cfg.close()
	    
        # read config file	    
	lines = file(cfgfile,'r').readlines()

	# parse config line by line
	for line in lines:
	    if line[0] != '#':
		delimiterAt = line.find(' ')
		if delimiterAt != -1:
		    opt = line[:delimiterAt].strip()
		    value = line[delimiterAt+1:].rstrip("\n")
		    
		    # try to interpret config options
		    if value.lower() == 'true':
			setvalue = True
		    elif value.lower() == 'false':
			setvalue = False
		    elif value.isdigit():
			setvalue = int(value)
		    else:
			setvalue = value
		    
		    prefs[opt] = setvalue

        return prefs

    # write a dictionary of options to the configuration file
    def writePrefsToDisk(self):
        print "writePrefsToDisk"

	cfgFile=os.path.expanduser('~')+'/.mythriprc'
        
        cfg = file(cfgFile,'w+')
        cfg.write("# Automatically generated mythrip config file.\n\n")

        for option in self.optionMap:
            if self.prefs.has_key( option["dest"] ): # if the option appears in our prefs then save it
                cfg.write("## %s\n%s %s\n\n" % (option["help"], option["dest"], self.prefs[ option["dest"] ]))

        cfg.close()

    # read CLI optparse opts into the self.prefs, if they were given
    def loadPrefsFromCli(self):
	import optparse
	usage = "%prog [options]"
	
        cliparser = optparse.OptionParser(usage=usage)
	
	for option in self.optionMap:
            cliparser.add_option(option['short'],option['long'],action=option['action'],dest=option['dest'],help=option['help'])
	
	(options, files) = cliparser.parse_args()
		
	for option in self.optionMap:
            value = getattr(options, option['dest'])
            if value:
                print "pref ",option['dest']," loaded with value",value,"from cli"
                self.prefs[option['dest']] = value
                
    def populatePrefsToChildren(self):
        self.preferencesFrame.setPreferences( self.prefs )
        self.encoderQueueFrame.setPreferences( self.prefs )

        
    def onPrefsOK(self, event):

        # load the preferences from the prefs frame
        self.prefs = self.preferencesFrame.getPreferences()
        
        self.writePrefsToDisk()

        self.populatePrefsToChildren()

        self.mainFrameStatusbar.PushStatusText('Preferences saved.')

        event.Skip()

    def loadPrefsFromDisk(self):
        
        # load the prefs from disk to self.prefs        
        self.prefs = self.readPrefsFromDisk()
                
        # if we did not load mysqlHost from disk, assume we should try and find the myth settings from the myth config files
        if not self.prefs.has_key("mysqlHost"):
            print "mysql host wasnt loaded from disk; searching for mysql settings"
            self.prefs.update( self.findMythMysqlSettings() )
            
        self.mainFrameStatusbar.PushStatusText('Preferences loaded.')
        
        print "loadPrefsFromDisk returning : ",self.prefs

            
    def findMythMysqlSettings(self):
        # Try to read the mysql.txt file used by MythTV.
        # Order taken from libs/libmyth/mythcontext.cpp
        config_files = [
            '/usr/local/share/mythtv/mysql.txt',
            '/usr/share/mythtv/mysql.txt',
            '/usr/local/etc/mythtv/mysql.txt',
            '/etc/mythtv/mysql.txt',
            os.path.expanduser('~/.mythtv/mysql.txt'),
            ]
        
        if 'MYTHCONFDIR' in os.environ:
            config_locations.append('%s/mysql.txt' % os.environ['MYTHCONFDIR'])

        found_config = False
        for config_file in config_files:

                dbconn_host = None
                dbconn_name = None
                dbconn_user = None
                dbconn_pass = None
                dbconn_port = None

                if not os.access(config_file, os.R_OK): 
                        continue

                for line in file(config_file):
                    
                    if line[0] != '#' and '=' in line:
                        equalPos = line.find('=')

                        key = line[0:equalPos]
                        val = line[equalPos+1:].strip()
                        
                        if key == "DBHostName":
                            dbconn_host = val
                        elif key == "DBPort":
                            dbconn_port = val
                        elif key == "DBName":
                            dbconn_name = val
                        elif key == "DBUserName":
                            dbconn_user = val
                        elif key == "DBPassword":
                            dbconn_pass = val

                if dbconn_host != None or dbconn_name != None or dbconn_user != None or dbconn_pass != None:
                    found_config = True
                    break
        
        # we didn't find a config file, just bail out
        if not found_config:
            return {}

        return {"mysqlHost": dbconn_host,
                "mysqlPort": dbconn_port,
                "mysqlDB": dbconn_name,
                "mysqlUser": dbconn_user,
                "mysqlPassword": dbconn_pass}
        

    def showErrorDialog(self,title,message):
        errorDialog = wx.MessageDialog(parent=self, caption=title, message=message)
        errorDialog.ShowModal()

    ###########################################################################
    # event handler land

        
    def onMenuQuit(self, event): # wxGlade: mainFrame.<event_handler>
        sys.exit()


    def onItemRightClick(self, event): # wxGlade: mainFrame.<event_handler>
        
        menu = wx.Menu()

        for (id,title) in self.contextMenuEntriesById.iteritems():
            menu.Append(id, title)
            wx.EVT_MENU( menu, id, self.onContextMenuSelection )
            
        self.PopupMenu( menu )

        event.Skip()

    def onColClick(self, event): # wxGlade: mainFrame.<event_handler>

        clickedCol = event.GetColumn()

        if (clickedCol == self.lastColClick):
            self.sortToggler *= -1
        else:
            self.sortToggler = 1

        self.lastColClick = clickedCol
        
        self.mainFrameListCtrl.SortItems( self.sortList ) 

        event.Skip()


    def onContextMenuSelection(self, event):        
        selectedMenuItem = self.contextMenuEntriesById[ event.GetId() ]
        if selectedMenuItem == "Encode":
            self.addRecordingsToQueue()
        event.Skip()
        
    def onMenuQueue(self, event): # wxGlade: mainFrame.<event_handler>        
        print "showing encoderQueueFrame.."
        self.encoderQueueFrame.Show()
        event.Skip()

    def onToolbarEncode(self, event): # wxGlade: mainFrame.<event_handler>
        self.addRecordingsToQueue()
        event.Skip()

    def onToolbarDelete(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarDelete' not implemented"
        event.Skip()

    def onMenuDelete(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onMenuDelete' not implemented"
        event.Skip()

    def onMenuPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        self.preferencesFrame.Show()
        event.Skip()

    def onToolbarPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        self.preferencesFrame.Show()
        event.Skip()

    def onToolbarQuit(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarQuit' not implemented"
        event.Skip()

    def onToolbarReload(self, event): # wxGlade: mainFrame.<event_handler>
        self.loadRecordingsFromMyth()
        event.Skip()

# end of class mainFrame





class aboutFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: aboutFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.aboutFrameContents = wx.StaticText(self, -1, "About MythRIP", style=wx.ALIGN_CENTRE)
        self.aboutFrameCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: aboutFrame.__set_properties
        self.SetTitle("MythRip - About")
        self.aboutFrameCloseButton.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: aboutFrame.__do_layout
        aboutFrameSizer = wx.BoxSizer(wx.VERTICAL)
        aboutFrameSizer.Add(self.aboutFrameContents, 0, wx.BOTTOM|wx.EXPAND, 0)
        aboutFrameSizer.Add(self.aboutFrameCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(aboutFrameSizer)
        aboutFrameSizer.Fit(self)
        self.Layout()
        # end wxGlade

# end of class aboutFrame


class encoderOptionsFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: encoderOptionsFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.encoderOptionsFrameStatusbar = self.CreateStatusBar(1, 0)

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: encoderOptionsFrame.__set_properties
        self.SetTitle("MythRip - Encoder Options")
        self.SetSize((400, 300))
        self.encoderOptionsFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        encoderOptionsFrameStatusbar_fields = ["encoderOptionsFrame_statusbar"]
        for i in range(len(encoderOptionsFrameStatusbar_fields)):
            self.encoderOptionsFrameStatusbar.SetStatusText(encoderOptionsFrameStatusbar_fields[i], i)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderOptionsFrame.__do_layout
        self.Layout()
        # end wxGlade

# end of class encoderOptionsFrame


class encoderQueueFrame(wx.Frame):
    def __init__(self, *args, **kwds):

        toolbarPause = wx.NewId()
        toolbarRemove = wx.NewId()
        toolbarUp = wx.NewId()
        toolbarDown = wx.NewId()
        toolbarOptions = wx.NewId()

        # begin wxGlade: encoderQueueFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Tool Bar
        self.encoderQueueFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.encoderQueueFrameToolbar)
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarPause, "Pause", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-media-pause.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Pause selected job(s)", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarRemove, "Remove", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-cancel.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Remove from queue", "Remove an item from the encoding queue")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarUp, "Up", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-up.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected recording(s) up", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarDown, "Down", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-down.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected recording(s) down", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarOptions, "Options", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Open the queue options dialog", "")
        # Tool Bar end
        self.encoderQueueListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.SUNKEN_BORDER)
        self.encoderQueueCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_TOOL, self.onToolbarPause, id=toolbarPause)
        self.Bind(wx.EVT_TOOL, self.onToolbarRemove, id=toolbarRemove)
        self.Bind(wx.EVT_TOOL, self.onToolbarUp, id=toolbarUp)
        self.Bind(wx.EVT_TOOL, self.onToolbarDown, id=toolbarDown)
        self.Bind(wx.EVT_TOOL, self.onToolbarOptions, id=toolbarOptions)
        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.encoderQueueCloseButton)
        # end wxGlade
        
        ##########################
        
        # this variable tracks the thread IDs .. 
        # because I use this style of identifying threads eventually the ID would wrap.. so there's the app's max threads limit!
        self.nextThreadID = 0

        # this variable contains a list of encoder jobs, including their thread handles
        self.threads = {}
        
        # this holds our app preferences
        self.prefs = {}

        # set up the listctrl
        self.encoderQueueListCtrl.InsertColumn(0, "Show")
        self.encoderQueueListCtrl.InsertColumn(1, "Episode")
        self.encoderQueueListCtrl.InsertColumn(2, "Air Time")
        self.encoderQueueListCtrl.InsertColumn(3, "Progress")
        
        # connect up a handler to update the GUI upon events from the encoder threads
        EVT_ENCODER(self, self.onEncoderEvent)    
        

    def __set_properties(self):
        # begin wxGlade: encoderQueueFrame.__set_properties
        self.SetTitle("MythRip - Encoding Queue")
        self.SetSize((640, 300))
        self.encoderQueueFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderQueueFrame.__do_layout
        encoderQueueSizer = wx.BoxSizer(wx.VERTICAL)
        encoderQueueSizer.Add(self.encoderQueueListCtrl, 1, wx.EXPAND, 0)
        encoderQueueSizer.Add(self.encoderQueueCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(encoderQueueSizer)
        self.Layout()
        # end wxGlade

    ##########################################################################################
    # meat

    def addProgram(self,program):
        
        # grab the next thread id
        threadID = self.nextThreadID
        
        # prepare the thread id for the thread after this one
        self.nextThreadID += 1
        
        # create the thread.  
        self.threads[threadID] = encoderThread(program, threadID, self)
        self.threads[threadID].start()
                
        # determine the number of items in the control and add in the next available slot
        newListIndex = self.encoderQueueListCtrl.GetItemCount()

        # insert the new list ctrl item
        self.encoderQueueListCtrl.InsertStringItem(newListIndex, program.title)
        self.encoderQueueListCtrl.SetStringItem(newListIndex, 1, program.subtitle)
        self.encoderQueueListCtrl.SetStringItem(newListIndex, 2, str(program.starttime))
        self.encoderQueueListCtrl.SetStringItem(newListIndex, 3, 'Initializing...')
        self.encoderQueueListCtrl.SetItemData(newListIndex, threadID) # store the thread id with each item

        # keep the table clean with some column resizing
        self.resizeEncoderQueueListCtrl()
                
    def getSelectedEncoders(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:
            thread = self.threads[ self.encoderQueueListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.encoderQueueListCtrl.GetNextSelected(item)
        
        return returnList


    def resizeEncoderQueueListCtrl(self):
        self.encoderQueueListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)

    def setPreferences(self, prefs):
        print "encoder queue frame received new prefs"
        self.prefs = prefs


    ##########################################################################################
    # event handlers


    # when an encoder event is received this is called
    def onEncoderEvent(self, event):

        print "Thread %d state %s : %s" % (event.threadID, event.threadState, event.listMessage)
        
        # we pretty much need this no matter what
        listCtrlIndex = self.encoderQueueListCtrl.FindItemData(0,event.threadID)
        
        if event.threadState == "terminating":
            # if the thread died, remove it from the thread pool, and remove the item from the listctrl

            print "Thread %d removed from thread pool." % event.threadID
            
            del self.threads[event.threadID]
            
            print "- Thread %d is at position %d in the list ctrl, removing it" % (event.threadID,listCtrlIndex)
            
            self.encoderQueueListCtrl.DeleteItem(listCtrlIndex)
            

        self.encoderQueueListCtrl.SetStringItem(listCtrlIndex, 3, event.listMessage)
        self.resizeEncoderQueueListCtrl()
        
        event.Skip()

    def onCloseButton(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.Hide()
        event.Skip()

    def onToolbarPause(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        
        print "Event handler `onToolbarPause' not implemented"
        event.Skip()

    def onToolbarRemove(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarRemove' not implemented"
        event.Skip()

    def onToolbarUp(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarUp' not implemented"
        event.Skip()

    def onToolbarDown(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarDown' not implemented"
        event.Skip()

    def onToolbarOptions(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarOptions' not implemented"
        event.Skip()

# end of class encoderQueueFrame

###################################################################
# encoder thread land

# get an ID for an "encoder" event 
EVT_ENCODER_ID = wx.NewId()

# define a macro for connecting event handlers to the encoder events
def EVT_ENCODER(theWin, theFunc):
   theWin.Connect(-1, -1, EVT_ENCODER_ID, theFunc)

# a simple event to throw out of the encoder
class encoderEvent(wx.PyEvent):
   def __init__(self, threadID, threadState, listMessage):
       wx.PyEvent.__init__(self)
       self.SetEventType(EVT_ENCODER_ID)
       self.threadID = threadID
       self.threadState = threadState
       self.listMessage = listMessage

# the encoder thread itself
class encoderThread(threading.Thread):
    
    def __init__(self, program, threadID, notifyWindow):
        
        self.notifyWindow = notifyWindow
        self.program = program
        self.threadID = threadID
        self.doCommand = ""
        self.mythTranscodeProcess = False
        self.mythTranscodeStdout = ""
        self.fifoDir = ""
        self.vidWidth = ""
        self.vidHeight = ""
        self.vidFramerate = ""
        self.audioRate = ""
        self.audioChannels = ""
        self.currentPass = 0

        # load parent constructor
        threading.Thread.__init__(self)
    
        
    def run(self):
                
        print "Thread ID %d : %s" % (self.threadID, self.program)
        
        self.startMythtranscode()

        # now we need to examine the mythtranscode output to determine the video and audio parameters .. 
        # we wait up to 10 seconds for them to show up in self.mythTranscodeStdout
        for i in range(10): 
            self.parseSubprocessOutput(mtGathering = True)
            print self.mythTranscodeStdout,"\n-----------------------------------------"
            if re.search(".*Stream.*Audio.*kb/s", self.mythTranscodeStdout):
                print "Found file AV parameters! Beginning extraction from mythtranscode output"
                (self.vidWidth, self.vidHeight, self.vidFramerate) = re.findall('.*Stream #.* ([0-9]+)x([0-9]+).* ([0-9]+\.[0-9]+) tb',self.mythTranscodeStdout)[0]
                (self.audioRate, audioChanMode) = re.findall('.*Stream #.* ([0-9]+) Hz, ([A-Za-z]+)',self.mythTranscodeStdout)[0]
                if audioChanMode == "stereo":
                    self.audioChannels = "2"
                else:
                    # TODO im not sure what other values are produced in this slot
                    self.audioChannels = "1"
                break

            time.sleep(1)

        

        twoPass = (self.notifyWindow.prefs["twoPassVideo"] == 0)
        # 0 is yes...
        if twoPass:
            mencCount = 2
        else:
            mencCount = 1
            
        # loop as many times as we are supposed to start mencoder
        for i in range(mencCount):
            
            self.currentPass = i+1

            # if this isnt the first loop, we can't count on mythtranscode being started!  we need to start a new one for subsequent passes
            if self.currentPass != 1:
                self.startMythtranscode()

            mencoderCmd = self.buildMencoderCmd( twoPass=twoPass, passNumber=self.currentPass )
            print mencoderCmd

            self.stdoutSockMenc, stdoutChildSockMenc = socket.socketpair() 
            self.stderrSockMenc, stderrChildSockMenc = socket.socketpair() 
            self.stdoutSockMenc.settimeout(0.1)
            self.stderrSockMenc.settimeout(0.1)

            self.mencoderProcess = subprocess.Popen(mencoderCmd, stdin=None, stdout=stdoutChildSockMenc.fileno(), stderr=stderrChildSockMenc.fileno())

            self.setRunningStatus( "Encoder started." )

            while True:

                print "encoder thread heartbeat"

                self.parseSubprocessOutput()
                
                # dead processes
                mythTranscodeRunning = (self.mythTranscodeProcess.poll() == None)
                mencoderRunning = (self.mencoderProcess.poll() == None)

                # if they arent both running
                if not ( mythTranscodeRunning and mencoderRunning ):

                    self.setRunningStatus( "Waiting for all subprocesses to end" )

                    print "alert - mencoderRunning",mencoderRunning,"mythTranscodeRunning",mythTranscodeRunning
                    
                    # wait 5 seconds for things to normalize
                    for sec in range(15):
                        
                        # read again
                        mythTranscodeRunning = (self.mythTranscodeProcess.poll() == None)
                        mencoderRunning = (self.mencoderProcess.poll() == None)
                        
                        if not mythTranscodeRunning and not mencoderRunning:
                            print "all subprocesses dead"
                            break

                        if sec > 5:

                            # read again
                            mythTranscodeRunning = (self.mythTranscodeProcess.poll() == None)
                            mencoderRunning = (self.mencoderProcess.poll() == None)

                            self.setRunningStatus( "Actively stopping subprocesses" )
                            print "its been %d seconds now.. going to aggressive mode" % sec

                            if sec > 10:
                                usesig = signal.SIGKILL
                            else:
                                usesig = signal.SIGTERM

                            if mythTranscodeRunning:
                                print "aggr, mencoder died but mythtranscode continues to run.  killing it."
                                os.kill(self.mythTranscodeProcess.pid, usesig)

                            if mencoderRunning:
                                print "aggr, the 5 sec wait, mythTranscode died but mencoder continues to run.  killing it."
                                os.kill(self.mencoderProcess.pid, usesig)


                        # wait a second.. both processes should be disolving more or less simultaneously
                        time.sleep(1);


                    self.parseSubprocessOutput()

                    # proceed to next pass or to termination or whatever
                    break 
                


                # check for the abort command and if its there then bail!
                if self.doCommand == "abort":
                    self.setRunningStatus( "Aborted by user" )
                    self.endThread("abort","Thread aborted.") # die!

                # wait a second before checking the subprocess again
                time.sleep(0.1)

        self.sendEncoderEvent( "stopped", "Completed" )


    def clearFifoDir(self):
        print "clearFifoDir"

        # get directory for our fifos to live in
        self.fifoDir = '/tmp/mythrip-%d-fifo' % self.threadID

        # we'll try killing that fifo dir 10 times.
        for sec in range(10):
            
            self.setRunningStatus( "Waiting for mythtranscode fifos" )

            if os.path.isdir(self.fifoDir):
                try:
                    shutil.rmtree(self.fifoDir)
                except Exception, e:
                    self.endThread("failed","Could not remove stale fifo directory: %s" % e)
            else:
                break

            time.sleep(1)

        try:
            os.mkdir(self.fifoDir)
        except Exception, e:
            self.endThread("failed","Failed creating fifo directories: %s" % e)


    def parseSubprocessOutput(self,mtGathering = False):
        
        streamDict = {"mt": [self.stdoutSockMT, self.stderrSockMT]}
                      
        # if we are in mtGathering mode, we ignore menc
        if not mtGathering:
            streamDict["menc"] = [self.stdoutSockMenc, self.stderrSockMenc]
        
        # read from all processes
        for (name, (stdoutSock,stderrSock)) in streamDict.iteritems():
            newstdout = ""
            newstderr = ""
            
            try:
                newstdout = stdoutSock.recv(1024)
                newstderr = stderrSock.recv(1024)

            except socket.timeout, e:
                pass 

            # print em out if there was anything
            if len(newstdout):
                # if this is mythtranscode, we need to gather up all the output so we may parse out video and audio parameters
                if mtGathering:
                    self.mythTranscodeStdout += newstdout

                # parse mencoder output for the queue listctrl
                if name == "menc":
                    # Pos:   6.1s    192f ( 0%) 35.13fps Trem:   0min   0mb  A-V:0.033 [715:1536]
                    match = re.findall('Pos\: +([0-9\.]+)s +([0-9]+)f \(([0-9 ]+%)\) +([0-9\.]+)fps',newstdout) # pull mencoder output
                    if match:
                        self.setRunningStatus("%s - %s seconds, frame %s (%s fps)" % (match[0][2], match[0][0], match[0][1], match[0][3]))
                    

                # because we just receive data periodically we might be getting only pieces of full output lines.. but this is just a progress indicator, its good enough
                # match = re.findall('.*Processed: (.*)',newstdout)
                # if match:
                # self.sendEncoderEvent( "running", "Pass %d : %s" % (self.currentPass, match[0]) )
                    
                print "STDOUT %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstdout)
            if len(newstderr):
                print "STDERR %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstderr)


    def buildMencoderCmd(self,twoPass,passNumber):
        
        prefs = self.notifyWindow.prefs
        
        print "loaded prefs",prefs

        # now fire up mencoder reading from mythtranscode's fifo
        mencoderCmd = ['/usr/bin/mencoder','-noskip','-idx',
                       os.path.join(self.fifoDir, 'vidout'),
                       '-audiofile', os.path.join(self.fifoDir,'audout'),
                       '-demuxer','20','-audio-demuxer','20',
                       '-rawvideo','w=%s:h=%s:fps=%s' % (self.vidWidth, self.vidHeight, self.vidFramerate),
                       '-rawaudio','rate=%s:channels=%s' % (self.audioRate, self.audioChannels),
                       '-demuxer','26']

        ### Audio
        
        # dont process sound on first pass of a two-pass encode
        # if twoPass and passNumber == 1:
        # mencoderCmd.extend( ['-nosound'] )
        # else:
        mencoderCmd.extend( ['-oac','copy'] )

        if len(prefs['audioFilter']):
            mencoderCmd.extend(['-af',prefs['audioFilter']])
            
        ### Video

        # load this pass' options
        if twoPass:

            if passNumber == 1:
                encOpts = prefs['videoFirstPassOpts']+':pass=1'
            else:
                encOpts = prefs['videoSecondPassOpts']+':pass=2'

        else:

            if passNumber == 1:
                encOpts = prefs['videoFirstPassOpts']
            else:
                encOpts = prefs['videoSecondPassOpts']

                      
        # 0 is xvid
        if prefs['videoCodec'] == 0:                 
            mencoderCmd.extend(['-ovc','xvid','-xvidencopts',encOpts])
            
        # 1 is x264
        elif prefs['videoCodec'] == 1:            
            mencoderCmd.extend(['-ovc','x264','-x264encopts',encOpts]), # :pass=1', # 'subq=5:8x8dct:frameref=2:bframes=3:b_pyramid:weight_b',
            
        if len(prefs['videoFilter']):            
            mencoderCmd.extend(['-vf',prefs['videoFilter']])

        mencoderCmd.extend([
                # '-frames','200', # debug - only do 100 frames
                '-o', '/home/sean/Desktop/video-thread-%d.avi' % self.threadID
                ])
                                           
        return mencoderCmd
    
    def startMythtranscode(self):
        
        self.clearFifoDir()

        print "Starting mythtranscode!"

        # fire up mythtranscode turbo=1:subq=1:frameref=1
        mythTranscodeCmd = ['/usr/bin/mythtranscode',
               '--showprogress',
               '-p','autodetect',
               '-c',str(self.program.chanid),
               '-s',self.program.recstartts.strftime('%Y-%m-%dT%H:%M:%S'),
               '-f',self.fifoDir,
               '--honorcutlist',
               '--verbose','libav']
        print mythTranscodeCmd        
        
        # use sockets for the subprocess file objects so we can read from stdout/stderr in a non-blocking fashion
        self.stdoutSockMT, stdoutChildSockMT = socket.socketpair() 
        self.stderrSockMT, stderrChildSockMT = socket.socketpair() 
        self.stdoutSockMT.settimeout(0.1)
        self.stderrSockMT.settimeout(0.1)
        self.mythTranscodeProcess = subprocess.Popen(mythTranscodeCmd, stdin=None, stdout=stdoutChildSockMT.fileno(), stderr=stderrChildSockMT.fileno())

        # 5 second loop
        for i in range(10):
            print "waiting for fifo dir %d" % i
            if self.isfifo( os.path.join(self.fifoDir,'vidout') ):
                print "fifo present!"
                break

            time.sleep(1)

    # func called to update the encoder queue frame listctrl item
    def setRunningStatus(self,status):

        if self.currentPass > 0 and self.notifyWindow.prefs["twoPassVideo"] == 0: # 0 is yes
            sendStat = "Pass %d : %s" % (self.currentPass, status)
        else:
            sendStat = status

        self.sendEncoderEvent( "running", sendStat )
        

    # func called by the main thread in order to issue commands
    def setCommand(self,command):
        self.doCommand = setCommand

    def endThread(self,threadState,listMessage):

        # i'm hoping this kills the subprocess... if not i might just use process.pid to kill it
        del self.mythTranscodeProcess

        # the last thing the thread does is tell the main thread its terminating, and thats a rule
        self.sendEncoderEvent( threadState, listMessage )
        
        # die!
        sys.exit()
       
    def sendEncoderEvent(self, threadState, listMessage):
        wx.PostEvent(self.notifyWindow, encoderEvent(self.threadID, threadState, listMessage))
            
    def isfifo(self,fn):
        return os.access(fn,os.R_OK) and stat.S_ISFIFO(os.stat(fn).st_mode)

        

###########################################################################
        

class preferencesFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: preferencesFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.preferencesNotebook = wx.Notebook(self, -1, style=0)
        self.preferencesFilesPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesQueuePane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesEncodersPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesMythTVPane = wx.Panel(self.preferencesNotebook, -1)
        self.mysqlHostLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Hostname: ")
        self.mysqlHostText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlPortLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Port: ")
        self.mysqlPortText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlUserLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL User: ")
        self.mysqlUserText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlPasswordLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Password: ")
        self.mysqlPasswordText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlDBNameLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Database Name: ")
        self.mysqlDBNameText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.FileOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "File Options:")
        self.containerFormatLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Container Format: ")
        self.containerFormatChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["avi", "mkv"])
        self.videoOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Options: ")
        self.videoCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Codec: ")
        self.videoCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["xvid", "x264"])
        self.twoPassVideoLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Two-Pass Video: ")
        self.twoPassVideoChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["Yes", "No"])
        self.videoFirstPassOptsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "First Pass Options (): ")
        self.videoFirstPassOptsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.videoSecondPassOptsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Second Pass Options (): ")
        self.videoSecondPassOptsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.videoFilterStringLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Filter String (-vf): ")
        self.videoFilterStringText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.audioOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Options:")
        self.audioCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec: ")
        self.audioCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["passthrough", "mp3lame", "ogg", "whatever"])
        self.audioCodecOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec Options ():")
        self.audioCodecOptionsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.audioFilterLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Filter String (-af): ")
        self.audioFilterText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.threadCountLabel = wx.StaticText(self.preferencesQueuePane, -1, "Max Simultaneous Jobs: ")
        self.threadCountSpin = wx.SpinCtrl(self.preferencesQueuePane, -1, "", min=0, max=100)
        self.removeCompletedLabel = wx.StaticText(self.preferencesQueuePane, -1, "Remove Completed Jobs: ")
        self.removeCompletedChoice = wx.Choice(self.preferencesQueuePane, -1, choices=["Yes", "No"])
        self.savePathLabel = wx.StaticText(self.preferencesFilesPane, -1, "Save Encoded Videos In: ")
        self.savePathPicker = wx.DirPickerCtrl(self.preferencesFilesPane, -1)
        self.fileTemplateLabel = wx.StaticText(self.preferencesFilesPane, -1, "File Naming Template: ")
        self.fileTemplateText = wx.TextCtrl(self.preferencesFilesPane, -1, "")
        self.preferencesCancelButton = wx.Button(self, wx.ID_CANCEL, "")
        self.preferencesOKButton = wx.Button(self, wx.ID_OK, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCancelButton, self.preferencesCancelButton)
        self.Bind(wx.EVT_BUTTON, self.onOKButton, self.preferencesOKButton)
        # end wxGlade
        
        # a map of which 'prefs' keys map to which controls in the preferences dialog, and the control type
        # we use this for getting/setting values in the preferences dialog
        self.prefMap = {'mysqlHost': ['TextCtrl', self.mysqlHostText],
                        'mysqlPort': ['TextCtrl', self.mysqlPortText],
                        'mysqlUser': ['TextCtrl', self.mysqlUserText],
                        'mysqlPassword': ['TextCtrl', self.mysqlPasswordText],
                        'mysqlDB': ['TextCtrl', self.mysqlDBNameText],
                        'containerFormat': ['Choice', self.containerFormatChoice],
                        'videoCodec': ['Choice', self.videoCodecChoice],
                        'videoFirstPassOpts': ['TextCtrl', self.videoFirstPassOptsText],
                        'videoSecondPassOpts': ['TextCtrl', self.videoSecondPassOptsText],
                        'videoFilter': ['TextCtrl', self.videoFilterStringText],
                        'twoPassVideo': ['Choice', self.twoPassVideoChoice],
                        'audioCodec': ['Choice', self.audioCodecChoice],
                        'audioCodecOptions': ['TextCtrl', self.audioCodecOptionsText],
                        'audioFilter': ['TextCtrl', self.audioFilterText],
                        'threadCount': ['Spin', self.threadCountSpin],
                        'removeCompleted': ['Choice', self.removeCompletedChoice],
                        'savePath': ['DirPicker', self.savePathPicker],
                        'fileTemplate': ['TextCtrl', self.fileTemplateText]                        
                        }

    def __set_properties(self):
        # begin wxGlade: preferencesFrame.__set_properties
        self.SetTitle("MythRip - Preferences")
        self.containerFormatChoice.SetSelection(0)
        self.videoCodecChoice.SetSelection(0)
        self.twoPassVideoChoice.SetSelection(0)
        self.audioCodecChoice.SetSelection(0)
        self.removeCompletedChoice.SetSelection(0)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: preferencesFrame.__do_layout
        preferencesSizer = wx.BoxSizer(wx.VERTICAL)
        preferencesButtonSizer = wx.BoxSizer(wx.HORIZONTAL)
        preferencesFilesSizer = wx.FlexGridSizer(6, 2, 0, 0)
        preferencesQueueSIzer = wx.FlexGridSizer(2, 2, 0, 0)
        preferencesEncodersSizer = wx.FlexGridSizer(7, 2, 0, 0)
        preferencesMythTVSizer = wx.FlexGridSizer(9, 2, 0, 0)
        preferencesMythTVSizer.Add(self.mysqlHostLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlHostText, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPortLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPortText, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlUserLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlUserText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mysqlPasswordLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPasswordText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mysqlDBNameLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlDBNameText, 0, wx.EXPAND, 0)
        self.preferencesMythTVPane.SetSizer(preferencesMythTVSizer)
        preferencesMythTVSizer.AddGrowableCol(1)
        preferencesEncodersSizer.Add(self.FileOptionsLabel, 0, 0, 0)
        preferencesEncodersSizer.Add((10, 10), 0, 0, 0)
        preferencesEncodersSizer.Add(self.containerFormatLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.containerFormatChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoOptionsLabel, 0, wx.ALIGN_BOTTOM, 0)
        preferencesEncodersSizer.Add((20, 20), 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.twoPassVideoLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.twoPassVideoChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoFirstPassOptsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoFirstPassOptsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.videoSecondPassOptsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoSecondPassOptsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.videoFilterStringLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoFilterStringText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.audioOptionsLabel, 0, 0, 0)
        preferencesEncodersSizer.Add((20, 20), 0, 0, 0)
        preferencesEncodersSizer.Add(self.audioCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.audioCodecOptionsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioCodecOptionsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.audioFilterLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioFilterText, 0, wx.EXPAND, 0)
        self.preferencesEncodersPane.SetSizer(preferencesEncodersSizer)
        preferencesEncodersSizer.AddGrowableCol(1)
        preferencesQueueSIzer.Add(self.threadCountLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.threadCountSpin, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.removeCompletedLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.removeCompletedChoice, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        self.preferencesQueuePane.SetSizer(preferencesQueueSIzer)
        preferencesQueueSIzer.AddGrowableCol(1)
        preferencesFilesSizer.Add(self.savePathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.savePathPicker, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.fileTemplateLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.fileTemplateText, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        self.preferencesFilesPane.SetSizer(preferencesFilesSizer)
        preferencesFilesSizer.AddGrowableCol(1)
        self.preferencesNotebook.AddPage(self.preferencesMythTVPane, "MythTV")
        self.preferencesNotebook.AddPage(self.preferencesEncodersPane, "Encoders")
        self.preferencesNotebook.AddPage(self.preferencesQueuePane, "Queue")
        self.preferencesNotebook.AddPage(self.preferencesFilesPane, "Files")
        preferencesSizer.Add(self.preferencesNotebook, 1, wx.EXPAND, 0)
        preferencesButtonSizer.Add(self.preferencesCancelButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesButtonSizer.Add(self.preferencesOKButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesSizer.Add(preferencesButtonSizer, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(preferencesSizer)
        preferencesSizer.Fit(self)
        self.Layout()
        # end wxGlade


    # set the preferences window to the prefs defined in the prefs argument
    def setPreferences(self, prefs):
        print "prefs frame being set with prefs passed from caller",prefs

        self.prefs = prefs
        
        for (prefKey,(controlType,controlVar)) in self.prefMap.iteritems():

            if prefs.has_key( prefKey ):
                
                # set the value according to controlType
                
                if controlType == "TextCtrl": 
                    controlVar.SetValue( str(prefs[ prefKey ]) )
                elif controlType == "Spin":
                    controlVar.SetValue( int(prefs[ prefKey ]) )
                elif controlType == "Choice":
                    controlVar.SetSelection( int(prefs[ prefKey ]) )
                elif controlType == "DirPicker":
                    controlVar.SetPath( str(prefs[ prefKey ]) )
                    

    # load the preferences that are currently set in this frame in to a prefs array and return it
    def getPreferences(self):
        print "prefs frame getting preferences from frame and returning them"
        
        prefs = {}
        
        for (prefKey,(controlType,controlVar)) in self.prefMap.iteritems():

            # retrieve the value according to controlType
            if controlType in ["TextCtrl","Spin"]: # these types all share GetValue()
                value = controlVar.GetValue()
            elif controlType == "Choice":
                value = controlVar.GetCurrentSelection()
            elif controlType == "DirPicker":
                value = controlVar.GetPath()

            # stuff it in to the prefs array
            prefs[ prefKey ] = value

        return prefs

    def onCancelButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        self.Hide()
        event.Skip()

    def onOKButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        # this event is picked up by the mainframe where the actual saving/load of preferences takes place
        self.Hide()
        event.Skip()
        
# end of class preferencesFrame


class mythRipMain(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        self.mainFrameInstance = mainFrame(None, -1, "")
        self.SetTopWindow(self.mainFrameInstance)
        self.mainFrameInstance.Show()
        return 1

# end of class mythRipMain

if __name__ == "__main__":
    mythRip = mythRipMain(0)
    mythRip.MainLoop()

