#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Fri May 22 10:25:23 2009

# mythrip: GUI tool to export MythTV recordings to various portable media files, and manage recordings in general

import os
import shutil
import sys
import wx
import mythtv
import threading
import subprocess
import socket
import re
import time 
import signal
import stat

# begin wxGlade: extracode
# end wxGlade

# for now i just snag the logger from the mythtv bindings.. maybe it'd be better to use my own.. i dunno
log = mythtv.log
DEBUG = mythtv.DEBUG
INFO = mythtv.INFO
WARNING = mythtv.WARNING
ERROR = mythtv.ERROR
FATAL = mythtv.FATAL
CRITICAL = mythtv.CRITICAL

# string defining the default log level, used by optparse 
defaultLogLevel = 'WARNING'

mythripVersionString = "MythRip v0.1"

class threadDetailFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: threadDetailFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.threadDetailLabel = wx.StaticText(self, -1, "Details for thread:")
        self.threadDetailInformation = wx.StaticText(self, -1, "")
        self.static_line_1 = wx.StaticLine(self, -1)
        self.threadMencoderPass1Label = wx.StaticText(self, -1, "mencoder Pass 1 Command:")
        self.threadMencoderPass1Cmd = wx.StaticText(self, -1, "[ Waiting.. ]")
        self.static_line_2 = wx.StaticLine(self, -1)
        self.threadMencoderPass2Label = wx.StaticText(self, -1, "mencoder Pass 2 Command:")
        self.threadMencoderPass2Cmd = wx.StaticText(self, -1, "[ Waiting.. ]")
        self.static_line_6 = wx.StaticLine(self, -1)
        self.threadMythtranscodeLabel = wx.StaticText(self, -1, "mythtranscode Command:")
        self.threadMythtranscodeCmd = wx.StaticText(self, -1, "[ Waiting.. ]")
        self.static_line_5 = wx.StaticLine(self, -1)
        self.threadMessagesLabel = wx.StaticText(self, -1, "Errors: ")
        self.threadMessagesText = wx.StaticText(self, -1, "[ None ]")
        self.static_line_7 = wx.StaticLine(self, -1)
        self.closeButton = wx.Button(self, -1, "Close")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.closeButton)
        # end wxGlade
        
        self.Bind(wx.EVT_SIZE, self.onResize, self)
        
        self.threadID = 0

        # start the updater timer
        self.genericTickingTimer = genericTickingTimer()
        self.genericTickingTimer.setFrameHandle(self)
        self.genericTickingTimer.Start(milliseconds=2000)
        
    def __set_properties(self):
        # begin wxGlade: threadDetailFrame.__set_properties
        self.SetTitle("Thread Details")
        self.SetSize((798, 621))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: threadDetailFrame.__do_layout
        threadDetailSizer = wx.BoxSizer(wx.VERTICAL)
        threadDetailInfoSizer = wx.BoxSizer(wx.HORIZONTAL)
        threadDetailInfoSizer.Add(self.threadDetailLabel, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        threadDetailInfoSizer.Add(self.threadDetailInformation, 0, wx.LEFT|wx.ALIGN_CENTER_VERTICAL, 5)
        threadDetailSizer.Add(threadDetailInfoSizer, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        threadDetailSizer.Add((20, 20), 0, 0, 0)
        threadDetailSizer.Add(self.static_line_1, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMencoderPass1Label, 0, 0, 0)
        threadDetailSizer.Add(self.threadMencoderPass1Cmd, 0, 0, 0)
        threadDetailSizer.Add((20, 20), 0, 0, 0)
        threadDetailSizer.Add(self.static_line_2, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMencoderPass2Label, 0, 0, 0)
        threadDetailSizer.Add(self.threadMencoderPass2Cmd, 0, 0, 0)
        threadDetailSizer.Add((20, 20), 0, 0, 0)
        threadDetailSizer.Add(self.static_line_6, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMythtranscodeLabel, 0, 0, 0)
        threadDetailSizer.Add(self.threadMythtranscodeCmd, 0, 0, 0)
        threadDetailSizer.Add((20, 20), 1, wx.EXPAND, 0)
        threadDetailSizer.Add(self.static_line_5, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.threadMessagesLabel, 0, 0, 0)
        threadDetailSizer.Add(self.threadMessagesText, 0, 0, 0)
        threadDetailSizer.Add(self.static_line_7, 0, wx.EXPAND, 0)
        threadDetailSizer.Add(self.closeButton, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 0)
        self.SetSizer(threadDetailSizer)
        self.Layout()
        # end wxGlade

    def setThreadID(self, threadID):        
        self.encoderThread = self.GetParent().threads[ threadID ] 
        self.threadID = threadID
        self.refreshThreadInfo()
        
    def refreshThreadInfo(self):
        if self.encoderThread.mencoderCmd.has_key(1):
            self.threadMencoderPass1Cmd.SetLabel( " ".join(self.encoderThread.mencoderCmd[1]) )

        if self.encoderThread.mencoderCmd.has_key(2):
            self.threadMencoderPass2Cmd.SetLabel( " ".join(self.encoderThread.mencoderCmd[2]) )        
            
        if self.encoderThread.mythtranscodeCmd and len(self.encoderThread.mythtranscodeCmd):
            self.threadMythtranscodeCmd.SetLabel(" ".join(self.encoderThread.mythtranscodeCmd))

        if self.encoderThread.state in ["failed","failedAndAcknowledged"]:
            self.threadMessagesText.SetLabel( self.encoderThread.failedMessage )

        self.threadDetailInformation.SetLabel( str(self.threadID) )

    def refreshAll(self):
        self.refreshThreadInfo()

        width = self.GetSizeTuple()[0]
        self.threadMencoderPass1Cmd.Wrap( width )
        self.threadMencoderPass2Cmd.Wrap( width )
        self.threadMythtranscodeCmd.Wrap( width )
        self.threadMessagesText.Wrap( width )

        self.Layout()

    def onCloseButton(self, event): # wxGlade: threadDetailFrame.<event_handler>
        self.Destroy()
        event.Skip()

    def onRefreshButton(self, event): # wxGlade: threadDetailFrame.<event_handler>
        self.refreshThreadInfo()
        event.Skip()

    def onResize(self, event):
        self.refreshAll()
        event.Skip()

    def onTimerTick(self):
        self.refreshAll()

# end of class threadDetailFrame



class mainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        
        toolbarEncode = wx.NewId()
        toolbarView = wx.NewId()
        toolbarDelete = wx.NewId()
        toolbarDeleteRerecord = wx.NewId()
        toolbarPrefs = wx.NewId()
        toolbarReload = wx.NewId()
        toolbarQuit = wx.NewId()

        # begin wxGlade: mainFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.mainFrameMenubar = wx.MenuBar()
        self.fileMenuItem = wx.Menu()
        self.reloadMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Reload", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.reloadMenuItem)
        self.encodeMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Encode", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.encodeMenuItem)
        self.viewMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&View", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.viewMenuItem)
        self.fileMenuItem.AppendSeparator()
        self.quitMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Quit", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.quitMenuItem)
        self.mainFrameMenubar.Append(self.fileMenuItem, "&File")
        self.editMenuItem = wx.Menu()
        self.deleteMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Delete", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.deleteMenuItem)
        self.deleteRerecordMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Delete + Re-record", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.deleteRerecordMenuItem)
        self.editMenuItem.AppendSeparator()
        self.prefsMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Preferences", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.prefsMenuItem)
        self.mainFrameMenubar.Append(self.editMenuItem, "&Edit")
        self.viewTopMenuItem = wx.Menu()
        self.queMenuItem = wx.MenuItem(self.viewTopMenuItem, wx.NewId(), "&Queue", "", wx.ITEM_NORMAL)
        self.viewTopMenuItem.AppendItem(self.queMenuItem)
        self.mainFrameMenubar.Append(self.viewTopMenuItem, "&View")
        self.helpMenuItem = wx.Menu()
        self.aboutMenuItem = wx.MenuItem(self.helpMenuItem, wx.NewId(), "&About", "", wx.ITEM_NORMAL)
        self.helpMenuItem.AppendItem(self.aboutMenuItem)
        self.mainFrameMenubar.Append(self.helpMenuItem, "&Help")
        self.SetMenuBar(self.mainFrameMenubar)
        # Menu Bar end
        self.mainFrameStatusbar = self.CreateStatusBar(1, 0)
        
        # Tool Bar
        self.mainFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.mainFrameToolbar)
        self.mainFrameToolbar.AddLabelTool(toolbarReload, "Reload", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/reload.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Reload MythTV recording list", "")
        self.mainFrameToolbar.AddSeparator()
        self.mainFrameToolbar.AddLabelTool(toolbarView, "View", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-media-play-ltr.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "View selected recording", "")
        self.mainFrameToolbar.AddLabelTool(toolbarEncode, "Encode", wx.Bitmap("/usr/share/icons/gnome/32x32/categories/applications-system.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Encode selected recordings(s)", "")
        self.mainFrameToolbar.AddSeparator()
        self.mainFrameToolbar.AddLabelTool(toolbarDelete, "Delete", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/stock_delete.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Delete and do not re-record selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarDeleteRerecord, "DeleteRerecord", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/window-close.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Delete and re-record selected recording(s)", "")
        self.mainFrameToolbar.AddSeparator()
        self.mainFrameToolbar.AddLabelTool(toolbarPrefs, "Preferences", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Open preferences dialog", "")
        self.mainFrameToolbar.AddLabelTool(toolbarQuit, "Quit", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/application-exit.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Quit", "")
        # Tool Bar end
        self.mainFrameListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.LC_EDIT_LABELS|wx.LC_SORT_ASCENDING|wx.SUNKEN_BORDER)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.onReload, self.reloadMenuItem)
        self.Bind(wx.EVT_MENU, self.onEncode, self.encodeMenuItem)
        self.Bind(wx.EVT_MENU, self.onView, self.viewMenuItem)
        self.Bind(wx.EVT_MENU, self.onQuit, self.quitMenuItem)
        self.Bind(wx.EVT_MENU, self.onDelete, self.deleteMenuItem)
        self.Bind(wx.EVT_MENU, self.onDeleteRerecord, self.deleteRerecordMenuItem)
        self.Bind(wx.EVT_MENU, self.onPrefs, self.prefsMenuItem)
        self.Bind(wx.EVT_MENU, self.onQueue, self.queMenuItem)
        self.Bind(wx.EVT_MENU, self.onAbout, self.aboutMenuItem)
        self.Bind(wx.EVT_TOOL, self.onReload, id=toolbarReload)
        self.Bind(wx.EVT_TOOL, self.onView, id=toolbarView)
        self.Bind(wx.EVT_TOOL, self.onEncode, id=toolbarEncode)
        self.Bind(wx.EVT_TOOL, self.onDelete, id=toolbarDelete)
        self.Bind(wx.EVT_TOOL, self.onDeleteRerecord, id=toolbarDeleteRerecord)
        self.Bind(wx.EVT_TOOL, self.onPrefs, id=toolbarPrefs)
        self.Bind(wx.EVT_TOOL, self.onQuit, id=toolbarQuit)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.onColClick, self.mainFrameListCtrl)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.onItemRightClick, self.mainFrameListCtrl)
        # end wxGlade

        ################################################################################
        # Various non-wxglade GUI setup

        # set up our various single-instance child frames
        self.encoderQueueFrame = encoderQueueFrame(parent=self)
        self.preferencesFrame = preferencesFrame(parent=self)
        self.aboutFrame = aboutFrame(parent=self)

        # bind "OK" button presses in preferences frame to our own event handler
        self.Bind(wx.EVT_BUTTON, self.onPrefsOK, self.preferencesFrame.preferencesOKButton)
        self.Bind(wx.EVT_BUTTON, self.onPrefsCancel, self.preferencesFrame.preferencesCancelButton)

        # set up the ListCtrl columns
        self.mainFrameListCtrl.InsertColumn(0, "Show")
        self.mainFrameListCtrl.InsertColumn(1, "Episode")
        self.mainFrameListCtrl.InsertColumn(2, "Air Time")
        self.mainFrameListCtrl.InsertColumn(3, "Flags")

        ###################################################################################
        # preference handling

        # map of options support by the config file and internal prefs

        self.optionMap = ( { 'short': '-P', 'long': '--mysqlport', 'action': 'store', 'dest': 'mysqlPort', 'default': 3306, 'help': 'MythTV MySQL Port', 'autoDiscover': True },
                           { 'short': '-H', 'long': '--mysqlhost', 'action': 'store', 'dest': 'mysqlHost', 'default': 'localhost', 'help': 'MythTV MySQL Host', 'autoDiscover': True},
                           { 'short': '-u', 'long': '--mysqluser', 'action': 'store', 'dest': 'mysqlUser', 'default': 'localhost', 'help': 'MythTV MySQL User', 'autoDiscover': True},
                           { 'short': '-p', 'long': '--mysqlpass', 'action': 'store', 'dest': 'mysqlPassword', 'default': 'localhost', 'help': 'MythTV MySQL Password', 'autoDiscover': True},
                           { 'short': '-D', 'long': '--mysqldb', 'action': 'store', 'dest': 'mysqlDB', 'default': 'localhost', 'help': 'MythTV MySQL Database Name', 'autoDiscover': True},
                           { 'short': '-R', 'long': '--mythrecordingpath', 'action': 'store', 'dest': 'mythtvRecordingPath', 'default': '/mythtv', 'help': 'MythTV Recording Path'},
                           { 'short': '-C', 'long': '--mythcutlist', 'action': 'store', 'dest': 'useMythCutlist', 'default': '0', 'help': 'Use MythTV Cutlist'},
                           { 'short': '-m', 'long': '--mencoderpath', 'action': 'store', 'dest': 'mencoderPath', 'default': '/usr/bin/mencoder', 'help': 'Full path to mencoder'},
                           { 'short': '-M', 'long': '--playerpath', 'action': 'store', 'dest': 'playerPath', 'default': '/usr/bin/mplayer', 'help': 'Full path to player'},
                           { 'short': '-z', 'long': '--mythtranscodepath', 'action': 'store', 'dest': 'mythtranscodePath', 'default': '/usr/bin/mythtranscode', 'help': 'Full path to mythtranscode'},
                           { 'short': '-c', 'long': '--container', 'action': 'store', 'dest': 'containerFormat', 'default': '0', 'help' : 'Container format' },
                           { 'short': '-v', 'long': '--videocodec', 'action': 'store', 'dest': 'videoCodec', 'default': '0', 'help' : 'Video Codec Choice Index' },
                           { 'short': '-1', 'long': '--videocodecopts', 'action': 'store', 'dest': 'videoFirstPassOpts', 'default': '', 'help' : 'Video Codec Option String - Pass 1' },
                           { 'short': '-2', 'long': '--videocodecoptspass2', 'action': 'store', 'dest': 'videoSecondPassOpts', 'default': '', 'help' : 'Video Codec Option String - Pass 2' },
                           { 'short': '-f', 'long': '--videofilter', 'action': 'store', 'dest': 'videoFilter', 'default': 'pp=fd', 'help': 'Video Filter String' },
                           { 'short': '-T', 'long': '--twopass', 'action': 'store', 'dest': 'twoPassVideo', 'default': '0', 'help' : 'Two Pass Video Choice Index' },
                           { 'short': '-a', 'long': '--audiocodec', 'action': 'store', 'dest': 'audioCodec', 'default': '0', 'help' : 'Audio Codec Choice Index' },
                           { 'short': '-A', 'long': '--audiocodecopts', 'action': 'store', 'dest': 'audioCodecOptions', 'default': '', 'help' : 'Audio Codec Option String' },
                           { 'short': '-F', 'long': '--audiofilter', 'action': 'store', 'dest': 'audioFilter', 'default': '', 'help' : 'Audio Filter String' },
                           { 'short': '-t', 'long': '--threadcount', 'action': 'store', 'dest': 'threadCount', 'default': '2', 'help' : 'Max Simultaneous Encoding Jobs' },
                           { 'short': '-r', 'long': '--removecompleted', 'action': 'store', 'dest': 'removeCompleted', 'default': '1', 'help' : 'Remove Completed Job Choice Index' },                       
                           { 'short': '-s', 'long': '--savepath', 'action': 'store', 'dest': 'savePath', 'default': os.path.expanduser('~/Desktop'), 'help' : 'Save Encodings to Path' }, 
                           { 'short': '-x', 'long': '--filetemplate', 'action': 'store', 'dest': 'fileTemplate', 'default': '%s - %t.%x', 'help' : 'Output File Naming Template' },
                           { 'short': '-d', 'long': '--debuglevel', 'action': 'store', 'dest': 'debugLevel', 'default': defaultLogLevel, 'help': 'Debug Level: CRITICAL, FATAL, ERROR, WARNING, INFO or DEBUG'}
                           )
        # load preferences from disk
        self.loadPrefsFromDisk()
        
        # load preferences from CLI ; these override disk preferences
        self.loadPrefsFromCli()

        # push the prefs we've gathered in to the preferences frame
        self.populatePrefsToChildren()

        ###############################################################################
        # make mythtv connection and load data from it
        
        # a variable to stuff the program list in to
        self.programList = []

        # connect to mythtv
        if self.connectToMyth():

            # load recordings from myth
            self.loadRecordingsFromMyth()

    def __set_properties(self):
        # begin wxGlade: mainFrame.__set_properties
        self.SetTitle("MythRip - Main")
        self.SetSize((720, 430))
        self.mainFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        mainFrameStatusbar_fields = ["mainFrame_statusbar"]
        for i in range(len(mainFrameStatusbar_fields)):
            self.mainFrameStatusbar.SetStatusText(mainFrameStatusbar_fields[i], i)
        self.mainFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: mainFrame.__do_layout
        mainFrameSizer = wx.BoxSizer(wx.HORIZONTAL)
        mainFrameSizer.Add(self.mainFrameListCtrl, 1, wx.EXPAND, 0)
        self.SetSizer(mainFrameSizer)
        self.Layout()
        # end wxGlade

    def connectToMyth(self):        
        # establish our MythTV connection using the mythtv python bindings, push our preferences in to it
        try: 
            self.mythTV = mythtv.MythTV(force_db_opts=self.prefs)
            return True
        except Exception, e:
            self.showErrorDialog("Error connecting to MythTV", "Error connecting to MythTV:\n%s\nPlease alter your MythTV settings in the Preferences Dialog"%str(e))
            # it failed?  send the user to the preferences dialog
            self.preferencesFrame.Show()
            self.mythTV = False
            return False

        
    def loadRecordingsFromMyth(self):

        # delete any listctrl items currently present
        for i in range(len(self.programList)):
            self.mainFrameListCtrl.DeleteItem( self.mainFrameListCtrl.FindItemData(0, i) )

        # reset the programList
        self.programList = []

        # query recordings from the backend
        rawRecordings = self.mythTV.backendCommand('QUERY_RECORDINGS Play').split(mythtv.BACKEND_SEP)            

        if len(rawRecordings):
            # determine the record length and number of recordings present in the response
            numberRecordings = int(rawRecordings[0])        
            recordingLength = (len(rawRecordings) - 1) / numberRecordings

            # parse the output, stuff the results in to a list of Program objects

            for recording in range(numberRecordings):            
                idxStart = ( recording * recordingLength ) + 1    # plus one - offset for the beginning's "record count" record
                idxStop = ( recording + 1 ) * recordingLength     # stop at the next recording beginning

                recordingData = rawRecordings[idxStart:idxStop]

                log.Msg(DEBUG, "Recording data scrape: %s" % recordingData)

                self.programList.append( mythtv.Program( recordingData ) )
            
        # add recording count to the status bar
        self.mainFrameStatusbar.PushStatusText('Loaded %d recordings' % len(self.programList))
        
        
        # push in the ListCtrl data
        for i in range(len(self.programList)):
            program = self.programList[i]
            self.mainFrameListCtrl.InsertStringItem(i, program.title)
            self.mainFrameListCtrl.SetStringItem(i, 1, program.subtitle)
            self.mainFrameListCtrl.SetStringItem(i, 2, str(program.starttime))
            
            # unpack program flags to english strings
            flags = []
            for k,v in mythtv.PROGRAM_FLAGS.iteritems():
                if int(program.programflags) & v:
                    flags.append(k)

            self.mainFrameListCtrl.SetStringItem(i, 3, ', '.join(flags) )
            self.mainFrameListCtrl.SetItemData(i, i)  # set item datas to be the same as indexes initially
            
        # make nice column sizes
        self.mainFrameListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)
        
        # these variables are for preserving the listctrl sorting state
        self.lastColClick = 0
        self.sortToggler = 1

        # run an initial sort
        self.mainFrameListCtrl.SortItems( self.sortList ) 
        

    # this is the callback to sort the mainFrameListCtrl used by mainFrameListCtrl.SortItems
    def sortList(self, item1, item2):
        
        progLeft = self.programList[ item1 ]
        progRight = self.programList[ item2 ]
        
        if self.lastColClick == 0:
            if progLeft.title < progRight.title:
                return -1 * self.sortToggler
            elif progLeft.title == progRight.title:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 1:
            if progLeft.subtitle < progRight.subtitle:
                return -1 * self.sortToggler
            elif progLeft.subtitle == progRight.subtitle:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 2:
            if progLeft.starttime < progRight.starttime:
                return -1 * self.sortToggler
            elif progLeft.starttime == progRight.starttime:
                return 0
            else:
                return 1 * self.sortToggler

        return 0
    
    
    # this function returns a list of the mythtv Program objects that have been selected
    def getSelectedPrograms(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.mainFrameListCtrl.GetFirstSelected()
        while item != -1:
            program = self.programList[ self.mainFrameListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.mainFrameListCtrl.GetNextSelected(item)
        
        return returnList
    
    def addRecordingsToQueue(self):
        
        addcount = 0
        for program in self.getSelectedPrograms():
            self.encoderQueueFrame.addProgram(program)
            addcount += 1

        # automatically show encoder queue when we add to it
        if addcount > 0:
            self.encoderQueueFrame.Show()

        self.mainFrameStatusbar.PushStatusText('Added %d recordings to queue.' % addcount)
        

    def readPrefsFromDisk(self):
        prefs = {}
	cfgfile=os.path.expanduser('~')+'/.mythriprc'
	
	if not os.access(cfgfile,os.F_OK):
            log.Msg(WARNING, "%s not found, generating a new one set to application defaults" % cfgfile)
	    self.resetDiskPrefs()

        # read config file	    
	lines = file(cfgfile,'r').readlines()

	# parse config line by line
	for line in lines:
	    if line[0] != '#':
		delimiterAt = line.find(' ')
		if delimiterAt != -1:
		    opt = line[:delimiterAt].strip()
		    value = line[delimiterAt+1:].rstrip("\n")
		    
		    # try to interpret config options
		    if value.lower() == 'true':
			setvalue = True
		    elif value.lower() == 'false':
			setvalue = False
		    elif value.isdigit():
			setvalue = int(value)
		    else:
			setvalue = value
		    
		    prefs[opt] = setvalue

        return prefs

    def resetDiskPrefs(self):
	cfgfile=os.path.expanduser('~')+'/.mythriprc'
        cfg = file(cfgfile,'w+')
        cfg.write("# Automatically generated mythrip config file.\n\n")
        for option in self.optionMap:
            
            # we avoid writing the mysql options because they are automatically discovered by the self.findMythMysqlSettings
            if option.has_key('autoDiscover'):
                optionPrefix = "# "
            else:
                optionPrefix = ""

            cfg.write("# %s\n%s%s %s\n\n" % (option['help'], optionPrefix, option['dest'], option['default']))

        cfg.close()

    # write a dictionary of options to the configuration file
    def writePrefsToDisk(self):

	cfgFile=os.path.expanduser('~')+'/.mythriprc'
        
        cfg = file(cfgFile,'w+')
        cfg.write("# Automatically generated mythrip config file.\n\n")

        for option in self.optionMap:

            if self.prefs.has_key( option["dest"] ): # if the option appears in our prefs then save it
                cfg.write("## %s\n%s %s\n\n" % (option["help"], option["dest"], self.prefs[ option["dest"] ]))

        cfg.close()

    # read CLI optparse opts into the self.prefs, if they were given
    def loadPrefsFromCli(self):
	import optparse
	usage = "%prog [options]"
	
        cliparser = optparse.OptionParser(usage=usage)
	
	for option in self.optionMap:
            cliparser.add_option(option['short'],option['long'],action=option['action'],dest=option['dest'],help=option['help'])
	
	(options, files) = cliparser.parse_args()
        
	for option in self.optionMap:
            value = getattr(options, option['dest'])
            if value:
                self.prefs[option['dest']] = value

        # handle the special debuglevel config option

        # map string values to error levels
        levelMap = {"CRITICAL": mythtv.CRITICAL,
                    "FATAL": mythtv.FATAL,
                    "ERROR": mythtv.ERROR,
                    "WARNING": mythtv.WARNING,
                    "INFO": mythtv.INFO,
                    "DEBUG": mythtv.DEBUG}
        
        # if they didnt supply a default log level, then set the default
        if options.debugLevel == None:
            options.debugLevel = defaultLogLevel

        if levelMap.has_key( options.debugLevel ):
            log.setLevel( levelMap[ options.debugLevel ] )
            log.Msg(INFO, "Changed debug level to %s" % options.debugLevel)
        
    def populatePrefsToChildren(self):
        self.preferencesFrame.setPreferences( self.prefs )
        self.encoderQueueFrame.setPreferences( self.prefs )


        
    def loadPrefsFromDisk(self):
        
        # load the prefs from disk to self.prefs        
        self.prefs = self.readPrefsFromDisk()
        
        # if we did not load mysqlHost from disk, assume we should try and find the myth settings from the myth config files
        if not self.prefs.has_key("mysqlHost"):
            log.Msg(INFO, "mysqlHost not found in saved preferences; searching for your MythTV MySQL settings file.")

            mythSettings = self.findMythMysqlSettings()

            self.prefs.update( mythSettings )
            
        self.mainFrameStatusbar.PushStatusText('Preferences loaded.')
        
        
    def findMythMysqlSettings(self):
        # Try to read the mysql.txt file used by MythTV.
        # Order taken from libs/libmyth/mythcontext.cpp
        config_files = [
            '/usr/local/share/mythtv/mysql.txt',
            '/usr/share/mythtv/mysql.txt',
            '/usr/local/etc/mythtv/mysql.txt',
            '/etc/mythtv/mysql.txt',
            os.path.expanduser('~/.mythtv/mysql.txt'),
            ]
        
        if 'MYTHCONFDIR' in os.environ:
            config_locations.append('%s/mysql.txt' % os.environ['MYTHCONFDIR'])

        found_config = False
        for config_file in config_files:

            dbconn_host = None
            dbconn_name = None
            dbconn_user = None
            dbconn_pass = None
            dbconn_port = None

            if not os.access(config_file, os.R_OK): 
                continue

            for line in file(config_file):
                
                if line[0] != '#' and '=' in line:
                    equalPos = line.find('=')

                    key = line[0:equalPos]
                    val = line[equalPos+1:].strip()
                    
                    if key == "DBHostName":
                        dbconn_host = val
                    elif key == "DBPort":
                        dbconn_port = val
                    elif key == "DBName":
                        dbconn_name = val
                    elif key == "DBUserName":
                        dbconn_user = val
                    elif key == "DBPassword":
                        dbconn_pass = val

            if dbconn_host != None or dbconn_name != None or dbconn_user != None or dbconn_pass != None:
                log.Msg(INFO, "Using configuration file %s" % config_file)
                found_config = True
                break
        
        # we didn't find a config file, just bail out
        if not found_config:
            return {}
        
        
        return {"mysqlHost": dbconn_host,
                "mysqlPort": dbconn_port,
                "mysqlDB": dbconn_name,
                "mysqlUser": dbconn_user,
                "mysqlPassword": dbconn_pass}
    

    def showErrorDialog(self,title,message):
        errorDialog = wx.MessageDialog(parent=self, caption=title, message=message)
        errorDialog.ShowModal()

    def deleteRecordings(self,forget):
        progList = self.getSelectedPrograms()

        progCount = len(progList)

        if forget:
            actiontitle = "delete and re-record"
        else:
            actiontitle = "delete"

        reloadRecordings = False

        if progCount:

            if progCount == 1:
                message = "Really %s show '%s'?" % (actiontitle, progList[0])
            else:
                message = "Really %s %d shows?" % (actiontitle, progCount)

            wxmessage = wx.MessageDialog(parent=self, message=message, caption="MythRip - Confirm Delete", style=wx.YES_NO|wx.YES_DEFAULT|wx.ICON_QUESTION)
            
            if wxmessage.ShowModal() == wx.ID_YES:
                
                for program in progList:                    
                    self.mythTV.deleteRecording(program, forget)                                        
                
                reloadRecordings = True
                    
        if reloadRecordings:
            # reload the recording list
            self.loadRecordingsFromMyth()
        

    ###########################################################################
    # event handler land

        
    def onPrefsOK(self, event):

        # load the preferences from the prefs frame
        self.prefs = self.preferencesFrame.getPreferences()
        
        self.writePrefsToDisk()
        self.populatePrefsToChildren()

        self.mainFrameStatusbar.PushStatusText('Preferences saved.')

        event.Skip()


    def onPrefsCancel(self, event):
        
        # restore previous prefs settings if they cancel
        self.preferencesFrame.setPreferences( self.prefs )

        
    def onQuit(self, event): # wxGlade: mainFrame.<event_handler>
        
        runningThreads = []

        for threadID in self.encoderQueueFrame.threadOrder:            
            encoderThread = self.encoderQueueFrame.threads[ threadID ]            
            if encoderThread.state == "running":
                runningThreads.append(threadID)

        if len(runningThreads):            
            message = "%d thread(s) are running now.  Terminate them and quit?" % len(runningThreads)
            wxmessage = wx.MessageDialog(parent=self, message=message, caption="MythRip - Confirm Quit", style=wx.YES_NO|wx.YES_DEFAULT|wx.ICON_QUESTION)
            if wxmessage.ShowModal() == wx.ID_YES:
                self.encoderQueueFrame.abortThreadsAndQuit( runningThreads )

        else:

            sys.exit()


    def onColClick(self, event): # wxGlade: mainFrame.<event_handler>

        clickedCol = event.GetColumn()

        if (clickedCol == self.lastColClick):
            self.sortToggler *= -1
        else:
            self.sortToggler = 1

        self.lastColClick = clickedCol
        
        self.mainFrameListCtrl.SortItems( self.sortList ) 

        event.Skip()


    def onContextMenuSelection(self, event):        
        selectedMenuItem = self.contextMenuEntriesById[ event.GetId() ]
        if selectedMenuItem == "Encode":
            self.addRecordingsToQueue()
        event.Skip()
        
    def onQueue(self, event): # wxGlade: mainFrame.<event_handler>        
        self.encoderQueueFrame.Show()
        event.Skip()

    def onEncode(self, event): # wxGlade: mainFrame.<event_handler>
        self.addRecordingsToQueue()
        event.Skip()

    def onDelete(self, event): # wxGlade: mainFrame.<event_handler>        
        self.deleteRecordings(forget=False)
        event.Skip()

    def onDeleteRerecord(self, event): # wxGlade: mainFrame.<event_handler>
        self.deleteRecordings(forget=True)
        event.Skip()

    def onPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        self.preferencesFrame.Show()
        event.Skip()

    def onReload(self, event): # wxGlade: mainFrame.<event_handler>
        if not self.mythTV:
            self.connectToMyth()
            
        if self.mythTV:
            self.loadRecordingsFromMyth()
        else:
            self.mainFrameStatusbar.PushStatusText('No recordings loaded.')

        event.Skip()

    def onAbout(self, event): # wxGlade: mainFrame.<event_handler>
        self.aboutFrame.Show()
        event.Skip()


    def onView(self, event): # wxGlade: mainFrame.<event_handler>
        
        program = self.getSelectedPrograms()[0]
        
        filename = os.path.join(self.prefs['mythtvRecordingPath'], program.filename.split('/')[3:][0]) 

        failed = False
        
        if os.access(filename, os.R_OK):
            cmd = [ self.prefs['playerPath'], os.path.join(self.prefs['mythtvRecordingPath'], program.filename.split('/')[3:][0]) ]
            try:
                subprocess.call(cmd)
            except OSError, e:
                failed = True
                failMessage = "Failed spawning process:\n\n%s\n\n%s" % (" ".join(cmd), e)
        else:
            failed = True
            failMessage = "Could not access file:\n\n%s\n\nCheck 'MythTV Recording Path' in preferences" % filename

        if failed:
            wxmessage = wx.MessageDialog(parent=self, caption="MythRip - Playback Error", message=failMessage)
            wxmessage.ShowModal()

        event.Skip()

    def onItemRightClick(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onItemRightClick' not implemented"
        event.Skip()

# end of class mainFrame





class aboutFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: aboutFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.aboutFrameContents = wx.StaticText(self, -1, "About MythRIP:", style=wx.ALIGN_CENTRE)
        self.versionLabel = wx.StaticText(self, -1, "MythRip v0.0")
        self.static_line_4 = wx.StaticLine(self, -1)
        self.aboutFrameCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.aboutFrameCloseButton)
        # end wxGlade

        self.versionLabel.SetLabel(mythripVersionString)

    def __set_properties(self):
        # begin wxGlade: aboutFrame.__set_properties
        self.SetTitle("MythRip - About")
        self.SetSize((189, 109))
        self.aboutFrameCloseButton.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: aboutFrame.__do_layout
        aboutFrameSizer = wx.BoxSizer(wx.VERTICAL)
        aboutFrameSizer.Add(self.aboutFrameContents, 0, wx.BOTTOM|wx.EXPAND, 0)
        aboutFrameSizer.Add(self.versionLabel, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 11)
        aboutFrameSizer.Add(self.static_line_4, 0, wx.EXPAND, 0)
        aboutFrameSizer.Add(self.aboutFrameCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(aboutFrameSizer)
        self.Layout()
        # end wxGlade

    def onCloseButton(self, event): # wxGlade: aboutFrame.<event_handler>
        self.Hide()
        event.Skip()

# end of class aboutFrame



class encoderQueueFrame(wx.Frame):
    def __init__(self, *args, **kwds):

        toolbarDetails = wx.NewId()
        toolbarCleanup = wx.NewId()
        toolbarStop = wx.NewId()
        toolbarUp = wx.NewId()
        toolbarDown = wx.NewId()
        toolbarPrefs = wx.NewId()

        # begin wxGlade: encoderQueueFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Tool Bar
        self.encoderQueueFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.encoderQueueFrameToolbar)
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarDetails, "Details", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-page-setup.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "View details of selected thread(s)", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarStop, "Stop", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-cancel.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Stop selected thread(s)", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarUp, "Up", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-up.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected thread(s) up", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarDown, "Down", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-down.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected thread(s) down", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarCleanup, "Clean Up", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/edit-clear.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Remove all completed, failed and aborted threads", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarPrefs, "Preferences", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Show queue preferences", "")
        # Tool Bar end
        self.encoderQueueListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.SUNKEN_BORDER)
        self.encoderQueueCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_TOOL, self.onThreadDetail, id=toolbarDetails)
        self.Bind(wx.EVT_TOOL, self.onToolbarStop, id=toolbarStop)
        self.Bind(wx.EVT_TOOL, self.onToolbarUp, id=toolbarUp)
        self.Bind(wx.EVT_TOOL, self.onToolbarDown, id=toolbarDown)
        self.Bind(wx.EVT_TOOL, self.onToolbarCleanup, id=toolbarCleanup)
        self.Bind(wx.EVT_TOOL, self.onToolbarPrefs, id=toolbarPrefs)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.onItemRightClick, self.encoderQueueListCtrl)
        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.encoderQueueCloseButton)
        # end wxGlade
        
        ##########################
        
        # this variable tracks the thread IDs .. 
        # because I use this style of identifying threads eventually the ID would wrap.. so there's the app's max threads limit!
        self.nextThreadID = 0

        # this variable contains a list of encoder jobs, including their thread handles
        self.threads = {}

        # this tracks the order in which the threads appear in the listctrl
        self.threadOrder = []

        # this holds our app preferences
        self.prefs = {}

        # this is set when we are told to abort all jobs & quit.  if tick sees it, it checks that all threads are dead, then quit the app
        self.quitFlag = False

        # set up the listctrl
        self.encoderQueueListCtrl.InsertColumn(0, "Show")
        self.encoderQueueListCtrl.InsertColumn(1, "Episode")
        self.encoderQueueListCtrl.InsertColumn(2, "Air Time")
        self.encoderQueueListCtrl.InsertColumn(3, "Progress")
        
        # connect up a handler to update the GUI upon events from the encoder threads
        EVT_ENCODER(self, self.onEncoderEvent)    
                
        # start the updater timer
        self.genericTickingTimer = genericTickingTimer()
        self.genericTickingTimer.setFrameHandle(self)
        self.genericTickingTimer.Start(milliseconds=2000)

    def __set_properties(self):
        # begin wxGlade: encoderQueueFrame.__set_properties
        self.SetTitle("MythRip - Encoding Queue")
        self.SetSize((640, 300))
        self.encoderQueueFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderQueueFrame.__do_layout
        encoderQueueSizer = wx.BoxSizer(wx.VERTICAL)
        encoderQueueSizer.Add(self.encoderQueueListCtrl, 1, wx.EXPAND, 0)
        encoderQueueSizer.Add(self.encoderQueueCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(encoderQueueSizer)
        self.Layout()
        # end wxGlade

    ##########################################################################################
    # meat

    def addProgram(self,program):
        
        # grab the next thread id
        threadID = self.nextThreadID
        
        # prepare the thread id for the thread after this one
        self.nextThreadID += 1
        
        # create the thread.  
        self.threads[threadID] = encoderThread(program, threadID, self)
        self.threadOrder.append(threadID)
        
        self.onThreadPoolChange()

    def getSelectedThreads(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:
            threadID = self.threads[ self.encoderQueueListCtrl.GetItemData(item) ]                        
            returnList.append(threadID)
            item = self.encoderQueueListCtrl.GetNextSelected(item)
        
        return returnList


    def resizeEncoderQueueListCtrl(self):
        self.encoderQueueListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)

    def setPreferences(self, prefs):
        log.Msg(INFO, "Encoder queue frame received new preferences")
        self.prefs = prefs
        
    def reorderThreads(self, direction):

        # make a list of selected threads so we can restore it after we redraw the listctrl
        selThreads = []

        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:

            selThreadID = self.encoderQueueListCtrl.GetItemData(item)

            selThreads.append(selThreadID)
            
            # make a copy of threadOrder for us to mutilate
            newThreadOrder = self.threadOrder

            # loop through threadOrder indexes
            idx=0
            maxIdx = len(self.threadOrder)
            for idx in range(maxIdx):
                                
                if selThreadID == self.threadOrder[idx]:
                    
                    if direction == "up" and idx > 0:
                        # swap entries up
                        tmpThread = newThreadOrder[idx-1] 
                        newThreadOrder[idx-1] = newThreadOrder[idx]
                        newThreadOrder[idx] = tmpThread
                        break

                    elif direction == "down" and idx+1 < maxIdx:
                        # swap entries down
                        tmpThread = newThreadOrder[idx+1]
                        newThreadOrder[idx+1] = newThreadOrder[idx]
                        newThreadOrder[idx] = tmpThread
                        break

                idx += 1

            self.threadOrder = newThreadOrder

            item = self.encoderQueueListCtrl.GetNextSelected(item)

        # now that we are done re-ordering, redraw the threads
        self.onThreadPoolChange(selThreads)


    def abortThreadsAndQuit(self, abortThreads):
        
        for threadID in abortThreads:
            self.threads[ threadID ].doCommand = "abort"
            
        self.quitFlag = True

    def removeCompletedItems(self):
        # lists to hold indexes to be deleted from self.threads & self.threadOrder
        nukeThreads = []

        for idx in range(len(self.threadOrder)):
            threadID = self.threadOrder[idx]

            if self.threads[threadID].state in ("aborted","completed","failed","failedAndAcknowledged"):
                
                nukeThreads.append(threadID)
        
        for threadID in nukeThreads:
        
            # we need to discover the idx anew for each thread, since the indexes are liable to change
            for idx in range(len(self.threadOrder)):
                if self.threadOrder[idx] == threadID:
                    del self.threadOrder[idx]
                    break

            # if we havent already nuked it, nuke it from self.threads too
            if self.threads.has_key(threadID):
                del self.threads[ threadID ]

        if len(nukeThreads) > 0:
            self.onThreadPoolChange()


    ##########################################################################################
    # event handlers

    # called by hand any time the threads list is added from, subtracted to, or re-ordered
    def onThreadPoolChange(self,selectedThreads = []):
        
        self.encoderQueueListCtrl.DeleteAllItems()

        for threadID in self.threadOrder:

            # for threadID, encoderThread in self.threads.iteritems():            
            newListIndex = self.encoderQueueListCtrl.GetItemCount()

            if self.threads.has_key(threadID):
                program = self.threads[threadID].program

                # insert the new list ctrl item
                self.encoderQueueListCtrl.InsertStringItem(newListIndex, program.title)
                self.encoderQueueListCtrl.SetStringItem(newListIndex, 1, program.subtitle)
                self.encoderQueueListCtrl.SetStringItem(newListIndex, 2, str(program.starttime))
                self.encoderQueueListCtrl.SetStringItem(newListIndex, 3, self.threads[threadID].lastListMessage)
                self.encoderQueueListCtrl.SetItemData(newListIndex, threadID) # store the thread id with each item

                # restore the user's selection
                if threadID in selectedThreads:
                    item = self.encoderQueueListCtrl.FindItemData(0, threadID)
                    self.encoderQueueListCtrl.SetItemState( item, state=wx.LIST_STATE_SELECTED, stateMask=wx.LIST_STATE_SELECTED)
            
        # keep the table clean with some column resizing
        self.resizeEncoderQueueListCtrl()


    # called from the genericTickingTimer
    def onTimerTick(self):
        
        # 0 is yes
        if self.prefs['removeCompleted'] == 0: 
            self.removeCompletedItems()
        
        # this is where the encoder queue determines when it needs to start more encoders
        while True:
        
            pendingThreads = []

            threadCount = len(self.threadOrder)

            runningThreads = 0

            for threadID in self.threadOrder:

                encoderThread = self.threads[threadID]

                # count how many threads are running now
                if encoderThread.state == "running":
                    runningThreads += 1  

                # make a list of threads that are waiting to start
                elif encoderThread.state == "new":
                    pendingThreads.append( encoderThread )

                elif encoderThread.state == "failed":
                    encoderThread.state = "failedAndAcknowledged"
                    frame = threadDetailFrame(parent=self)
                    frame.setThreadID( threadID )
                    frame.Show()
                    
                
            # if self.quitFlag is set, we are to terminate once no threads are left running
            if runningThreads == 0 and self.quitFlag:
                sys.exit()

            # if there are less threads running than the threadCount, then start some until thats no longer true    
            if runningThreads < self.prefs['threadCount'] and len(pendingThreads):
                pendingThreads[0].start()
                time.sleep(0.1) # sleep long enough for the thread to start and get its 'state' variable set to 'running' so we dont try to run it twice
            else:
                # the only way out of the while True is for there to be no more threads that need starting
                break
                    

    # when an encoder event is received this is called
    def onEncoderEvent(self, event):
        
        # we pretty much need this no matter what
        listCtrlIndex = self.encoderQueueListCtrl.FindItemData(0,event.threadID)        
        self.encoderQueueListCtrl.SetStringItem(listCtrlIndex, 3, event.listMessage)
        self.resizeEncoderQueueListCtrl()
            
        event.Skip()

    def onCloseButton(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.Hide()
        event.Skip()

    def onToolbarUp(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.reorderThreads("up")
        event.Skip()

    def onToolbarDown(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.reorderThreads("down")
        event.Skip()

    def onToolbarCleanup(self, event): # wxGlade: encoderQueueFrame.<event_handler>        
        self.removeCompletedItems()
        event.Skip()

    def onToolbarPrefs(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.GetParent().preferencesFrame.Show()
        self.GetParent().preferencesFrame.preferencesNotebook.ChangeSelection(2)
        event.Skip()

    def onToolbarStop(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:
            threadID = self.encoderQueueListCtrl.GetItemData(item)

            # abort if its running (dont set abort flag on waiting threads)
            if self.threads[ threadID ].state == "running":
                self.threads[ threadID ].setCommand("abort")

            item = self.encoderQueueListCtrl.GetNextSelected(item)
        event.Skip()

    def onItemRightClick(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onItemRightClick' not implemented"
        event.Skip()

    def onThreadDetail(self, event): # wxGlade: encoderQueueFrame.<event_handler>

        for thread in self.getSelectedThreads():
            frame = threadDetailFrame(parent=self)
            frame.setThreadID( thread.threadID )
            frame.Show()
        
        event.Skip()

# end of class encoderQueueFrame

###################################################################
# encoder thread land

# get an ID for an "encoder" event 
EVT_ENCODER_ID = wx.NewId()

# define a macro for connecting event handlers to the encoder events
def EVT_ENCODER(theWin, theFunc):
    theWin.Connect(-1, -1, EVT_ENCODER_ID, theFunc)

# a simple event to throw out of the encoder
class encoderEvent(wx.PyEvent):
    def __init__(self, threadID, threadState, listMessage):
        wx.PyEvent.__init__(self)
        self.SetEventType(EVT_ENCODER_ID)
        self.threadID = threadID
        self.threadState = threadState
        self.listMessage = listMessage

# the encoder thread itself
class encoderThread(threading.Thread):
    
    def __init__(self, program, threadID, notifyWindow):
        
        self.notifyWindow = notifyWindow
        self.program = program
        self.threadID = threadID
        self.doCommand = "none"
        
        self.state = "new"
        
        self.lastListMessage = "Waiting"

        # False indicates the process was never started
        self.mencoderProcess = False
        self.mythtranscodeProcess = False

        # no errors have occurred.. yet..
        self.mencoderProcessError = False
        self.mythtranscodeProcessError = False
        
        # this is for scraping video parameters out of mythtranscode output
        self.mythtranscodeStdout = ""

        self.mythtranscodeFifoDir = ""

        # source video/audio properties
        self.vidWidth = ""
        self.vidHeight = ""
        self.vidFramerate = ""
        self.audioRate = ""
        self.audioChannels = ""

        self.currentPass = 0
        self.currentFrame = 0
        self.currentFPS = 0
        self.maxFrame = 0
        
        # make a copy of the preferences at the time the thread was created to avoid them changing mid-stream if the user
        # alters preferences during a thread's execution
        self.prefs = self.notifyWindow.prefs 

        # boolean describing if two-pass is enabled ; 0 is yes
        self.twoPass = (self.prefs["twoPassVideo"] == 0)

        self.mencoderCmd = {}

        self.mythtranscodeCmd = False

        # initialize the passlog dir 
        self.clearPasslogDir()

        # load parent constructor
        threading.Thread.__init__(self)
    
        
    def run(self):

        self.state = "running"
        
        self.startMythtranscode()

        # now we need to examine the mythtranscode output to determine the video and audio parameters .. 
        # we wait up to 10 seconds for them to show up in self.mythtranscodeStdout
        for i in range(10): 

            # mythtranscode isnt even running.. just bail
            if self.mythtranscodeProcessError == True or self.mythtranscodeProcess.poll() != None:
                log.Msg(WARNING, "Thread %d: mythtranscode launch failure precludes gathering of AV parameters from mythtranscode output; thread will fail" % self.threadID)
                break

            self.parseSubprocessOutput(mtGathering = True)
            # print self.mythtranscodeStdout,"\n-----------------------------------------"
            if re.search(".*Stream.*Audio.*kb/s", self.mythtranscodeStdout):
                log.Msg(INFO, "Thread %d: Found file AV parameters! Beginning extraction from mythtranscode output" % self.threadID)
                (self.vidWidth, self.vidHeight, self.vidFramerate) = re.findall('.*Stream #.* ([0-9]+)x([0-9]+).* ([0-9]+\.[0-9]+) tb',self.mythtranscodeStdout)[0]
                (self.audioRate, audioChanMode) = re.findall('.*Stream #.* ([0-9]+) Hz, ([A-Za-z]+)',self.mythtranscodeStdout)[0]
                if audioChanMode == "stereo":
                    self.audioChannels = "2"
                else:
                    # TODO im not sure what other values are produced in this slot
                    self.audioChannels = "1"
                break

            time.sleep(1)

        
        if self.twoPass:
            mencCount = 2
        else:
            mencCount = 1


        # loop as many times as we are supposed to start mencoder
        # - zip through the upcoming passes and generate the mencoderCmds in advance
        for i in range(mencCount):
            self.currentPass = i+1
            self.mencoderCmd[self.currentPass] = self.buildMencoderCmd()

        # loop as many times as we are supposed to start mencoder
        for i in range(mencCount):

            self.currentPass = i+1

            log.Msg(INFO, "Thread %d: Entering pass %d with doCommand %s, state %s" % ( self.threadID, self.currentPass, self.doCommand, self.state))

            # if we were told to abort, escape the loop failedAndAcknowledged
            if self.doCommand == "abort" or self.state in ("failed","failedAndAcknowledged"):
                log.Msg(WARNING, "Thread %d: Thread is aborted or failed, pass %d skipped" % (self.threadID, self.currentPass))
                break

            # if this isnt the first loop, we can't count on mythtranscode being started!  we need to start a new one for subsequent passes
            if self.currentPass != 1:
                self.startMythtranscode()

            # if mythtranscode failed outright, just report the error and escape the encoding loop
            if self.mythtranscodeProcessError:
                self.reportSubprocessFailure( self.prefs['mythtranscodePath'], self.lastMythtranscodeStderr )
                log.Msg(WARNING, "Thread %d: Thread failed, pass %d skipped" % (self.threadID, self.currentPass))
                break

            self.stdoutSockMenc, stdoutChildSockMenc = socket.socketpair() 
            self.stderrSockMenc, stderrChildSockMenc = socket.socketpair() 
            self.stdoutSockMenc.settimeout(0.1)
            self.stderrSockMenc.settimeout(0.1)

            self.mencoderProcessError = False
            try:
                self.mencoderProcess = subprocess.Popen(self.mencoderCmd[self.currentPass], stdin=None, stdout=stdoutChildSockMenc.fileno(), stderr=stderrChildSockMenc.fileno())
            except OSError, e:

                # if this fails it will be detected and reported on elsewhere
                self.lastMencoderStderr = "Failed spawning process: %s" % e
                self.mencoderProcessError = True
                pass
                

            self.setRunningStatus( "Encoder started." )
            
            # these need to be initialized for the loop below
            self.mythtranscodeRunning = True
            self.mencoderRunning = True
        
            stopRunning = False
            while not stopRunning:

                self.parseSubprocessOutput()
                
                errorSent = False

                # if a process *was* running, but is not running now, we should decide if its an error and report back to the user
                if self.mythtranscodeRunning:
                    
                    self.updateProcessRunningFlags("mythtranscode")

                    if ( not self.mythtranscodeRunning ) and ( self.mythtranscodeProcessError or self.mythtranscodeProcess.returncode != 0 ):
                        self.reportSubprocessFailure( self.prefs['mythtranscodePath'], self.lastMythtranscodeStderr )
                        errorSent = True
                
                if self.mencoderRunning:

                    self.updateProcessRunningFlags("mencoder")
                    
                    if ( not self.mencoderRunning ) and ( self.mencoderProcessError or self.mencoderProcess.returncode != 0 ):
                        if not errorSent: # dont send another error report about mencoder if mythtranscode already failed
                            self.reportSubprocessFailure( self.prefs['mencoderPath'], self.lastMencoderStderr )
                        
                # end the pass if mythtranscode and mencoder are not both running, or if we've been told to abort
                endPass = (not ( self.mythtranscodeRunning and self.mencoderRunning ) ) or self.doCommand == "abort"

                if endPass:

                    self.setRunningStatus( "Waiting for all subprocesses to end" )
                    
                    # wait 5 seconds for things to normalize
                    for sec in range(15):
                            
                        # if mythtranscodeProcessError is False and poll() returns None, the process is alive
                        self.updateProcessRunningFlags()
                        
                        if not self.mythtranscodeRunning and not self.mencoderRunning:
                            log.Msg(INFO, "Thread %d: All subprocess dead, terminating thread execution" % self.threadID)
                            stopRunning = True
                            break

                        if sec > 3:

                            # read again
                            self.updateProcessRunningFlags()

                            self.setRunningStatus( "Actively stopping subprocesses" )
                            
                            log.Msg(INFO, "Thread %d: Aggressive mode running at second %d" % (self.threadID, sec))

                            if sec > 7:
                                usesig = signal.SIGKILL
                                usesigname = "SIGKILL"
                            else:
                                usesig = signal.SIGTERM
                                usesigname = "SIGTERM"

                            if self.mythtranscodeRunning:
                                log.Msg(INFO, "Thread %d: Aggressive mode: mencoder died but mythtranscode continues to run, sending %s to mythtranscode." % (self.threadID, usesigname))
                                os.kill(self.mythtranscodeProcess.pid, usesig)

                            if self.mencoderRunning:
                                log.Msg(INFO, "Thread %d: Aggressive mode: mythtranscode died but mencoder continues to run, sending %s to mencoder." % (self.threadID, usesigname))
                                os.kill(self.mencoderProcess.pid, usesig)


                        # wait a second.. both processes should be disolving more or less simultaneously
                        time.sleep(1);

                    # parse subprocess output one last time
                    self.parseSubprocessOutput()
                
                # wait a second before checking the subprocess again
                time.sleep(0.1)

        self.cleanUp()

        if self.doCommand == "abort":
            self.sendEncoderEvent( "stopped", "Aborted" )
            self.state = "aborted"
        elif self.state in ("failed","failedAndAcknowledged"):
            self.sendEncoderEvent( "stopped", "Failed (see thread detail window)" )
        else:
            self.sendEncoderEvent( "stopped", "Completed" )
            self.state = "completed"


    def updateProcessRunningFlags(self,which="both"):
        if which in ("both","mythtranscode"):
            self.mythtranscodeRunning = ( self.mythtranscodeProcessError == False and self.mythtranscodeProcess.poll() == None )

        if which in ("both","mencoder"):
            self.mencoderRunning = ( self.mencoderProcessError == False and self.mencoderProcess.poll() == None )

    def reportSubprocessFailure(self, processName, failureDetails):
        if self.state == "failedAndAcknowledged":
            return

        # set the message first so parent threads dont get a failed state when theres no message set
        self.failedMessage = "%s returned a failure code in pass %d\n\nDetails:\n%s" % (processName, self.currentPass, failureDetails)
        self.state = "failed"

        log.Msg(WARNING, "Thread %d: Subprocess failure: %s" % (self.threadID, self.failedMessage))

    def clearPasslogDir(self, renewMode=True):
        log.Msg(INFO, "Thread %d: Clearing passlog directory" % self.threadID)

        # get directory for our fifos to live in
        self.passlogDir = '/tmp/mythrip-%d-passlog' % self.threadID
        
        if os.path.isdir(self.passlogDir):
            try:
                shutil.rmtree(self.passlogDir)
            except Exception, e:
                msg = "Could not remove stale passlog directory: %s" % e
                
                log.Msg(WARNING, "Thread ID %d: %s" % (self.threadID, msg))
                
                self.sendEncoderEvent("failed",msg)
                self.state = "failed"

        if renewMode:
            try:
                os.mkdir(self.passlogDir)
            except Exception, e:
                self.sendEncoderEvent("failed","Failed creating passlog directory: %s" % e)
                self.state = "failed"

        
    def clearFifoDir(self, renewMode=True):
        log.Msg(INFO, "Thread %d: Clearing FIFO directory" % self.threadID)

        # get directory for our fifos to live in
        self.mythtranscodeFifoDir = '/tmp/mythrip-%d-fifo' % self.threadID

        # we'll try killing that fifo dir 10 times.
        for sec in range(10):
            
            self.setRunningStatus( "Waiting for mythtranscode fifos" )

            if os.path.isdir(self.mythtranscodeFifoDir):
                try:
                    shutil.rmtree(self.mythtranscodeFifoDir)
                except Exception, e:
                    msg = "Could not remove stale fifo directory: %s" % e

                    log.Msg(WARNING, "Thread ID %d: %s" % (self.threadID, msg))

                    self.sendEncoderEvent("failed",msg)
                    self.state = "failed"
            else:
                break

            time.sleep(1)

        if renewMode:
            try:
                os.mkdir(self.mythtranscodeFifoDir)
            except Exception, e:
                self.sendEncoderEvent("failed","Failed creating fifo directories: %s" % e)
                self.state = "failed"

    def parseSubprocessOutput(self,mtGathering = False):
        
        streamDict = {"mt": [self.stdoutSockMT, self.stderrSockMT]}
        
        # if we are in mtGathering mode, we ignore menc
        if not mtGathering:
            streamDict["menc"] = [self.stdoutSockMenc, self.stderrSockMenc]
        
        # read from all processes
        for (name, (stdoutSock,stderrSock)) in streamDict.iteritems():
            newstdout = ""
            newstderr = ""
            
            try:
                newstdout = stdoutSock.recv(1024)
                newstderr = stderrSock.recv(1024)

            except socket.timeout, e:
                pass 

            # print em out if there was anything
            if len(newstdout):
                # if this is mythtranscode, we need to gather up all the output so we may parse out video and audio parameters
                if mtGathering:
                    self.mythtranscodeStdout += newstdout
                    
                # parse mencoder output for the queue listctrl
                if name == "menc":
                    # Pos:   6.1s    192f ( 0%) 35.13fps Trem:   0min   0mb  A-V:0.033 [715:1536]
                    match = re.findall('Pos\: +([0-9\.]+)s +([0-9]+)f \(([0-9 ]+%)\) +([0-9\.]+)fps',newstdout) # pull mencoder output
                    if match:
                        self.currentFrame = int(match[0][1])
                        self.currentFPS = float(match[0][3])

                # because we just receive data periodically we might be getting only pieces of full output lines.. but this is just a progress indicator, its good enough
                if name == "mt":
                    match = re.findall('.*Processed: [0-9]+ of ([0-9]+) frames',newstdout)
                    if match:
                        self.maxFrame = int(match[0])

                
                if self.currentFrame and self.maxFrame:
                    perc = self.currentFrame / float(self.maxFrame) * 100 

                    self.setRunningStatus("%d%% : Frame %d / %d : %0.02f fps" % (int(perc), self.currentFrame, self.maxFrame, self.currentFPS ) )

                elif self.currentFrame:
                    
                    self.setRunningStatus("0%% : Frame %d / ????: %0.02f fps" % (self.currentFrame, self.currentFPS) )

                self.lastStdout = newstdout
                                               
                # print "STDOUT %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstdout)
                    
            if len(newstderr):
                
                if name == 'menc':
                    self.lastMencoderStderr = newstderr
                else:
                    self.lastMythtranscodeStderr = newstderr
                    

                # print "STDERR %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstderr)
                pass


    def buildMencoderCmd(self):
                
        # now fire up mencoder reading from mythtranscode's fifo
        mencoderCmd = [self.prefs['mencoderPath'],
                       '-noskip','-idx',
                       os.path.join(self.mythtranscodeFifoDir, 'vidout'),
                       '-audiofile', os.path.join(self.mythtranscodeFifoDir,'audout'),
                       '-demuxer','20','-audio-demuxer','20',
                       '-rawvideo','w=%s:h=%s:fps=%s' % (self.vidWidth, self.vidHeight, self.vidFramerate),
                       '-rawaudio','rate=%s:channels=%s' % (self.audioRate, self.audioChannels),
                       '-demuxer','26']

        ### Audio
        
        # dont process sound on first pass of a two-pass encode
        # if twoPass and passNumber == 1:
        # mencoderCmd.extend( ['-nosound'] )
        # else:
        mencoderCmd.extend( ['-oac','copy'] )

        if len(self.prefs['audioFilter']):
            mencoderCmd.extend( ['-af',self.prefs['audioFilter']] )
            
        ### Video

        # load this pass' options
        if self.twoPass:

            if self.currentPass == 1:
                encOpts = self.prefs['videoFirstPassOpts']+':pass=1'
            else:
                encOpts = self.prefs['videoSecondPassOpts']+':pass=2'

        else:

            if self.currentPass == 1:
                encOpts = self.prefs['videoFirstPassOpts']
            else:
                encOpts = self.prefs['videoSecondPassOpts']

                
        # 0 is xvid
        if self.prefs['videoCodec'] == 0:                 
            mencoderCmd.extend( ['-ovc','xvid','-xvidencopts',encOpts] )
            
        # 1 is x264
        elif self.prefs['videoCodec'] == 1:            
            mencoderCmd.extend( ['-ovc','x264','-x264encopts',encOpts] )  # :pass=1', # 'subq=5:8x8dct:frameref=2:bframes=3:b_pyramid:weight_b',
            
        if len(self.prefs['videoFilter']):            
            mencoderCmd.extend( ['-vf',self.prefs['videoFilter']] )

        # debugging
        mencoderCmd.extend( ['-frames','200'] )

        if self.twoPass:

            if self.currentPass == 1:
                mencoderCmd.extend( ['-o', '/dev/null'] )
            else:
                self.makeOutputFilename()
                mencoderCmd.extend( ['-o', self.outputFile] )

            # in two pass mode, always pass the logfile arg
            mencoderCmd.extend( ['-passlogfile', os.path.join( self.passlogDir, 'pass.log' ) ] )
        else:
            outputFile = self.makeOutputFilename()
            mencoderCmd.extend( ['-o', self.outputFile] )
            
        return mencoderCmd
    
    def startMythtranscode(self):
        
        self.clearFifoDir()

        # fire up mythtranscode turbo=1:subq=1:frameref=1
        self.mythtranscodeCmd = [self.prefs['mythtranscodePath'],
                            '--showprogress',
                            '-p','autodetect',
                            '-c',str(self.program.chanid),
                            '-s',self.program.recstartts.strftime('%Y-%m-%dT%H:%M:%S'),
                            '-f',self.mythtranscodeFifoDir,
                            '--verbose','libav' # we pull video parameters out of this verbose output mode
                            ]
        
        if self.prefs["useMythCutlist"] == 0:
            self.mythtranscodeCmd.append('--honorcutlist')
        
        # use sockets for the subprocess file objects so we can read from stdout/stderr in a non-blocking fashion
        self.stdoutSockMT, stdoutChildSockMT = socket.socketpair() 
        self.stderrSockMT, stderrChildSockMT = socket.socketpair() 
        self.stdoutSockMT.settimeout(0.1)
        self.stderrSockMT.settimeout(0.1)

        log.Msg(INFO, "Thread %d: Starting mythtranscode" % self.threadID)

        self.mythtranscodeProcessError = False
        try:
            self.mythtranscodeProcess = subprocess.Popen(self.mythtranscodeCmd, stdin=None, stdout=stdoutChildSockMT.fileno(), stderr=stderrChildSockMT.fileno())
        except OSError, e:
            # if this fails it will be detected and reported on elsewhere
            self.lastMythtranscodeStderr = "Failed spawning process: %s" % e
            self.mythtranscodeProcessError = True

            # dont bother with the fifo dir if the command failed
            return

        # 5 second loop
        for i in range(10):

            # mythtranscode isnt even running.. just bail
            if self.mythtranscodeProcess.poll() != None:
                log.Msg(WARNING, "Thread %d: mythtranscode quit running during FIFO directory scan" % self.threadID)
                break

            fifoPresent = self.isFifo( os.path.join(self.mythtranscodeFifoDir,'vidout') )
            if fifoPresent:
                log.Msg(INFO, "Thread %d: FIFO directory has appeared, mythtranscode start-up successful" % self.threadID)
                break

            time.sleep(1)


    # when called this func spits out the full path & filename for the new file..?
    def makeOutputFilename(self, iteration=0):

        templateMap = { '%s': "title",
                        '%e': "subtitle",
                        '%d': "description",
                        '%c': "category",
                        '%C': "channum",
                        '%T': "starttime",
                        '%E': "endtime",
                        '%i': "seriesid",
                        '%h': "hostname" }
        
        template = self.prefs["fileTemplate"]

        for (code, name) in templateMap.iteritems():

            value = getattr(self.program, name)
            
            template = template.replace(code, str(value))
            
        extension = 'avi'

        if iteration > 0:
            filename = '%s - Copy %d.%s' % (template, iteration, extension)
        else:
            filename = '%s.%s' % (template, extension)
            
        retrFile = os.path.join( self.prefs['savePath'], filename )

        if os.path.isfile(retrFile):
            return self.makeOutputFilename( iteration=(iteration+1) )
        else:
            log.Msg(INFO, "Thread %d: Output filename determined to be %s" % (self.threadID, retrFile))
            self.outputFile = retrFile

    # func called to update the encoder queue frame listctrl item
    def setRunningStatus(self,status):

        if self.currentPass > 0 and self.prefs["twoPassVideo"] == 0: # 0 is yes
            sendStat = "Pass %d : %s" % (self.currentPass, status)
        else:
            sendStat = status

        self.sendEncoderEvent( "running", sendStat )
        

    # func called by the main thread in order to issue commands
    def setCommand(self,command):
        self.doCommand = command

    def sendEncoderEvent(self, threadState, listMessage):
        self.lastListMessage = listMessage
        wx.PostEvent(self.notifyWindow, encoderEvent(self.threadID, threadState, listMessage))
        
    def isFifo(self,fn):
        return os.access(fn,os.R_OK) and stat.S_ISFIFO(os.stat(fn).st_mode)

    def cleanUp(self):
        self.clearFifoDir(renewMode=False) # clear fifo dir and don't regenerate it!
        self.clearPasslogDir(renewMode=False)
    
# a very simple timer to call a tick function in the encoder queue fraem
class genericTickingTimer(wx.Timer):
    
    def setFrameHandle(self,targetFrame):
        self.targetFrame = targetFrame

    def Notify(self):
        self.targetFrame.onTimerTick()

###########################################################################
    

class preferencesFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: preferencesFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.preferencesNotebook = wx.Notebook(self, -1, style=0)
        self.preferencesExternalProgramsPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesFilesPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesQueuePane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesEncodersPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesMythTVPane = wx.Panel(self.preferencesNotebook, -1)
        self.mysqlSettingsLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Settings: ")
        self.mysqlHostLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Hostname: ")
        self.mysqlHostText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlPortLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Port: ")
        self.mysqlPortText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlUserLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL User: ")
        self.mysqlUserText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlPasswordLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Password: ")
        self.mysqlPasswordText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mysqlDBNameLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MySQL Database Name: ")
        self.mysqlDBNameText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.mythOptionsLabel = wx.StaticText(self.preferencesMythTVPane, -1, "MythTV Options: ")
        self.useMythCutlistLabel = wx.StaticText(self.preferencesMythTVPane, -1, "Use Myth Cutlists: ")
        self.useMythCutlistChoice = wx.Choice(self.preferencesMythTVPane, -1, choices=["Yes", "No"])
        self.mythtvRecordingPath = wx.StaticText(self.preferencesMythTVPane, -1, "MythTV Recording Path: ")
        self.mythtvRecordingText = wx.TextCtrl(self.preferencesMythTVPane, -1, "")
        self.FileOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "File Options:")
        self.containerFormatLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Container Format: ")
        self.containerFormatChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["avi", "mkv"])
        self.videoOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Options: ")
        self.videoCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Video Codec: ")
        self.videoCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["xvid", "x264"])
        self.twoPassVideoLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Two-Pass Video: ")
        self.twoPassVideoChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["Yes", "No"])
        self.videoFirstPassOptsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "First Pass Options (): ")
        self.videoFirstPassOptsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.videoSecondPassOptsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Second Pass Options (): ")
        self.videoSecondPassOptsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.videoFilterStringLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Filter String (-vf): ")
        self.videoFilterStringText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.audioOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Options:")
        self.audioCodecLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec: ")
        self.audioCodecChoice = wx.Choice(self.preferencesEncodersPane, -1, choices=["passthrough", "mp3lame", "ogg", "whatever"])
        self.audioCodecOptionsLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Codec Options ():")
        self.audioCodecOptionsText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.audioFilterLabel = wx.StaticText(self.preferencesEncodersPane, -1, "Audio Filter String (-af): ")
        self.audioFilterText = wx.TextCtrl(self.preferencesEncodersPane, -1, "")
        self.threadCountLabel = wx.StaticText(self.preferencesQueuePane, -1, "Max Simultaneous Jobs: ")
        self.threadCountSpin = wx.SpinCtrl(self.preferencesQueuePane, -1, "", min=0, max=100)
        self.removeCompletedLabel = wx.StaticText(self.preferencesQueuePane, -1, "Remove Completed Jobs: ")
        self.removeCompletedChoice = wx.Choice(self.preferencesQueuePane, -1, choices=["Yes", "No"])
        self.savePathLabel = wx.StaticText(self.preferencesFilesPane, -1, "Save Encoded Videos In: ")
        self.savePathPicker = wx.DirPickerCtrl(self.preferencesFilesPane, -1)
        self.fileTemplateLabel = wx.StaticText(self.preferencesFilesPane, -1, "File Naming Template: ")
        self.fileTemplateText = wx.TextCtrl(self.preferencesFilesPane, -1, "")
        self.mencoderPathLabel = wx.StaticText(self.preferencesExternalProgramsPane, -1, "Path to mencoder: ")
        self.mencoderPathText = wx.TextCtrl(self.preferencesExternalProgramsPane, -1, "")
        self.playerPathLabel = wx.StaticText(self.preferencesExternalProgramsPane, -1, "Path to video player: ")
        self.playerPathText = wx.TextCtrl(self.preferencesExternalProgramsPane, -1, "")
        self.mythtranscodePathLabel = wx.StaticText(self.preferencesExternalProgramsPane, -1, "Path to mythtranscode: ")
        self.mythtranscodePathText = wx.TextCtrl(self.preferencesExternalProgramsPane, -1, "")
        self.preferencesCancelButton = wx.Button(self, wx.ID_CANCEL, "")
        self.preferencesOKButton = wx.Button(self, wx.ID_OK, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onCancelButton, self.preferencesCancelButton)
        self.Bind(wx.EVT_BUTTON, self.onOKButton, self.preferencesOKButton)
        # end wxGlade
        
        # a map of which 'prefs' keys map to which controls in the preferences dialog, and the control type
        # we use this for getting/setting values in the preferences dialog

        self.prefMap = {'mysqlHost': ['TextCtrl', self.mysqlHostText],
                        'mysqlPort': ['TextCtrl', self.mysqlPortText],
                        'mysqlUser': ['TextCtrl', self.mysqlUserText],
                        'mysqlPassword': ['TextCtrl', self.mysqlPasswordText],
                        'mysqlDB': ['TextCtrl', self.mysqlDBNameText],
                        'useMythCutlist': ['Choice', self.useMythCutlistChoice],
                        'mythtvRecordingPath': ['TextCtrl', self.mythtvRecordingText],
                        'containerFormat': ['Choice', self.containerFormatChoice],
                        'videoCodec': ['Choice', self.videoCodecChoice],
                        'videoFirstPassOpts': ['TextCtrl', self.videoFirstPassOptsText],
                        'videoSecondPassOpts': ['TextCtrl', self.videoSecondPassOptsText],
                        'videoFilter': ['TextCtrl', self.videoFilterStringText],
                        'twoPassVideo': ['Choice', self.twoPassVideoChoice],
                        'audioCodec': ['Choice', self.audioCodecChoice],
                        'audioCodecOptions': ['TextCtrl', self.audioCodecOptionsText],
                        'audioFilter': ['TextCtrl', self.audioFilterText],
                        'threadCount': ['Spin', self.threadCountSpin],
                        'removeCompleted': ['Choice', self.removeCompletedChoice],
                        'savePath': ['DirPicker', self.savePathPicker],
                        'fileTemplate': ['TextCtrl', self.fileTemplateText],
                        'mencoderPath': ['TextCtrl', self.mencoderPathText],
                        'playerPath': ['TextCtrl', self.playerPathText],
                        'mythtranscodePath': ['TextCtrl', self.mythtranscodePathText],

                        }

    def __set_properties(self):
        # begin wxGlade: preferencesFrame.__set_properties
        self.SetTitle("MythRip - Preferences")
        self.SetSize((469, 442))
        self.useMythCutlistChoice.SetSelection(0)
        self.containerFormatChoice.SetSelection(0)
        self.videoCodecChoice.SetSelection(0)
        self.twoPassVideoChoice.SetSelection(0)
        self.audioCodecChoice.SetSelection(0)
        self.removeCompletedChoice.SetSelection(0)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: preferencesFrame.__do_layout
        preferencesSizer = wx.BoxSizer(wx.VERTICAL)
        preferencesButtonSizer = wx.BoxSizer(wx.HORIZONTAL)
        externalProgramsSizer = wx.FlexGridSizer(4, 2, 0, 0)
        preferencesFilesSizer = wx.FlexGridSizer(6, 2, 0, 0)
        preferencesQueueSIzer = wx.FlexGridSizer(2, 2, 0, 0)
        preferencesEncodersSizer = wx.FlexGridSizer(7, 2, 0, 0)
        preferencesMythTVSizer = wx.FlexGridSizer(9, 2, 0, 0)
        preferencesMythTVSizer.Add(self.mysqlSettingsLabel, 0, 0, 0)
        preferencesMythTVSizer.Add((20, 20), 0, 0, 0)
        preferencesMythTVSizer.Add(self.mysqlHostLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlHostText, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPortLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPortText, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlUserLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlUserText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mysqlPasswordLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlPasswordText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mysqlDBNameLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mysqlDBNameText, 0, wx.EXPAND, 0)
        preferencesMythTVSizer.Add(self.mythOptionsLabel, 0, wx.TOP, 10)
        preferencesMythTVSizer.Add((20, 20), 0, 0, 0)
        preferencesMythTVSizer.Add(self.useMythCutlistLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.useMythCutlistChoice, 0, 0, 0)
        preferencesMythTVSizer.Add(self.mythtvRecordingPath, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesMythTVSizer.Add(self.mythtvRecordingText, 0, wx.EXPAND, 0)
        self.preferencesMythTVPane.SetSizer(preferencesMythTVSizer)
        preferencesMythTVSizer.AddGrowableCol(1)
        preferencesEncodersSizer.Add(self.FileOptionsLabel, 0, 0, 0)
        preferencesEncodersSizer.Add((10, 10), 0, 0, 0)
        preferencesEncodersSizer.Add(self.containerFormatLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.containerFormatChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoOptionsLabel, 0, wx.TOP|wx.ALIGN_BOTTOM, 10)
        preferencesEncodersSizer.Add((20, 20), 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.twoPassVideoLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.twoPassVideoChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.videoFirstPassOptsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoFirstPassOptsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.videoSecondPassOptsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoSecondPassOptsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.videoFilterStringLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.videoFilterStringText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.audioOptionsLabel, 0, wx.TOP, 10)
        preferencesEncodersSizer.Add((20, 20), 0, 0, 0)
        preferencesEncodersSizer.Add(self.audioCodecLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioCodecChoice, 0, 0, 0)
        preferencesEncodersSizer.Add(self.audioCodecOptionsLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioCodecOptionsText, 0, wx.EXPAND, 0)
        preferencesEncodersSizer.Add(self.audioFilterLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesEncodersSizer.Add(self.audioFilterText, 0, wx.EXPAND, 0)
        self.preferencesEncodersPane.SetSizer(preferencesEncodersSizer)
        preferencesEncodersSizer.AddGrowableCol(1)
        preferencesQueueSIzer.Add(self.threadCountLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.threadCountSpin, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.removeCompletedLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesQueueSIzer.Add(self.removeCompletedChoice, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        self.preferencesQueuePane.SetSizer(preferencesQueueSIzer)
        preferencesQueueSIzer.AddGrowableCol(1)
        preferencesFilesSizer.Add(self.savePathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.savePathPicker, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.fileTemplateLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesFilesSizer.Add(self.fileTemplateText, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        self.preferencesFilesPane.SetSizer(preferencesFilesSizer)
        preferencesFilesSizer.AddGrowableCol(1)
        externalProgramsSizer.Add(self.mencoderPathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        externalProgramsSizer.Add(self.mencoderPathText, 0, wx.EXPAND, 0)
        externalProgramsSizer.Add(self.playerPathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        externalProgramsSizer.Add(self.playerPathText, 0, wx.EXPAND, 0)
        externalProgramsSizer.Add(self.mythtranscodePathLabel, 0, wx.ALIGN_RIGHT|wx.ALIGN_CENTER_VERTICAL, 0)
        externalProgramsSizer.Add(self.mythtranscodePathText, 0, wx.EXPAND, 0)
        self.preferencesExternalProgramsPane.SetSizer(externalProgramsSizer)
        externalProgramsSizer.AddGrowableCol(1)
        self.preferencesNotebook.AddPage(self.preferencesMythTVPane, "MythTV")
        self.preferencesNotebook.AddPage(self.preferencesEncodersPane, "Encoders")
        self.preferencesNotebook.AddPage(self.preferencesQueuePane, "Queue")
        self.preferencesNotebook.AddPage(self.preferencesFilesPane, "Output Files")
        self.preferencesNotebook.AddPage(self.preferencesExternalProgramsPane, "External Programs")
        preferencesSizer.Add(self.preferencesNotebook, 1, wx.EXPAND, 0)
        preferencesButtonSizer.Add(self.preferencesCancelButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesButtonSizer.Add(self.preferencesOKButton, 0, wx.ALIGN_BOTTOM, 0)
        preferencesSizer.Add(preferencesButtonSizer, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(preferencesSizer)
        self.Layout()
        # end wxGlade


    # set the preferences window to the prefs defined in the prefs argument
    def setPreferences(self, prefs):
        self.prefs = prefs
        
        for (prefKey,(controlType,controlVar)) in self.prefMap.iteritems():

            if prefs.has_key( prefKey ):
                
                # set the value according to controlType
                
                if controlType == "TextCtrl": 
                    controlVar.SetValue( str(prefs[ prefKey ]) )
                elif controlType == "Spin":
                    controlVar.SetValue( int(prefs[ prefKey ]) )
                elif controlType == "Choice":
                    controlVar.SetSelection( int(prefs[ prefKey ]) )
                elif controlType == "DirPicker":
                    controlVar.SetPath( str(prefs[ prefKey ]) )
                    

    # load the preferences that are currently set in this frame in to a prefs array and return it
    def getPreferences(self):        
        prefs = {}
        
        for (prefKey,(controlType,controlVar)) in self.prefMap.iteritems():

            # retrieve the value according to controlType
            if controlType in ("TextCtrl","Spin"): # these types all share GetValue()
                value = controlVar.GetValue()
            elif controlType == "Choice":
                value = controlVar.GetCurrentSelection()
            elif controlType == "DirPicker":
                value = controlVar.GetPath()

            # stuff it in to the prefs array
            prefs[ prefKey ] = value

        return prefs


    def onCancelButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        # this event is picked up by the mainframe where the actual saving/load of preferences takes place
        self.Hide()
        event.Skip()

    def onOKButton(self, event): # wxGlade: preferencesFrame.<event_handler>
        # this event is picked up by the mainframe where the actual saving/load of preferences takes place
        self.Hide()
        event.Skip()
        
# end of class preferencesFrame


class mythRipMain(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        self.mainFrameInstance = mainFrame(None, -1, "")
        self.SetTopWindow(self.mainFrameInstance)
        self.mainFrameInstance.Show()
        return 1

# end of class mythRipMain

if __name__ == "__main__":
    mythRip = mythRipMain(0)
    mythRip.MainLoop()

