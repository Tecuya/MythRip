#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Fri May 22 10:25:23 2009

# mythrip: GUI tool to export MythTV recordings to various portable media files, and manage recordings in general

import os
import shutil
import sys
import wx
import mythtv
import threading
import subprocess
import asyncsubprocess
import socket

import time   # for debugging only so far

# begin wxGlade: extracode
# end wxGlade



class mainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        
        toolbarEncode = wx.NewId()
        toolbarView = wx.NewId()
        toolbarDelete = wx.NewId()
        toolbarPrefs = wx.NewId()
        toolbarQuit = wx.NewId()

        # begin wxGlade: mainFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.mainFrameMenubar = wx.MenuBar()
        self.fileMenuItem = wx.Menu()
        self.deleteMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Delete", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.deleteMenuItem)
        self.fileMenuItem.AppendSeparator()
        self.quitMenuItem = wx.MenuItem(self.fileMenuItem, wx.NewId(), "&Quit", "", wx.ITEM_NORMAL)
        self.fileMenuItem.AppendItem(self.quitMenuItem)
        self.mainFrameMenubar.Append(self.fileMenuItem, "&File")
        self.editMenuItem = wx.Menu()
        self.prefsMenuItem = wx.MenuItem(self.editMenuItem, wx.NewId(), "&Preferences", "", wx.ITEM_NORMAL)
        self.editMenuItem.AppendItem(self.prefsMenuItem)
        self.mainFrameMenubar.Append(self.editMenuItem, "&Edit")
        self.viewMenuItem = wx.Menu()
        self.queMenuItem = wx.MenuItem(self.viewMenuItem, wx.NewId(), "&Queue", "", wx.ITEM_NORMAL)
        self.viewMenuItem.AppendItem(self.queMenuItem)
        self.mainFrameMenubar.Append(self.viewMenuItem, "&View")
        self.helpMenuItem = wx.Menu()
        self.aboutMenuItem = wx.MenuItem(self.helpMenuItem, wx.NewId(), "&About", "", wx.ITEM_NORMAL)
        self.helpMenuItem.AppendItem(self.aboutMenuItem)
        self.mainFrameMenubar.Append(self.helpMenuItem, "&Help")
        self.SetMenuBar(self.mainFrameMenubar)
        # Menu Bar end
        self.mainFrameStatusbar = self.CreateStatusBar(1, 0)
        
        # Tool Bar
        self.mainFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.mainFrameToolbar)
        self.mainFrameToolbar.AddLabelTool(toolbarEncode, "Encode", wx.Bitmap("/usr/share/icons/gnome/32x32/categories/applications-system.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Encode selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarView, "View", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-media-play-ltr.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "View selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarDelete, "Delete", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/stock_delete.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Delete selected recordings(s)", "")
        self.mainFrameToolbar.AddLabelTool(toolbarPrefs, "Preferences", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        self.mainFrameToolbar.AddLabelTool(toolbarQuit, "Quit", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/application-exit.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "", "")
        # Tool Bar end
        self.mainFrameListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.LC_EDIT_LABELS|wx.LC_SORT_ASCENDING|wx.SUNKEN_BORDER)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.onMenuDelete, self.deleteMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuQuit, self.quitMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuPrefs, self.prefsMenuItem)
        self.Bind(wx.EVT_MENU, self.onMenuQueue, self.queMenuItem)
        self.Bind(wx.EVT_TOOL, self.onToolbarEncode, id=toolbarEncode)
        self.Bind(wx.EVT_TOOL, self.onToolbarDelete, id=toolbarDelete)
        self.Bind(wx.EVT_TOOL, self.onToolbarPrefs, id=toolbarPrefs)
        self.Bind(wx.EVT_TOOL, self.onToolbarQuit, id=toolbarQuit)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.onColClick, self.mainFrameListCtrl)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.onItemRightClick, self.mainFrameListCtrl)
        # end wxGlade

        ################################################################################
        
        # initialize the encoder queue window
        self.encoderQueueFrame = encoderQueueFrame(parent=self)
        
        # establish our MythTV connection using the mythtv python bindings
        try: 
            self.mythTV = mythtv.MythTV()
        except mythtv.MythError, e:
            print "Failed initializing MythTV environment; %s" % e.message
        
        # query recordings from the backend
        rawRecordings = self.mythTV.backendCommand('QUERY_RECORDINGS Play').split(mythtv.BACKEND_SEP)
        
        # determine the record length and number of recordings present in the response
        numberRecordings = int(rawRecordings[0])        
        recordingLength = (len(rawRecordings) - 1) / numberRecordings
        
        # parse the output, stuff the results in to a list of Program objects
        self.programList = []
        
        for recording in range(numberRecordings):            
            idxStart = ( recording * recordingLength ) + 1    # plus one - offset for the beginning's "record count" record
            idxStop = ( recording + 1 ) * recordingLength     # stop at the next recording beginning
            
            recordingData = rawRecordings[idxStart:idxStop]
            
            print "RECORDING: ",recordingData,"------------------------------------------------------\n\n\n"

            self.programList.append( mythtv.Program( recordingData ) )

        # add recording count to the status bar
        self.mainFrameStatusbar.PushStatusText('Loaded %d recordings' % len(self.programList))
        
        # set up the ListCtrl columns
        self.mainFrameListCtrl.InsertColumn(0, "Show")
        self.mainFrameListCtrl.InsertColumn(1, "Episode")
        self.mainFrameListCtrl.InsertColumn(2, "Air Time")
        self.mainFrameListCtrl.InsertColumn(3, "Flags")
        
        # push in the ListCtrl data
        for i in range(len(self.programList)):
            program = self.programList[i]
            self.mainFrameListCtrl.InsertStringItem(i, program.title)
            self.mainFrameListCtrl.SetStringItem(i, 1, program.subtitle)
            self.mainFrameListCtrl.SetStringItem(i, 2, str(program.starttime))
            
            # unpack program flags to english strings
            flags = []
            for k,v in mythtv.PROGRAM_FLAGS.iteritems():
                if int(program.programflags) & v:
                    flags.append(k)

            self.mainFrameListCtrl.SetStringItem(i, 3, ', '.join(flags) )
            self.mainFrameListCtrl.SetItemData(i, i)  # set item datas to be the same as indexes initially
            
        # make nice column sizes
        self.mainFrameListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.mainFrameListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)
        
        # these variables are for preserving the sorting state
        self.lastColClick = 0
        self.sortToggler = 1

        # run an initial sort
        self.mainFrameListCtrl.SortItems( self.sortList ) 
        
        # prepare the right-click context menu entry definitions
        self.contextMenuEntriesById = {}
        for item in [ "Preview", "Delete", "Encode" ]:
            self.contextMenuEntriesById[ wx.NewId() ] = item

    def __set_properties(self):
        # begin wxGlade: mainFrame.__set_properties
        self.SetTitle("MythRip - Main")
        self.SetSize((720, 430))
        self.mainFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        mainFrameStatusbar_fields = ["mainFrame_statusbar"]
        for i in range(len(mainFrameStatusbar_fields)):
            self.mainFrameStatusbar.SetStatusText(mainFrameStatusbar_fields[i], i)
        self.mainFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: mainFrame.__do_layout
        mainFrameSizer = wx.BoxSizer(wx.HORIZONTAL)
        mainFrameSizer.Add(self.mainFrameListCtrl, 1, wx.EXPAND, 0)
        self.SetSizer(mainFrameSizer)
        self.Layout()
        # end wxGlade

    # this is the callback to sort the mainFrameListCtrl used by mainFrameListCtrl.SortItems
    def sortList(self, item1, item2):
                        
        progLeft = self.programList[ item1 ]
        progRight = self.programList[ item2 ]
        
        if self.lastColClick == 0:
            if progLeft.title < progRight.title:
                return -1 * self.sortToggler
            elif progLeft.title == progRight.title:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 1:
            if progLeft.subtitle < progRight.subtitle:
                return -1 * self.sortToggler
            elif progLeft.subtitle == progRight.subtitle:
                return 0
            else:
                return 1 * self.sortToggler

        if self.lastColClick == 2:
            if progLeft.starttime < progRight.starttime:
                return -1 * self.sortToggler
            elif progLeft.starttime == progRight.starttime:
                return 0
            else:
                return 1 * self.sortToggler

        return 0
    
    
    # this function returns a list of the mythtv Program objects that have been selected
    def getSelectedPrograms(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.mainFrameListCtrl.GetFirstSelected()
        while item != -1:
            program = self.programList[ self.mainFrameListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.mainFrameListCtrl.GetNextSelected(item)
        
        return returnList
        
    def addRecordingsToQueue(self):
        
        addcount = 0
        for program in self.getSelectedPrograms():
            self.encoderQueueFrame.addProgram(program)
            addcount += 1

        self.mainFrameStatusbar.PushStatusText('Added %d recordings to queue.' % addcount)
            
        

    ###########################################################################
    # event handler land

        
    def onMenuQuit(self, event): # wxGlade: mainFrame.<event_handler>
        sys.exit()


    def onItemRightClick(self, event): # wxGlade: mainFrame.<event_handler>
        
        menu = wx.Menu()

        for (id,title) in self.contextMenuEntriesById.iteritems():
            menu.Append(id, title)
            wx.EVT_MENU( menu, id, self.onContextMenuSelection )
            
        self.PopupMenu( menu )

        event.Skip()

    def onColClick(self, event): # wxGlade: mainFrame.<event_handler>

        clickedCol = event.GetColumn()

        if (clickedCol == self.lastColClick):
            self.sortToggler *= -1
        else:
            self.sortToggler = 1

        self.lastColClick = clickedCol
        
        self.mainFrameListCtrl.SortItems( self.sortList ) 

        event.Skip()


    def onContextMenuSelection(self, event):        
        selectedMenuItem = self.contextMenuEntriesById[ event.GetId() ]
        if selectedMenuItem == "Encode":
            self.addRecordingsToQueue()
        event.Skip()
        
    def onMenuQueue(self, event): # wxGlade: mainFrame.<event_handler>        
        print "showing encoderQueueFrame.."
        self.encoderQueueFrame.Show()
        event.Skip()

    def onToolbarEncode(self, event): # wxGlade: mainFrame.<event_handler>
        self.addRecordingsToQueue()
        event.Skip()

    def onToolbarDelete(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarDelete' not implemented"
        event.Skip()

    def onMenuDelete(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onMenuDelete' not implemented"
        event.Skip()

    def onMenuPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onMenuPrefs' not implemented"
        event.Skip()

    def onToolbarPrefs(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarPrefs' not implemented"
        event.Skip()

    def onToolbarQuit(self, event): # wxGlade: mainFrame.<event_handler>
        print "Event handler `onToolbarQuit' not implemented"
        event.Skip()

# end of class mainFrame





class aboutFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: aboutFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.aboutFrameContents = wx.StaticText(self, -1, "About MythRIP", style=wx.ALIGN_CENTRE)
        self.aboutFrameCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: aboutFrame.__set_properties
        self.SetTitle("MythRip - About")
        self.aboutFrameCloseButton.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: aboutFrame.__do_layout
        aboutFrameSizer = wx.BoxSizer(wx.VERTICAL)
        aboutFrameSizer.Add(self.aboutFrameContents, 0, wx.BOTTOM|wx.EXPAND, 0)
        aboutFrameSizer.Add(self.aboutFrameCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(aboutFrameSizer)
        aboutFrameSizer.Fit(self)
        self.Layout()
        # end wxGlade

# end of class aboutFrame


class encoderOptionsFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: encoderOptionsFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.encoderOptionsFrameStatusbar = self.CreateStatusBar(1, 0)

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: encoderOptionsFrame.__set_properties
        self.SetTitle("MythRip - Encoder Options")
        self.SetSize((400, 300))
        self.encoderOptionsFrameStatusbar.SetStatusWidths([-1])
        # statusbar fields
        encoderOptionsFrameStatusbar_fields = ["encoderOptionsFrame_statusbar"]
        for i in range(len(encoderOptionsFrameStatusbar_fields)):
            self.encoderOptionsFrameStatusbar.SetStatusText(encoderOptionsFrameStatusbar_fields[i], i)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderOptionsFrame.__do_layout
        self.Layout()
        # end wxGlade

# end of class encoderOptionsFrame


class encoderQueueFrame(wx.Frame):
    def __init__(self, *args, **kwds):


        toolbarPause = wx.NewId()
        toolbarRemove = wx.NewId()
        toolbarUp = wx.NewId()
        toolbarDown = wx.NewId()
        toolbarOptions = wx.NewId()

        # begin wxGlade: encoderQueueFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Tool Bar
        self.encoderQueueFrameToolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.encoderQueueFrameToolbar)
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarPause, "Pause", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-media-pause.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Pause selected job(s)", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarRemove, "Remove", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-cancel.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Remove from queue", "Remove an item from the encoding queue")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarUp, "Up", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-up.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected recording(s) up", "")
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarDown, "Down", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/gtk-go-down.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move selected recording(s) down", "")
        self.encoderQueueFrameToolbar.AddSeparator()
        self.encoderQueueFrameToolbar.AddLabelTool(toolbarOptions, "Options", wx.Bitmap("/usr/share/icons/gnome/32x32/actions/document-properties.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Open the queue options dialog", "")
        # Tool Bar end
        self.encoderQueueListCtrl = wx.ListCtrl(self, -1, style=wx.LC_REPORT|wx.SUNKEN_BORDER)
        self.encoderQueueCloseButton = wx.Button(self, wx.ID_CLOSE, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_TOOL, self.onToolbarPause, id=toolbarPause)
        self.Bind(wx.EVT_TOOL, self.onToolbarRemove, id=toolbarRemove)
        self.Bind(wx.EVT_TOOL, self.onToolbarUp, id=toolbarUp)
        self.Bind(wx.EVT_TOOL, self.onToolbarDown, id=toolbarDown)
        self.Bind(wx.EVT_TOOL, self.onToolbarOptions, id=toolbarOptions)
        self.Bind(wx.EVT_BUTTON, self.onCloseButton, self.encoderQueueCloseButton)
        # end wxGlade
        
        ##########################
        
        # this variable tracks the thread IDs .. 
        # because I use this style of identifying threads eventually the ID would wrap.. so there's the app's max threads limit!
        self.nextThreadID = 0

        # this variable contains a list of encoder jobs, including their thread handles
        self.threads = {}

        # set up the listctrl
        self.encoderQueueListCtrl.InsertColumn(0, "Show")
        self.encoderQueueListCtrl.InsertColumn(1, "Episode")
        self.encoderQueueListCtrl.InsertColumn(2, "Air Time")
        self.encoderQueueListCtrl.InsertColumn(3, "Progress")
        
        # connect up a handler to update the GUI upon events from the encoder threads
        EVT_ENCODER(self, self.onEncoderEvent)    
        

    def __set_properties(self):
        # begin wxGlade: encoderQueueFrame.__set_properties
        self.SetTitle("MythRip - Encoding Queue")
        self.SetSize((640, 300))
        self.encoderQueueFrameToolbar.Realize()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: encoderQueueFrame.__do_layout
        encoderQueueSizer = wx.BoxSizer(wx.VERTICAL)
        encoderQueueSizer.Add(self.encoderQueueListCtrl, 1, wx.EXPAND, 0)
        encoderQueueSizer.Add(self.encoderQueueCloseButton, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.SetSizer(encoderQueueSizer)
        self.Layout()
        # end wxGlade

    ##########################################################################################
    # meat

    def addProgram(self,program):
        
        # grab the next thread id
        threadID = self.nextThreadID
        
        # prepare the thread id for the thread after this one
        self.nextThreadID += 1
        
        # create the thread.  
        self.threads[threadID] = encoderThread(program, threadID, self)
        self.threads[threadID].start()
                
        # determine the number of items in the control and add in the next available slot
        newListIndex = self.encoderQueueListCtrl.GetItemCount()

        # insert the new list ctrl item
        self.encoderQueueListCtrl.InsertStringItem(newListIndex, program.title)
        self.encoderQueueListCtrl.SetStringItem(newListIndex, 1, program.subtitle)
        self.encoderQueueListCtrl.SetStringItem(newListIndex, 2, str(program.starttime))
        self.encoderQueueListCtrl.SetStringItem(newListIndex, 3, 'Initializing...')
        self.encoderQueueListCtrl.SetItemData(newListIndex, threadID) # store the thread id with each item

        # keep the table clean with some column resizing
        self.resizeEncoderQueueListCtrl()
                
    def getSelectedEncoders(self):
        
        # iterate through items in the list control, reconcile them to program objects, form a list, return it
        returnList = []

        item = self.encoderQueueListCtrl.GetFirstSelected()
        while item != -1:
            thread = self.threads[ self.encoderQueueListCtrl.GetItemData(item) ]                        
            returnList.append(program)
            item = self.encoderQueueListCtrl.GetNextSelected(item)
        
        return returnList


    def resizeEncoderQueueListCtrl(self):
        self.encoderQueueListCtrl.SetColumnWidth(0, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(1, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(2, wx.LIST_AUTOSIZE)
        self.encoderQueueListCtrl.SetColumnWidth(3, wx.LIST_AUTOSIZE)
    
    ##########################################################################################
    # event handlers


    # when an encoder event is received this is called
    def onEncoderEvent(self, event):

        print "Thread %d state %s : %s" % (event.threadID, event.threadState, event.listMessage)
        
        # we pretty much need this no matter what
        listCtrlIndex = self.encoderQueueListCtrl.FindItemData(0,event.threadID)
        
        if event.threadState == "terminating":
            # if the thread died, remove it from the thread pool, and remove the item from the listctrl

            print "Thread %d removed from thread pool." % event.threadID
            
            del self.threads[event.threadID]
            
            print "- Thread %d is at position %d in the list ctrl, removing it" % (event.threadID,listCtrlIndex)
            
            self.encoderQueueListCtrl.DeleteItem(listCtrlIndex)
            

        self.encoderQueueListCtrl.SetStringItem(listCtrlIndex, 3, event.listMessage)
        
        event.Skip()

    def onCloseButton(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        self.Hide()
        event.Skip()

    def onToolbarPause(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        
        print "Event handler `onToolbarPause' not implemented"
        event.Skip()

    def onToolbarRemove(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarRemove' not implemented"
        event.Skip()

    def onToolbarUp(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarUp' not implemented"
        event.Skip()

    def onToolbarDown(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarDown' not implemented"
        event.Skip()

    def onToolbarOptions(self, event): # wxGlade: encoderQueueFrame.<event_handler>
        print "Event handler `onToolbarOptions' not implemented"
        event.Skip()

# end of class encoderQueueFrame

###################################################################
# encoder thread land

# get an ID for an "encoder" event 
EVT_ENCODER_ID = wx.NewId()

# define a macro for connecting event handlers to the encoder events
def EVT_ENCODER(theWin, theFunc):
   theWin.Connect(-1, -1, EVT_ENCODER_ID, theFunc)

# a simple event to throw out of the encoder
class encoderEvent(wx.PyEvent):
   def __init__(self, threadID, threadState, listMessage):
       wx.PyEvent.__init__(self)
       self.SetEventType(EVT_ENCODER_ID)
       self.threadID = threadID
       self.threadState = threadState
       self.listMessage = listMessage

# the encoder thread itself
class encoderThread(threading.Thread):
    
    def __init__(self, program, threadID, notifyWindow):
        
        self.notifyWindow = notifyWindow
        self.program = program
        self.threadID = threadID
        self.doCommand = ""
        self.mythTranscodeProcess = False

        # load parent constructor
        threading.Thread.__init__(self)
    
    def run(self):
                
        print "Thread ID %d : %s" % (self.threadID, self.program)
        
        # get directory for our fifos to live in
        fifoDir = '/tmp/mythrip-%d-fifo' % self.threadID

        if os.path.isdir(fifoDir):
            try:
                shutil.rmtree(fifoDir)
            except Exception, e:
                self.endThread("failed","Could not remove stale fifo directory: %s" % e)

        try:
            os.mkdir(fifoDir)
        except Exception, e:
            self.endThread("failed","Failed creating fifo directories: %s" % e)

        # fire up mythtranscode 
        mythTranscodeCmd = ['/usr/bin/mythtranscode',
               '--showprogress',
               '-p','autodetect',
               '-c',str(self.program.chanid),
               '-s',self.program.recstartts.strftime('%Y-%m-%dT%H:%M:%S'),
               '-f',fifoDir,
               '--honorcutlist']
        
        
        # use sockets for the subprocess file objects so we can read from stdout/stderr in a non-blocking fashion
        self.stdoutSockMT, stdoutChildSockMT = socket.socketpair() 
        self.stderrSockMT, stderrChildSockMT = socket.socketpair() 
        self.stdoutSockMT.settimeout(0.1)
        self.stderrSockMT.settimeout(0.1)

        self.mythTranscodeProcess = subprocess.Popen(mythTranscodeCmd, stdin=None, stdout=stdoutChildSockMT.fileno(), stderr=stderrChildSockMT.fileno())

        # replace me with a thing that waits to verify the fifo is up and ready
        time.sleep(1)
        
        # now fire up mencoder reading from mythtranscode's fifo
        # mencoder -aspect 1.33333333333333 -noskip -idx /tmp/fifodir_7895/vidout -audiofile /tmp/fifodir_7895/audout -demuxer 20 -audio-demuxer 20 -rawaudio rate=48000:channels=2 -demuxer 26 -rawvideo w=720:h=480:fps=29.970 -ovc xvid -passlogfile /tmp/xvid.7895.log -oac copy -xvidencopts bitrate=684:pass=1:quant_type=mpeg:threads=2:keyframe_boost=10:kfthreshold=1:kfreduction=20 -o /dev/null -vf crop=700:468:10:6,lavcdeint,scale=640:480

        mencoderCmd = ['/usr/bin/mencoder','-noskip','-idx',
                       os.path.join(fifoDir, 'vidout'),
                       '-audiofile', os.path.join(fifoDir,'audout'),
                       '-demuxer','20','-audio-demuxer','20',
                       '-rawvideo','w=720:h=480:fps=29.970',
                       '-rawaudio','rate=48000:channels=2','-demuxer','26',# '-rawvideo',
                       '-ovc','xvid','-oac','copy','-xvidencopts','bitrate=684','-vf','lavcdeint',
                       '-o', '/home/sean/Desktop/video-thread-%d.avi' % self.threadID]

        self.stdoutSockMenc, stdoutChildSockMenc = socket.socketpair() 
        self.stderrSockMenc, stderrChildSockMenc = socket.socketpair() 
        self.stdoutSockMenc.settimeout(0.1)
        self.stderrSockMenc.settimeout(0.1)
        
        self.mencoderProcess = subprocess.Popen(mencoderCmd, stdin=None, stdout=stdoutChildSockMT.fileno(), stderr=stderrChildSockMT.fileno())
    

        
        self.sendEncoderEvent( "started", "Encoding started." )

        while True:
            
            self.parseSubprocessOutput()
            
            # it seems we are getting a None result before the thread actually dies
            # if self.mythTranscodeProcess.poll() == None:                
            # self.parseSubprocessOutput()
            # self.endThread("done","Encoder poll returned None")                
            # break

            # check for the abort command and if its there then bail!
            if self.doCommand == "abort":
                self.endThread("abort","Thread aborted.")
                break

            # wait a second before checking the subprocess again
            time.sleep(1)

        
    def parseSubprocessOutput(self):
        
        # read from all processes
        for (name,(stdoutSock,stderrSock)) in {"mt": [self.stdoutSockMT, self.stderrSockMT], 
                                               "menc": [self.stdoutSockMenc, self.stderrSockMenc] }.iteritems():
            newstdout = ""
            newstderr = ""

            try:
                newstdout = stdoutSock.recv(1024)
                newstderr = stderrSock.recv(1024)

            except socket.timeout, e:
                pass 

            # print em out if there was anything
            if len(newstdout):
                print "STDOUT %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstdout)
            if len(newstderr):
                print "STDERR %s-------------------------------------------\n%s\n------------------------------------------------\n" % (name,newstderr)



    # func called by the main thread in order to issue commands
    def setCommand(self,command):
        self.doCommand = setCommand

    def endThread(self,threadState,listMessage):

        # i'm hoping this kills the subprocess... if not i might just use process.pid to kill it
        del self.mythTranscodeProcess

        # the last thing the thread does is tell the main thread its terminating, and thats a rule
        self.sendEncoderEvent( threadState, listMessage )

        sys.exit()
       
    def sendEncoderEvent(self, threadState, listMessage):
        wx.PostEvent(self.notifyWindow, encoderEvent(self.threadID, threadState, listMessage))

###########################################################################
        

class preferencesFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: preferencesFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.preferencesNotebook = wx.Notebook(self, -1, style=0)
        self.preferencesMythTVPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesEncodersPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesFilenamesPane = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesNotebook_pane_4 = wx.Panel(self.preferencesNotebook, -1)
        self.preferencesCancelButton = wx.Button(self, wx.ID_CANCEL, "")
        self.preferencesOKButton = wx.Button(self, wx.ID_OK, "")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: preferencesFrame.__set_properties
        self.SetTitle("MythRip - Preferences")
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: preferencesFrame.__do_layout
        preferencesSizer = wx.BoxSizer(wx.VERTICAL)
        preferencesButtonSizer = wx.BoxSizer(wx.HORIZONTAL)
        self.preferencesNotebook.AddPage(self.preferencesMythTVPane, "MythTV")
        self.preferencesNotebook.AddPage(self.preferencesEncodersPane, "Encoders")
        self.preferencesNotebook.AddPage(self.preferencesFilenamesPane, "Queue")
        self.preferencesNotebook.AddPage(self.preferencesNotebook_pane_4, "Files")
        preferencesSizer.Add(self.preferencesNotebook, 1, wx.EXPAND, 0)
        preferencesButtonSizer.Add(self.preferencesCancelButton, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesButtonSizer.Add(self.preferencesOKButton, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 0)
        preferencesSizer.Add(preferencesButtonSizer, 4, wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 0)
        self.SetSizer(preferencesSizer)
        preferencesSizer.Fit(self)
        self.Layout()
        # end wxGlade

# end of class preferencesFrame


class mythRipMain(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        self.mainFrameInstance = mainFrame(None, -1, "")
        self.SetTopWindow(self.mainFrameInstance)
        self.mainFrameInstance.Show()
        return 1

# end of class mythRipMain

if __name__ == "__main__":
    mythRip = mythRipMain(0)
    mythRip.MainLoop()
